MMAP(3P)                                                                                 POSIX Programmer's Manual                                                                                MMAP(3P)

PROLOG
       This  manual  page is part of the POSIX Programmer's Manual.  The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or
       the interface may not be implemented on Linux.

NAME
       mmap — map pages of memory

SYNOPSIS
       #include <sys/mman.h>

       void *mmap(void *addr, size_t len, int prot, int flags,
           int fildes, off_t off);

DESCRIPTION
       The mmap() function shall establish a mapping between an address space of a process and a memory object.

       The mmap() function shall be supported for the following memory objects:

        *  Regular files

        *  Shared memory objects

        *  Typed memory objects

       Support for any other type of file is unspecified.

       The format of the call is as follows:

           pa=mmap(addr, len, prot, flags, fildes, off);

       The mmap() function shall establish a mapping between the address space of the process at an address pa for len bytes to the memory object represented by the file descriptor fildes at offset  off
       for  len  bytes.  The value of pa is an implementation-defined function of the parameter addr and the values of flags, further described below. A successful mmap() call shall return pa as its re‐
       sult. The address range starting at pa and continuing for len bytes shall be legitimate for the possible (not necessarily current) address space of the process. The range of bytes starting at off
       and continuing for len bytes shall be legitimate for the possible (not necessarily current) offsets in the memory object represented by fildes.

       If  fildes  represents a typed memory object opened with either the POSIX_TYPED_MEM_ALLOCATE flag or the POSIX_TYPED_MEM_ALLOCATE_CONTIG flag, the memory object to be mapped shall be that portion
       of the typed memory object allocated by the implementation as specified below. In this case, if off is non-zero, the behavior of mmap() is undefined. If fildes refers to a valid typed memory  ob‐
       ject that is not accessible from the calling process, mmap() shall fail.

       The mapping established by mmap() shall replace any previous mappings for those whole pages containing any part of the address space of the process starting at pa and continuing for len bytes.

       If  the  size of the mapped file changes after the call to mmap() as a result of some other operation on the mapped file, the effect of references to portions of the mapped region that correspond
       to added or removed portions of the file is unspecified.

       If len is zero, mmap() shall fail and no mapping shall be established.

       The parameter prot determines whether read, write, execute, or some combination of accesses are permitted to the data being mapped. The prot shall be either PROT_NONE or the bitwise-inclusive  OR
       of one or more of the other flags in the following table, defined in the <sys/mman.h> header.

                                                                                 ┌──────────────────┬──────────────────────────┐
                                                                                 │Symbolic Constant │       Description        │
                                                                                 ├──────────────────┼──────────────────────────┤
                                                                                 │PROT_READ         │ Data can be read.        │
                                                                                 │PROT_WRITE        │ Data can be written.     │
                                                                                 │PROT_EXEC         │ Data can be executed.    │
                                                                                 │PROT_NONE         │ Data cannot be accessed. │
                                                                                 └──────────────────┴──────────────────────────┘
       If an implementation cannot support the combination of access types specified by prot, the call to mmap() shall fail.

       An  implementation  may  permit accesses other than those specified by prot; however, the implementation shall not permit a write to succeed where PROT_WRITE has not been set and shall not permit
       any access where PROT_NONE alone has been set. The implementation shall support at least the following values of prot: PROT_NONE, PROT_READ, PROT_WRITE, and the bitwise-inclusive OR of  PROT_READ
       and  PROT_WRITE.  The  file descriptor fildes shall have been opened with read permission, regardless of the protection options specified. If PROT_WRITE is specified, the application shall ensure
       that it has opened the file descriptor fildes with write permission unless MAP_PRIVATE is specified in the flags parameter as described below.

       The parameter flags provides other information about the handling of the mapped data.  The value of flags is the bitwise-inclusive OR of these options, defined in <sys/mman.h>:

                                                                                  ┌──────────────────┬─────────────────────────┐
                                                                                  │Symbolic Constant │       Description       │
                                                                                  ├──────────────────┼─────────────────────────┤
                                                                                  │MAP_SHARED        │ Changes are shared.     │
                                                                                  │MAP_PRIVATE       │ Changes are private.    │
                                                                                  │MAP_FIXED         │ Interpret addr exactly. │
                                                                                  └──────────────────┴─────────────────────────┘
       It is implementation-defined whether MAP_FIXED shall be supported.  MAP_FIXED shall be supported on XSI-conformant systems.

       MAP_SHARED and MAP_PRIVATE describe the disposition of write references to the memory object. If MAP_SHARED is specified, write references shall change the underlying object.  If  MAP_PRIVATE  is
       specified,  modifications  to  the mapped data by the calling process shall be visible only to the calling process and shall not change the underlying object.  It is unspecified whether modifica‐
       tions to the underlying object done after the MAP_PRIVATE mapping is established are visible through the MAP_PRIVATE mapping. Either MAP_SHARED or MAP_PRIVATE can be specified, but not both.  The
       mapping type is retained across fork().

       The  state of synchronization objects such as mutexes, semaphores, barriers, and conditional variables placed in shared memory mapped with MAP_SHARED becomes undefined when the last region in any
       process containing the synchronization object is unmapped.

       When fildes represents a typed memory object opened with either the POSIX_TYPED_MEM_ALLOCATE flag or the POSIX_TYPED_MEM_ALLOCATE_CONTIG flag, mmap() shall, if there are enough  resources  avail‐
       able, map len bytes allocated from the corresponding typed memory object which were not previously allocated to any process in any processor that may access that typed memory object. If there are
       not enough resources available, the function shall fail. If fildes represents a typed memory object opened with the POSIX_TYPED_MEM_ALLOCATE_CONTIG flag, these allocated bytes shall be contiguous
       within  the typed memory object. If fildes represents a typed memory object opened with the POSIX_TYPED_MEM_ALLOCATE flag, these allocated bytes may be composed of non-contiguous fragments within
       the typed memory object. If fildes represents a typed memory object opened with neither the POSIX_TYPED_MEM_ALLOCATE_CONTIG flag nor the POSIX_TYPED_MEM_ALLOCATE flag, len bytes starting at  off‐
       set  off  within  the typed memory object are mapped, exactly as when mapping a file or shared memory object. In this case, if two processes map an area of typed memory using the same off and len
       values and using file descriptors that refer to the same memory pool (either from the same port or from a different port), both processes shall map the same region of storage.

       When MAP_FIXED is set in the flags argument, the implementation is informed that the value of pa shall be addr, exactly. If MAP_FIXED is set, mmap() may return MAP_FAILED and set errno  to  [EIN‐
       VAL].   If  a  MAP_FIXED request is successful, then any previous mappings or memory locks for those whole pages containing any part of the address range [pa,pa+len) shall be removed, as if by an
       appropriate call to munmap(), before the new mapping is established.

       When MAP_FIXED is not set, the implementation uses addr in an implementation-defined manner to arrive at pa.  The pa so chosen shall be an area of the address space that the implementation  deems
       suitable for a mapping of len bytes to the file. All implementations interpret an addr value of 0 as granting the implementation complete freedom in selecting pa, subject to constraints described
       below. A non-zero value of addr is taken to be a suggestion of a process address near which the mapping should be placed. When the implementation selects a value for pa, it never places a mapping
       at address 0, nor does it replace any extant mapping.

       If MAP_FIXED is specified and addr is non-zero, it shall have the same remainder as the off parameter, modulo the page size as returned by sysconf() when passed _SC_PAGESIZE or _SC_PAGE_SIZE. The
       implementation may require that off is a multiple of the page size. If MAP_FIXED is specified, the implementation may require that addr is a multiple of the page size. The system performs mapping
       operations  over whole pages. Thus, while the parameter len need not meet a size or alignment constraint, the system shall include, in any mapping operation, any partial page specified by the ad‐
       dress range starting at pa and continuing for len bytes.

       The system shall always zero-fill any partial page at the end of an object. Further, the system shall never write out any modified portions of the last page of an object which are beyond its end.
       References within the address range starting at pa and continuing for len bytes to whole pages following the end of an object shall result in delivery of a SIGBUS signal.

       An implementation may generate SIGBUS signals when a reference would cause an error in the mapped object, such as out-of-space condition.

       The  mmap() function shall add an extra reference to the file associated with the file descriptor fildes which is not removed by a subsequent close() on that file descriptor. This reference shall
       be removed when there are no more mappings to the file.

       The last data access timestamp of the mapped file may be marked for update at any time between the mmap() call and the corresponding munmap() call. The initial read or write reference to a mapped
       region shall cause the file's last data access timestamp to be marked for update if it has not already been marked for update.

       The  last data modification and last file status change timestamps of a file that is mapped with MAP_SHARED and PROT_WRITE shall be marked for update at some point in the interval between a write
       reference to the mapped region and the next call to msync() with MS_ASYNC or MS_SYNC for that portion of the file by any process.  If there is no such call and if the underlying file is  modified
       as a result of a write reference, then these timestamps shall be marked for update at some time after the write reference.

       There may be implementation-defined limits on the number of memory regions that can be mapped (per process or per system).

       If such a limit is imposed, whether the number of memory regions that can be mapped by a process is decreased by the use of shmat() is implementation-defined.

       If mmap() fails for reasons other than [EBADF], [EINVAL], or [ENOTSUP], some of the mappings in the address range starting at addr and continuing for len bytes may have been unmapped.

RETURN VALUE
       Upon  successful  completion, the mmap() function shall return the address at which the mapping was placed (pa); otherwise, it shall return a value of MAP_FAILED and set errno to indicate the er‐
       ror. The symbol MAP_FAILED is defined in the <sys/mman.h> header. No successful return from mmap() shall return the value MAP_FAILED.

ERRORS
       The mmap() function shall fail if:

       EACCES The fildes argument is not open for read, regardless of the protection specified, or fildes is not open for write and PROT_WRITE was specified for a MAP_SHARED type mapping.

       EAGAIN The mapping could not be locked in memory, if required by mlockall(), due to a lack of resources.

       EBADF  The fildes argument is not a valid open file descriptor.

       EINVAL The value of len is zero.

       EINVAL The value of flags is invalid (neither MAP_PRIVATE nor MAP_SHARED is set).

       EMFILE The number of mapped regions would exceed an implementation-defined limit (per process or per system).

       ENODEV The fildes argument refers to a file whose type is not supported by mmap().

       ENOMEM MAP_FIXED was specified, and the range [addr,addr+len) exceeds that allowed for the address space of a process; or, if MAP_FIXED was not specified and there is insufficient room in the ad‐
              dress space to effect the mapping.

       ENOMEM The mapping could not be locked in memory, if required by mlockall(), because it would require more space than the system is able to supply.

       ENOMEM Not enough unallocated memory resources remain in the typed memory object designated by fildes to allocate len bytes.

       ENOTSUP
              MAP_FIXED or MAP_PRIVATE was specified in the flags argument and the implementation does not support this functionality.

                   The implementation does not support the combination of accesses requested in the prot argument.

       ENXIO  Addresses in the range [off,off+len) are invalid for the object specified by fildes.

       ENXIO  MAP_FIXED was specified in flags and the combination of addr, len, and off is invalid for the object specified by fildes.

       ENXIO  The fildes argument refers to a typed memory object that is not accessible from the calling process.

       EOVERFLOW
              The file is a regular file and the value of off plus len exceeds the offset maximum established in the open file description associated with fildes.

       The mmap() function may fail if:

       EINVAL The addr argument (if MAP_FIXED was specified) or off is not a multiple of the page size as returned by sysconf(), or is considered invalid by the implementation.

       The following sections are informative.

EXAMPLES
       None.

APPLICATION USAGE
       Use of mmap() may reduce the amount of memory available to other memory allocation functions.

       Use  of  MAP_FIXED may result in unspecified behavior in further use of malloc() and shmat().  The use of MAP_FIXED is discouraged, as it may prevent an implementation from making the most effec‐
       tive use of resources. Most implementations require that off and addr are multiples of the page size as returned by sysconf().

       The application must ensure correct synchronization when using mmap() in conjunction with any other file access method, such as read() and write(), standard input/output, and shmat().

       The mmap() function allows access to resources via address space manipulations, instead of read()/write().  Once a file is mapped, all a process has to do to access it is use the data at the  ad‐
       dress to which the file was mapped. So, using pseudo-code to illustrate the way in which an existing program might be changed to use mmap(), the following:

           fildes = open(...)
           lseek(fildes, some_offset)
           read(fildes, buf, len)
           /* Use data in buf. */

       becomes:

           fildes = open(...)
           address = mmap(0, len, PROT_READ, MAP_PRIVATE, fildes, some_offset)
           /* Use data at address. */

RATIONALE
       After  considering  several other alternatives, it was decided to adopt the mmap() definition found in SVR4 for mapping memory objects into process address spaces. The SVR4 definition is minimal,
       in that it describes only what has been built, and what appears to be necessary for a general and portable mapping facility.

       Note that while mmap() was first designed for mapping files, it is actually a general-purpose mapping facility. It can be used to map any appropriate object, such as memory, files,  devices,  and
       so on, into the address space of a process.

       When  a  mapping  is established, it is possible that the implementation may need to map more than is requested into the address space of the process because of hardware requirements. An applica‐
       tion, however, cannot count on this behavior. Implementations that do not use a paged architecture may simply allocate a common memory region and return the address of  it;  such  implementations
       probably do not allocate any more than is necessary. References past the end of the requested area are unspecified.

       If  an  application requests a mapping that overlaps existing mappings in the process, it might be desirable that an implementation detect this and inform the application. However, if the program
       specifies a fixed address mapping (which requires some implementation knowledge to determine a suitable address, if the function is supported at all), then the program is presumed to be  success‐
       fully  managing  its  own  address space and should be trusted when it asks to map over existing data structures. Furthermore, it is also desirable to make as few system calls as possible, and it
       might be considered onerous to require an munmap() before an mmap() to the same address range. This volume of POSIX.1‐2017 specifies that the new mapping replaces any existing mappings  (implying
       an  automatic munmap() on the address range), following existing practice in this regard.  The standard developers also considered whether there should be a way for new mappings to overlay exist‐
       ing mappings, but found no existing practice for this.

       It is not expected that all hardware implementations are able to support all combinations of permissions at all addresses.  Implementations are required to disallow write access to mappings with‐
       out  write permission and to disallow access to mappings without any access permission. Other than these restrictions, implementations may allow access types other than those requested by the ap‐
       plication. For example, if the application requests only PROT_WRITE, the implementation may also allow read access. A call to mmap() fails if the implementation cannot support  allowing  all  the
       access  requested by the application. For example, some implementations cannot support a request for both write access and execute access simultaneously. All implementations must support requests
       for no access, read access, write access, and both read and write access. Strictly conforming code must only rely on the required checks. These restrictions allow for portability  across  a  wide
       range of hardware.

       The  MAP_FIXED  address  treatment  is  likely to fail for non-page-aligned values and for certain architecture-dependent address ranges.  Conforming implementations cannot count on being able to
       choose address values for MAP_FIXED without utilizing non-portable, implementation-defined knowledge. Nonetheless, MAP_FIXED is provided as a standard interface conforming  to  existing  practice
       for utilizing such knowledge when it is available.

       Similarly,  in  order to allow implementations that do not support virtual addresses, support for directly specifying any mapping addresses via MAP_FIXED is not required and thus a conforming ap‐
       plication may not count on it.

       The MAP_PRIVATE function can be implemented efficiently when memory protection hardware is available. When such hardware is not available, implementations can implement such ``mappings'' by  sim‐
       ply making a real copy of the relevant data into process private memory, though this tends to behave similarly to read().

       The  function  has  been  defined to allow for many different models of using shared memory. However, all uses are not equally portable across all machine architectures. In particular, the mmap()
       function allows the system as well as the application to specify the address at which to map a specific region of a memory object. The most portable way to use the function is always to  let  the
       system choose the address, specifying NULL as the value for the argument addr and not to specify MAP_FIXED.

       If  it  is intended that a particular region of a memory object be mapped at the same address in a group of processes (on machines where this is even possible), then MAP_FIXED can be used to pass
       in the desired mapping address. The system can still be used to choose the desired address if the first such mapping is made without specifying MAP_FIXED, and then the resulting  mapping  address
       can be passed to subsequent processes for them to pass in via MAP_FIXED. The availability of a specific address range cannot be guaranteed, in general.

       The mmap() function can be used to map a region of memory that is larger than the current size of the object. Memory access within the mapping but beyond the current end of the underlying objects
       may result in SIGBUS signals being sent to the process. The reason for this is that the size of the object can be manipulated by other processes and can change at any moment.  The  implementation
       should tell the application that a memory reference is outside the object where this can be detected; otherwise, written data may be lost and read data may not reflect actual data in the object.

       Note that references beyond the end of the object do not extend the object as the new end cannot be determined precisely by most virtual memory hardware. Instead, the size can be directly manipu‐
       lated by ftruncate().

       Process memory locking does apply to shared memory regions, and the MCL_FUTURE argument to mlockall() can be relied upon to cause new shared memory regions to be automatically locked.

       Existing implementations of mmap() return the value -1 when unsuccessful. Since the casting of this value to type void * cannot be guaranteed by the ISO C standard to be distinct from a  success‐
       ful value, this volume of POSIX.1‐2017 defines the symbol MAP_FAILED, which a conforming implementation does not return as the result of a successful call.

FUTURE DIRECTIONS
       None.

SEE ALSO
       exec, fcntl(), fork(), lockf(), msync(), munmap(), mprotect(), posix_typed_mem_open(), shmat(), sysconf()

       The Base Definitions volume of POSIX.1‐2017, <sys_mman.h>

COPYRIGHT
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group
       Base Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any discrepancy between this  ver‐
       sion  and  the  original  IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be obtained online at http://www.open‐
       group.org/unix/online.html .

       Any typographical or formatting errors that appear in this page are most likely to have been introduced during the conversion of the source files to man page format. To report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                                                                2017                                                                                           MMAP(3P)
mmap(2)                                                                                     System Calls Manual                                                                                    mmap(2)

NAME
       mmap, munmap - map or unmap files or devices into memory

LIBRARY
       Standard C library (libc, -lc)

SYNOPSIS
       #include <sys/mman.h>

       void *mmap(void addr[.length], size_t length, int prot, int flags,
                  int fd, off_t offset);
       int munmap(void addr[.length], size_t length);

       See NOTES for information on feature test macro requirements.

DESCRIPTION
       mmap()  creates a new mapping in the virtual address space of the calling process.  The starting address for the new mapping is specified in addr.  The length argument specifies the length of the
       mapping (which must be greater than 0).

       If addr is NULL, then the kernel chooses the (page-aligned) address at which to create the mapping; this is the most portable method of creating a new mapping.  If addr is not NULL, then the ker‐
       nel takes it as a hint about where to place the mapping; on Linux, the kernel will pick a nearby page boundary (but always above or equal to the value specified by /proc/sys/vm/mmap_min_addr) and
       attempt to create the mapping there.  If another mapping already exists there, the kernel picks a new address that may or may not depend on the hint.  The address of the new mapping  is  returned
       as the result of the call.

       The  contents  of a file mapping (as opposed to an anonymous mapping; see MAP_ANONYMOUS below), are initialized using length bytes starting at offset offset in the file (or other object) referred
       to by the file descriptor fd.  offset must be a multiple of the page size as returned by sysconf(_SC_PAGE_SIZE).

       After the mmap() call has returned, the file descriptor, fd, can be closed immediately without invalidating the mapping.

       The prot argument describes the desired memory protection of the mapping (and must not conflict with the open mode of the file).  It is either PROT_NONE or the bitwise OR of one or  more  of  the
       following flags:

       PROT_EXEC  Pages may be executed.

       PROT_READ  Pages may be read.

       PROT_WRITE Pages may be written.

       PROT_NONE  Pages may not be accessed.

   The flags argument
       The flags argument determines whether updates to the mapping are visible to other processes mapping the same region, and whether updates are carried through to the underlying file.  This behavior
       is determined by including exactly one of the following values in flags:

       MAP_SHARED
              Share this mapping.  Updates to the mapping are visible to other processes mapping the same region, and (in the case of file-backed mappings) are carried through to  the  underlying  file.
              (To precisely control when updates are carried through to the underlying file requires the use of msync(2).)

       MAP_SHARED_VALIDATE (since Linux 4.15)
              This  flag provides the same behavior as MAP_SHARED except that MAP_SHARED mappings ignore unknown flags in flags.  By contrast, when creating a mapping using MAP_SHARED_VALIDATE, the ker‐
              nel verifies all passed flags are known and fails the mapping with the error EOPNOTSUPP for unknown flags.  This mapping type is also required to be able to use some mapping  flags  (e.g.,
              MAP_SYNC).

       MAP_PRIVATE
              Create a private copy-on-write mapping.  Updates to the mapping are not visible to other processes mapping the same file, and are not carried through to the underlying file.  It is unspec‐
              ified whether changes made to the file after the mmap() call are visible in the mapped region.

       Both MAP_SHARED and MAP_PRIVATE are described in POSIX.1-2001 and POSIX.1-2008.  MAP_SHARED_VALIDATE is a Linux extension.

       In addition, zero or more of the following values can be ORed in flags:

       MAP_32BIT (since Linux 2.4.20, 2.6)
              Put the mapping into the first 2 Gigabytes of the process address space.  This flag is supported only on x86-64, for 64-bit programs.  It was added to allow thread stacks to  be  allocated
              somewhere  in  the  first 2 GB of memory, so as to improve context-switch performance on some early 64-bit processors.  Modern x86-64 processors no longer have this performance problem, so
              use of this flag is not required on those systems.  The MAP_32BIT flag is ignored when MAP_FIXED is set.

       MAP_ANON
              Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.

       MAP_ANONYMOUS
              The mapping is not backed by any file; its contents are initialized to zero.  The fd argument is ignored; however, some implementations require fd to be -1 if MAP_ANONYMOUS  (or  MAP_ANON)
              is specified, and portable applications should ensure this.  The offset argument should be zero.  Support for MAP_ANONYMOUS in conjunction with MAP_SHARED was added in Linux 2.4.

       MAP_DENYWRITE
              This  flag  is ignored.  (Long ago—Linux 2.0 and earlier—it signaled that attempts to write to the underlying file should fail with ETXTBSY.  But this was a source of denial-of-service at‐
              tacks.)

       MAP_EXECUTABLE
              This flag is ignored.

       MAP_FILE
              Compatibility flag.  Ignored.

       MAP_FIXED
              Don't interpret addr as a hint: place the mapping at exactly that address.  addr must be suitably aligned: for most architectures a multiple of the page size is sufficient;  however,  some
              architectures  may  impose  additional  restrictions.  If the memory region specified by addr and length overlaps pages of any existing mapping(s), then the overlapped part of the existing
              mapping(s) will be discarded.  If the specified address cannot be used, mmap() will fail.

              Software that aspires to be portable should use the MAP_FIXED flag with care, keeping in mind that the exact layout of a process's memory mappings is allowed to  change  significantly  be‐
              tween Linux versions, C library versions, and operating system releases.  Carefully read the discussion of this flag in NOTES!

       MAP_FIXED_NOREPLACE (since Linux 4.17)
              This  flag  provides  behavior that is similar to MAP_FIXED with respect to the addr enforcement, but differs in that MAP_FIXED_NOREPLACE never clobbers a preexisting mapped range.  If the
              requested range would collide with an existing mapping, then this call fails with the error EEXIST.  This flag can therefore be used as a way to atomically (with respect to other  threads)
              attempt to map an address range: one thread will succeed; all others will report failure.

              Note  that  older  kernels which do not recognize the MAP_FIXED_NOREPLACE flag will typically (upon detecting a collision with a preexisting mapping) fall back to a “non-MAP_FIXED” type of
              behavior: they will return an address that is different from the requested address.  Therefore, backward-compatible software should check the returned address  against  the  requested  ad‐
              dress.

       MAP_GROWSDOWN
              This  flag  is  used  for stacks.  It indicates to the kernel virtual memory system that the mapping should extend downward in memory.  The return address is one page lower than the memory
              area that is actually created in the process's virtual address space.  Touching an address in the "guard" page below the mapping will cause the mapping to grow by a page.  This growth  can
              be repeated until the mapping grows to within a page of the high end of the next lower mapping, at which point touching the "guard" page will result in a SIGSEGV signal.

       MAP_HUGETLB (since Linux 2.6.32)
              Allocate the mapping using "huge" pages.  See the Linux kernel source file Documentation/admin-guide/mm/hugetlbpage.rst for further information, as well as NOTES, below.

       MAP_HUGE_2MB, MAP_HUGE_1GB (since Linux 3.8)
              Used in conjunction with MAP_HUGETLB to select alternative hugetlb page sizes (respectively, 2 MB and 1 GB) on systems that support multiple hugetlb page sizes.

              More  generally,  the  desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the offset MAP_HUGE_SHIFT.  (A value of zero in
              this bit field provides the default huge page size; the default huge page size can be discovered via the Hugepagesize field exposed by /proc/meminfo.)  Thus, the above  two  constants  are
              defined as:

                  #define MAP_HUGE_2MB    (21 << MAP_HUGE_SHIFT)
                  #define MAP_HUGE_1GB    (30 << MAP_HUGE_SHIFT)

              The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in /sys/kernel/mm/hugepages.

       MAP_LOCKED (since Linux 2.5.37)
              Mark  the  mapped region to be locked in the same way as mlock(2).  This implementation will try to populate (prefault) the whole range but the mmap() call doesn't fail with ENOMEM if this
              fails.  Therefore major faults might happen later on.  So the semantic is not as strong as mlock(2).  One should use mmap() plus mlock(2) when major faults are  not  acceptable  after  the
              initialization of the mapping.  The MAP_LOCKED flag is ignored in older kernels.

       MAP_NONBLOCK (since Linux 2.5.46)
              This  flag  is  meaningful only in conjunction with MAP_POPULATE.  Don't perform read-ahead: create page tables entries only for pages that are already present in RAM.  Since Linux 2.6.23,
              this flag causes MAP_POPULATE to do nothing.  One day, the combination of MAP_POPULATE and MAP_NONBLOCK may be reimplemented.

       MAP_NORESERVE
              Do not reserve swap space for this mapping.  When swap space is reserved, one has the guarantee that it is possible to modify the mapping.  When swap space is not reserved  one  might  get
              SIGSEGV  upon  a  write if no physical memory is available.  See also the discussion of the file /proc/sys/vm/overcommit_memory in proc(5).  Before Linux 2.6, this flag had effect only for
              private writable mappings.

       MAP_POPULATE (since Linux 2.5.46)
              Populate (prefault) page tables for a mapping.  For a file mapping, this causes read-ahead on the file.  This will help to reduce blocking on page faults later.  The  mmap()  call  doesn't
              fail  if  the mapping cannot be populated (for example, due to limitations on the number of mapped huge pages when using MAP_HUGETLB).  Support for MAP_POPULATE in conjunction with private
              mappings was added in Linux 2.6.23.

       MAP_STACK (since Linux 2.6.27)
              Allocate the mapping at an address suitable for a process or thread stack.

              This flag is currently a no-op on Linux.  However, by employing this flag, applications can ensure that they transparently obtain support if the flag is implemented in the  future.   Thus,
              it is used in the glibc threading implementation to allow for the fact that some architectures may (later) require special treatment for stack allocations.  A further reason to employ this
              flag is portability: MAP_STACK exists (and has an effect) on some other systems (e.g., some of the BSDs).

       MAP_SYNC (since Linux 4.15)
              This flag is available only with the MAP_SHARED_VALIDATE mapping type; mappings of type MAP_SHARED will silently ignore this flag.  This flag is supported only  for  files  supporting  DAX
              (direct mapping of persistent memory).  For other files, creating a mapping with this flag results in an EOPNOTSUPP error.

              Shared  file  mappings  with  this flag provide the guarantee that while some memory is mapped writable in the address space of the process, it will be visible in the same file at the same
              offset even after the system crashes or is rebooted.  In conjunction with the use of appropriate CPU instructions, this provides users of such mappings with a more efficient way of  making
              data modifications persistent.

       MAP_UNINITIALIZED (since Linux 2.6.33)
              Don't  clear  anonymous  pages.  This flag is intended to improve performance on embedded devices.  This flag is honored only if the kernel was configured with the CONFIG_MMAP_ALLOW_UNINI‐
              TIALIZED option.  Because of the security implications, that option is normally enabled only on embedded devices (i.e., devices where one has complete control of the contents of user  mem‐
              ory).

       Of the above flags, only MAP_FIXED is specified in POSIX.1-2001 and POSIX.1-2008.  However, most systems also support MAP_ANONYMOUS (or its synonym MAP_ANON).

   munmap()
       The  munmap()  system  call deletes the mappings for the specified address range, and causes further references to addresses within the range to generate invalid memory references.  The region is
       also automatically unmapped when the process is terminated.  On the other hand, closing the file descriptor does not unmap the region.

       The address addr must be a multiple of the page size (but length need not be).  All pages containing a part of the indicated range are unmapped, and subsequent references to these pages will gen‐
       erate SIGSEGV.  It is not an error if the indicated range does not contain any mapped pages.

RETURN VALUE
       On success, mmap() returns a pointer to the mapped area.  On error, the value MAP_FAILED (that is, (void *) -1) is returned, and errno is set to indicate the error.

       On success, munmap() returns 0.  On failure, it returns -1, and errno is set to indicate the error (probably to EINVAL).

ERRORS
       EACCES A  file descriptor refers to a non-regular file.  Or a file mapping was requested, but fd is not open for reading.  Or MAP_SHARED was requested and PROT_WRITE is set, but fd is not open in
              read/write (O_RDWR) mode.  Or PROT_WRITE is set, but the file is append-only.

       EAGAIN The file has been locked, or too much memory has been locked (see setrlimit(2)).

       EBADF  fd is not a valid file descriptor (and MAP_ANONYMOUS was not set).

       EEXIST MAP_FIXED_NOREPLACE was specified in flags, and the range covered by addr and length clashes with an existing mapping.

       EINVAL We don't like addr, length, or offset (e.g., they are too large, or not aligned on a page boundary).

       EINVAL (since Linux 2.6.12) length was 0.

       EINVAL flags contained none of MAP_PRIVATE, MAP_SHARED, or MAP_SHARED_VALIDATE.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENODEV The underlying filesystem of the specified file does not support memory mapping.

       ENOMEM No memory is available.

       ENOMEM The process's maximum number of mappings would have been exceeded.  This error can also occur for munmap(), when unmapping a region in the middle of an existing mapping, since this results
              in two smaller mappings on either side of the region being unmapped.

       ENOMEM (since Linux 4.7) The process's RLIMIT_DATA limit, described in getrlimit(2), would have been exceeded.

       ENOMEM We don't like addr, because it exceeds the virtual address space of the CPU.

       EOVERFLOW
              On  32-bit  architecture together with the large file extension (i.e., using 64-bit off_t): the number of pages used for length plus number of pages used for offset would overflow unsigned
              long (32 bits).

       EPERM  The prot argument asks for PROT_EXEC but the mapped area belongs to a file on a filesystem that was mounted no-exec.

       EPERM  The operation was prevented by a file seal; see fcntl(2).

       EPERM  The MAP_HUGETLB flag was specified, but the caller was not privileged (did not have the CAP_IPC_LOCK capability) and is not a member of the sysctl_hugetlb_shm_group group; see the descrip‐
              tion of /proc/sys/vm/sysctl_hugetlb_shm_group in

       ETXTBSY
              MAP_DENYWRITE was set but the object specified by fd is open for writing.

       Use of a mapped region can result in these signals:

       SIGSEGV
              Attempted write into a region mapped as read-only.

       SIGBUS Attempted  access to a page of the buffer that lies beyond the end of the mapped file.  For an explanation of the treatment of the bytes in the page that corresponds to the end of a mapped
              file that is not a multiple of the page size, see NOTES.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┬───────────────┬─────────┐
       │Interface                                                                                                                                                               │ Attribute     │ Value   │
       ├────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┼───────────────┼─────────┤
       │mmap(), munmap()                                                                                                                                                        │ Thread safety │ MT-Safe │
       └────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┴───────────────┴─────────┘

VERSIONS
       On some hardware architectures (e.g., i386), PROT_WRITE implies PROT_READ.  It is architecture dependent whether PROT_READ implies PROT_EXEC or not.  Portable programs should always set PROT_EXEC
       if they intend to execute code in the new mapping.

       The  portable way to create a mapping is to specify addr as 0 (NULL), and omit MAP_FIXED from flags.  In this case, the system chooses the address for the mapping; the address is chosen so as not
       to conflict with any existing mapping, and will not be 0.  If the MAP_FIXED flag is specified, and addr is 0 (NULL), then the mapped address will be 0 (NULL).

       Certain flags constants are defined only if suitable feature test macros are defined (possibly by default): _DEFAULT_SOURCE with glibc 2.19 or later; or _BSD_SOURCE or _SVID_SOURCE in glibc  2.19
       and  earlier.   (Employing  _GNU_SOURCE  also  suffices,  and  requiring  that macro specifically would have been more logical, since these flags are all Linux-specific.)  The relevant flags are:
       MAP_32BIT, MAP_ANONYMOUS (and the synonym MAP_ANON), MAP_DENYWRITE, MAP_EXECUTABLE, MAP_FILE, MAP_GROWSDOWN, MAP_HUGETLB, MAP_LOCKED, MAP_NONBLOCK, MAP_NORESERVE, MAP_POPULATE, and MAP_STACK.

   C library/kernel differences
       This page describes the interface provided by the glibc mmap() wrapper function.  Originally, this function invoked a system call of the same name.  Since Linux 2.4, that system call has been su‐
       perseded by mmap2(2), and nowadays the glibc mmap() wrapper function invokes mmap2(2) with a suitably adjusted value for offset.

STANDARDS
       POSIX.1-2008.

HISTORY
       POSIX.1-2001, SVr4, 4.4BSD.

       On POSIX systems on which mmap(), msync(2), and munmap() are available, _POSIX_MAPPED_FILES is defined in <unistd.h> to a value greater than 0.  (See also sysconf(3).)

NOTES
       Memory mapped by mmap() is preserved across fork(2), with the same attributes.

       A  file is mapped in multiples of the page size.  For a file that is not a multiple of the page size, the remaining bytes in the partial page at the end of the mapping are zeroed when mapped, and
       modifications to that region are not written out to the file.  The effect of changing the size of the underlying file of a mapping on the pages that correspond to added or removed regions of  the
       file is unspecified.

       An application can determine which pages of a mapping are currently resident in the buffer/page cache using mincore(2).

   Using MAP_FIXED safely
       The  only  safe  use  for  MAP_FIXED is where the address range specified by addr and length was previously reserved using another mapping; otherwise, the use of MAP_FIXED is hazardous because it
       forcibly removes preexisting mappings, making it easy for a multithreaded process to corrupt its own address space.

       For example, suppose that thread A looks through /proc/pid/maps in order to locate an unused address range that it can map using MAP_FIXED, while thread B simultaneously acquires part or  all  of
       that  same address range.  When thread A subsequently employs mmap(MAP_FIXED), it will effectively clobber the mapping that thread B created.  In this scenario, thread B need not create a mapping
       directly; simply making a library call that, internally, uses dlopen(3) to load some other shared library, will suffice.  The dlopen(3) call will map the library into the process's address space.
       Furthermore,  almost  any  library  call  may be implemented in a way that adds memory mappings to the address space, either with this technique, or by simply allocating memory.  Examples include
       brk(2), malloc(3), pthread_create(3), and the PAM libraries ⟨http://www.linux-pam.org⟩.

       Since Linux 4.17, a multithreaded program can use the MAP_FIXED_NOREPLACE flag to avoid the hazard described above when attempting to create a mapping at a fixed address that  has  not  been  re‐
       served by a preexisting mapping.

   Timestamps changes for file-backed mappings
       For  file-backed  mappings,  the st_atime field for the mapped file may be updated at any time between the mmap() and the corresponding unmapping; the first reference to a mapped page will update
       the field if it has not been already.

       The st_ctime and st_mtime field for a file mapped with PROT_WRITE and MAP_SHARED will be updated after a write to the mapped region, and before a subsequent msync(2) with the MS_SYNC or  MS_ASYNC
       flag, if one occurs.

   Huge page (Huge TLB) mappings
       For mappings that employ huge pages, the requirements for the arguments of mmap() and munmap() differ somewhat from the requirements for mappings that use the native system page size.

       For mmap(), offset must be a multiple of the underlying huge page size.  The system automatically aligns length to be a multiple of the underlying huge page size.

       For munmap(), addr, and length must both be a multiple of the underlying huge page size.

BUGS
       On Linux, there are no guarantees like those suggested above under MAP_NORESERVE.  By default, any process can be killed at any moment when the system runs out of memory.

       Before Linux 2.6.7, the MAP_POPULATE flag has effect only if prot is specified as PROT_NONE.

       SUSv3  specifies  that  mmap()  should  fail  if length is 0.  However, before Linux 2.6.12, mmap() succeeded in this case: no mapping was created and the call returned addr.  Since Linux 2.6.12,
       mmap() fails with the error EINVAL for this case.

       POSIX specifies that the system shall always zero fill any partial page at the end of the object and that system will never write any modification of the object beyond its end.   On  Linux,  when
       you  write data to such partial page after the end of the object, the data stays in the page cache even after the file is closed and unmapped and even though the data is never written to the file
       itself, subsequent mappings may see the modified content.  In some cases, this could be fixed by calling msync(2) before the unmap takes place; however, this doesn't work on tmpfs(5)  (for  exam‐
       ple, when using the POSIX shared memory interface documented in shm_overview(7)).

EXAMPLES
       The  following  program prints part of the file specified in its first command-line argument to standard output.  The range of bytes to be printed is specified via offset and length values in the
       second and third command-line arguments.  The program creates a memory mapping of the required pages of the file and then uses write(2) to output the desired bytes.

   Program source
       #include <fcntl.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/mman.h>
       #include <sys/stat.h>
       #include <unistd.h>

       #define handle_error(msg) \
           do { perror(msg); exit(EXIT_FAILURE); } while (0)

       int
       main(int argc, char *argv[])
       {
           int          fd;
           char         *addr;
           off_t        offset, pa_offset;
           size_t       length;
           ssize_t      s;
           struct stat  sb;

           if (argc < 3 || argc > 4) {
               fprintf(stderr, "%s file offset [length]\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           fd = open(argv[1], O_RDONLY);
           if (fd == -1)
               handle_error("open");

           if (fstat(fd, &sb) == -1)           /* To obtain file size */
               handle_error("fstat");

           offset = atoi(argv[2]);
           pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1);
               /* offset for mmap() must be page aligned */

           if (offset >= sb.st_size) {
               fprintf(stderr, "offset is past end of file\n");
               exit(EXIT_FAILURE);
           }

           if (argc == 4) {
               length = atoi(argv[3]);
               if (offset + length > sb.st_size)
                   length = sb.st_size - offset;
                       /* Can't display bytes past end of file */

           } else {    /* No length arg ==> display to end of file */
               length = sb.st_size - offset;
           }

           addr = mmap(NULL, length + offset - pa_offset, PROT_READ,
                       MAP_PRIVATE, fd, pa_offset);
           if (addr == MAP_FAILED)
               handle_error("mmap");

           s = write(STDOUT_FILENO, addr + offset - pa_offset, length);
           if (s != length) {
               if (s == -1)
                   handle_error("write");

               fprintf(stderr, "partial write");
               exit(EXIT_FAILURE);
           }

           munmap(addr, length + offset - pa_offset);
           close(fd);

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       ftruncate(2), getpagesize(2), memfd_create(2), mincore(2), mlock(2),  mmap2(2),  mprotect(2),  mremap(2),  msync(2),  remap_file_pages(2),  setrlimit(2),  shmat(2),  userfaultfd(2),  shm_open(3),
       shm_overview(7)

       The descriptions of the following files in proc(5): /proc/pid/maps, /proc/pid/map_files, and /proc/pid/smaps.

       B.O. Gallmeister, POSIX.4, O'Reilly, pp. 128–129 and 389–391.

Linux man-pages 6.04                                                                            2023-04-03                                                                                         mmap(2)
