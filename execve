execve(2)                                                                                   System Calls Manual                                                                                  execve(2)

NAME
       execve - execute program

LIBRARY
       Standard C library (libc, -lc)

SYNOPSIS
       #include <unistd.h>

       int execve(const char *pathname, char *const _Nullable argv[],
                  char *const _Nullable envp[]);

DESCRIPTION
       execve() executes the program referred to by pathname.  This causes the program that is currently being run by the calling process to be replaced with a new program, with newly initialized stack,
       heap, and (initialized and uninitialized) data segments.

       pathname must be either a binary executable, or a script starting with a line of the form:

           #!interpreter [optional-arg]

       For details of the latter case, see "Interpreter scripts" below.

       argv is an array of pointers to strings passed to the new program as its command-line arguments.  By convention, the first of these strings (i.e., argv[0]) should contain the filename  associated
       with the file being executed.  The argv array must be terminated by a NULL pointer.  (Thus, in the new program, argv[argc] will be NULL.)

       envp is an array of pointers to strings, conventionally of the form key=value, which are passed as the environment of the new program.  The envp array must be terminated by a NULL pointer.

       This  manual page describes the Linux system call in detail; for an overview of the nomenclature and the many, often preferable, standardised variants of this function provided by libc, including
       ones that search the PATH environment variable, see exec(3).

       The argument vector and environment can be accessed by the new program's main function, when it is defined as:

           int main(int argc, char *argv[], char *envp[])

       Note, however, that the use of a third argument to the main function is not specified in POSIX.1; according to POSIX.1, the environment should be accessed via the external variable environ(7).

       execve() does not return on success, and the text, initialized data, uninitialized data (bss), and stack of the calling process are overwritten according to the contents of the newly loaded  pro‐
       gram.

       If the current program is being ptraced, a SIGTRAP signal is sent to it after a successful execve().

       If  the  set-user-ID  bit is set on the program file referred to by pathname, then the effective user ID of the calling process is changed to that of the owner of the program file.  Similarly, if
       the set-group-ID bit is set on the program file, then the effective group ID of the calling process is set to the group of the program file.

       The aforementioned transformations of the effective IDs are not performed (i.e., the set-user-ID and set-group-ID bits are ignored) if any of the following is true:

       •  the no_new_privs attribute is set for the calling thread (see prctl(2));

       •  the underlying filesystem is mounted nosuid (the MS_NOSUID flag for mount(2)); or

       •  the calling process is being ptraced.

       The capabilities of the program file (see capabilities(7)) are also ignored if any of the above are true.

       The effective user ID of the process is copied to the saved set-user-ID; similarly, the effective group ID is copied to the saved set-group-ID.  This copying takes place after  any  effective  ID
       changes that occur because of the set-user-ID and set-group-ID mode bits.

       The process's real UID and real GID, as well as its supplementary group IDs, are unchanged by a call to execve().

       If  the  executable  is an a.out dynamically linked binary executable containing shared-library stubs, the Linux dynamic linker ld.so(8) is called at the start of execution to bring needed shared
       objects into memory and link the executable with them.

       If the executable is a dynamically linked ELF executable, the interpreter  named  in  the  PT_INTERP  segment  is  used  to  load  the  needed  shared  objects.   This  interpreter  is  typically
       /lib/ld-linux.so.2 for binaries linked with glibc (see ld-linux.so(8)).

   Effect on process attributes
       All process attributes are preserved during an execve(), except the following:

       •  The dispositions of any signals that are being caught are reset to the default (signal(7)).

       •  Any alternate signal stack is not preserved (sigaltstack(2)).

       •  Memory mappings are not preserved (mmap(2)).

       •  Attached System V shared memory segments are detached (shmat(2)).

       •  POSIX shared memory regions are unmapped (shm_open(3)).

       •  Open POSIX message queue descriptors are closed (mq_overview(7)).

       •  Any open POSIX named semaphores are closed (sem_overview(7)).

       •  POSIX timers are not preserved (timer_create(2)).

       •  Any open directory streams are closed (opendir(3)).

       •  Memory locks are not preserved (mlock(2), mlockall(2)).

       •  Exit handlers are not preserved (atexit(3), on_exit(3)).

       •  The floating-point environment is reset to the default (see fenv(3)).

       The process attributes in the preceding list are all specified in POSIX.1.  The following Linux-specific process attributes are also not preserved during an execve():

       •  The  process's  "dumpable"  attribute  is set to the value 1, unless a set-user-ID program, a set-group-ID program, or a program with capabilities is being executed, in which case the dumpable
          flag may instead be reset to the value in /proc/sys/fs/suid_dumpable, in the circumstances described under PR_SET_DUMPABLE in prctl(2).  Note that changes to the "dumpable" attribute may cause
          ownership of files in the process's /proc/pid directory to change to root:root, as described in proc(5).

       •  The prctl(2) PR_SET_KEEPCAPS flag is cleared.

       •  (Since Linux 2.4.36 / 2.6.23) If a set-user-ID or set-group-ID program is being executed, then the parent death signal set by prctl(2) PR_SET_PDEATHSIG flag is cleared.

       •  The process name, as set by prctl(2) PR_SET_NAME (and displayed by ps -o comm), is reset to the name of the new executable file.

       •  The SECBIT_KEEP_CAPS securebits flag is cleared.  See capabilities(7).

       •  The termination signal is reset to SIGCHLD (see clone(2)).

       •  The file descriptor table is unshared, undoing the effect of the CLONE_FILES flag of clone(2).

       Note the following further points:

       •  All threads other than the calling thread are destroyed during an execve().  Mutexes, condition variables, and other pthreads objects are not preserved.

       •  The equivalent of setlocale(LC_ALL, "C") is executed at program start-up.

       •  POSIX.1  specifies that the dispositions of any signals that are ignored or set to the default are left unchanged.  POSIX.1 specifies one exception: if SIGCHLD is being ignored, then an imple‐
          mentation may leave the disposition unchanged or reset it to the default; Linux does the former.

       •  Any outstanding asynchronous I/O operations are canceled (aio_read(3), aio_write(3)).

       •  For the handling of capabilities during execve(), see capabilities(7).

       •  By default, file descriptors remain open across an execve().  File descriptors that are marked close-on-exec are closed; see the description of FD_CLOEXEC in fcntl(2).  (If a  file  descriptor
          is closed, this will cause the release of all record locks obtained on the underlying file by this process.  See fcntl(2) for details.)  POSIX.1 says that if file descriptors 0, 1, and 2 would
          otherwise be closed after a successful execve(), and the process would gain privilege because the set-user-ID or set-group-ID mode bit was set on the executed file, then the system may open an
          unspecified  file  for  each of these file descriptors.  As a general principle, no portable program, whether privileged or not, can assume that these three file descriptors will remain closed
          across an execve().

   Interpreter scripts
       An interpreter script is a text file that has execute permission enabled and whose first line is of the form:

           #!interpreter [optional-arg]

       The interpreter must be a valid pathname for an executable file.

       If the pathname argument of execve() specifies an interpreter script, then interpreter will be invoked with the following arguments:

           interpreter [optional-arg] pathname arg...

       where pathname is the pathname of the file specified as the first argument of execve(), and arg...  is the series of words pointed to by the argv argument of execve(), starting at argv[1].   Note
       that there is no way to get the argv[0] that was passed to the execve() call.

       For portable use, optional-arg should either be absent, or be specified as a single word (i.e., it should not contain white space); see NOTES below.

       Since  Linux 2.6.28, the kernel permits the interpreter of a script to itself be a script.  This permission is recursive, up to a limit of four recursions, so that the interpreter may be a script
       which is interpreted by a script, and so on.

   Limits on size of arguments and environment
       Most UNIX implementations impose some limit on the total size of the command-line argument (argv) and environment (envp) strings that may be passed to a new program.  POSIX.1 allows an  implemen‐
       tation to advertise this limit using the ARG_MAX constant (either defined in <limits.h> or available at run time using the call sysconf(_SC_ARG_MAX)).

       Before Linux 2.6.23, the memory used to store the environment and argument strings was limited to 32 pages (defined by the kernel constant MAX_ARG_PAGES).  On architectures with a 4-kB page size,
       this yields a maximum size of 128 kB.

       On Linux 2.6.23 and later, most architectures support a size limit derived from the soft RLIMIT_STACK resource limit (see getrlimit(2)) that is in force at the time of the execve() call.  (Archi‐
       tectures  with no memory management unit are excepted: they maintain the limit that was in effect before Linux 2.6.23.)  This change allows programs to have a much larger argument and/or environ‐
       ment list.  For these architectures, the total size is limited to 1/4 of the allowed stack size.  (Imposing the 1/4-limit ensures that the new program always has some stack space.)  Additionally,
       the  total  size  is  limited  to  3/4 of the value of the kernel constant _STK_LIM (8 MiB).  Since Linux 2.6.25, the kernel also places a floor of 32 pages on this size limit, so that, even when
       RLIMIT_STACK is set very low, applications are guaranteed to have at least as much argument and environment space as was provided by Linux 2.6.22 and earlier.  (This guarantee was not provided in
       Linux 2.6.23 and 2.6.24.)  Additionally, the limit per string is 32 pages (the kernel constant MAX_ARG_STRLEN), and the maximum number of strings is 0x7FFFFFFF.

RETURN VALUE
       On success, execve() does not return, on error -1 is returned, and errno is set to indicate the error.

ERRORS
       E2BIG  The total number of bytes in the environment (envp) and argument list (argv) is too large.

       EACCES Search permission is denied on a component of the path prefix of pathname or the name of a script interpreter.  (See also path_resolution(7).)

       EACCES The file or a script interpreter is not a regular file.

       EACCES Execute permission is denied for the file or a script or ELF interpreter.

       EACCES The filesystem is mounted noexec.

       EAGAIN (since Linux 3.1)
              Having  changed its real UID using one of the set*uid() calls, the caller was—and is now still—above its RLIMIT_NPROC resource limit (see setrlimit(2)).  For a more detailed explanation of
              this error, see NOTES.

       EFAULT pathname or one of the pointers in the vectors argv or envp points outside your accessible address space.

       EINVAL An ELF executable had more than one PT_INTERP segment (i.e., tried to name more than one interpreter).

       EIO    An I/O error occurred.

       EISDIR An ELF interpreter was a directory.

       ELIBBAD
              An ELF interpreter was not in a recognized format.

       ELOOP  Too many symbolic links were encountered in resolving pathname or the name of a script or ELF interpreter.

       ELOOP  The maximum recursion limit was reached during recursive script interpretation (see "Interpreter scripts", above).  Before Linux 3.8, the error produced for this case was ENOEXEC.

       EMFILE The per-process limit on the number of open file descriptors has been reached.

       ENAMETOOLONG
              pathname is too long.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENOENT The file pathname or a script or ELF interpreter does not exist.

       ENOEXEC
              An executable is not in a recognized format, is for the wrong architecture, or has some other format error that means it cannot be executed.

       ENOMEM Insufficient kernel memory was available.

       ENOTDIR
              A component of the path prefix of pathname or a script or ELF interpreter is not a directory.

       EPERM  The filesystem is mounted nosuid, the user is not the superuser, and the file has the set-user-ID or set-group-ID bit set.

       EPERM  The process is being traced, the user is not the superuser and the file has the set-user-ID or set-group-ID bit set.

       EPERM  A "capability-dumb" applications would not obtain the full set of permitted capabilities granted by the executable file.  See capabilities(7).

       ETXTBSY
              The specified executable was open for writing by one or more processes.

VERSIONS
       POSIX does not document the #! behavior, but it exists (with some variations) on other UNIX systems.

       On Linux, argv and envp can be specified as NULL.  In both cases, this has the same effect as specifying the argument as a pointer to a list containing a single null pointer.  Do not take  advan‐
       tage  of this nonstandard and nonportable misfeature!  On many other UNIX systems, specifying argv as NULL will result in an error (EFAULT).  Some other UNIX systems treat the envp==NULL case the
       same as Linux.

       POSIX.1 says that values returned by sysconf(3) should be invariant over the lifetime of a process.  However, since Linux 2.6.23, if the RLIMIT_STACK resource limit changes, then  the  value  re‐
       ported by _SC_ARG_MAX will also change, to reflect the fact that the limit on space for holding command-line arguments and environment variables has changed.

   Interpreter scripts
       The kernel imposes a maximum length on the text that follows the "#!" characters at the start of a script; characters beyond the limit are ignored.  Before Linux 5.1, the limit is 127 characters.
       Since Linux 5.1, the limit is 255 characters.

       The semantics of the optional-arg argument of an interpreter script vary across implementations.  On Linux, the entire string following the interpreter name is passed as a single argument to  the
       interpreter, and this string can include white space.  However, behavior differs on some other systems.  Some systems use the first white space to terminate optional-arg.  On some systems, an in‐
       terpreter script can have multiple arguments, and white spaces in optional-arg are used to delimit the arguments.

       Linux (like most other modern UNIX systems) ignores the set-user-ID and set-group-ID bits on scripts.

STANDARDS
       POSIX.1-2008.

HISTORY
       POSIX.1-2001, SVr4, 4.3BSD.

       With UNIX V6, the argument list of an exec() call was ended by 0, while the argument list of main was ended by -1.  Thus, this argument list was not directly usable  in  a  further  exec()  call.
       Since UNIX V7, both are NULL.

NOTES
       One  sometimes  sees  execve()  (and  the  related  functions  described in exec(3)) described as "executing a new process" (or similar).  This is a highly misleading description: there is no new
       process; many attributes of the calling process remain unchanged (in particular, its PID).  All that execve() does is arrange for an existing process (the calling process) to execute a  new  pro‐
       gram.

       Set-user-ID and set-group-ID processes can not be ptrace(2)d.

       The  result  of  mounting a filesystem nosuid varies across Linux kernel versions: some will refuse execution of set-user-ID and set-group-ID executables when this would give the user powers they
       did not have already (and return EPERM), some will just ignore the set-user-ID and set-group-ID bits and exec() successfully.

       In most cases where execve() fails, control returns to the original executable image, and the caller of execve() can then handle the error.  However, in (rare) cases (typically caused by resource
       exhaustion), failure may occur past the point of no return: the original executable image has been torn down, but the new image could not be completely built.  In such cases, the kernel kills the
       process with a SIGSEGV (SIGKILL until Linux 3.17) signal.

   execve() and EAGAIN
       A more detailed explanation of the EAGAIN error that can occur (since Linux 3.1) when calling execve() is as follows.

       The EAGAIN error can occur when a preceding call to setuid(2), setreuid(2), or setresuid(2) caused the real user ID of the process to change, and that change caused  the  process  to  exceed  its
       RLIMIT_NPROC resource limit (i.e., the number of processes belonging to the new real UID exceeds the resource limit).  From Linux 2.6.0 to Linux 3.0, this caused the set*uid() call to fail.  (Be‐
       fore Linux 2.6, the resource limit was not imposed on processes that changed their user IDs.)

       Since Linux 3.1, the scenario just described no longer causes the set*uid() call to fail, because it too often led to security holes where buggy applications didn't check the  return  status  and
       assumed  that—if  the  caller  had  root  privileges—the call would always succeed.  Instead, the set*uid() calls now successfully change the real UID, but the kernel sets an internal flag, named
       PF_NPROC_EXCEEDED, to note that the RLIMIT_NPROC resource limit has been exceeded.  If the PF_NPROC_EXCEEDED flag is set and the resource limit is still exceeded at the time of a  subsequent  ex‐
       ecve()  call,  that call fails with the error EAGAIN.  This kernel logic ensures that the RLIMIT_NPROC resource limit is still enforced for the common privileged daemon workflow—namely, fork(2) +
       set*uid() + execve().

       If the resource limit was not still exceeded at the time of the execve() call (because other processes belonging to this real UID terminated between the set*uid() call  and  the  execve()  call),
       then the execve() call succeeds and the kernel clears the PF_NPROC_EXCEEDED process flag.  The flag is also cleared if a subsequent call to fork(2) by this process succeeds.

EXAMPLES
       The following program is designed to be execed by the second program below.  It just echoes its command-line arguments, one per line.

           /* myecho.c */

           #include <stdio.h>
           #include <stdlib.h>

           int
           main(int argc, char *argv[])
           {
               for (size_t j = 0; j < argc; j++)
                   printf("argv[%zu]: %s\n", j, argv[j]);

               exit(EXIT_SUCCESS);
           }

       This program can be used to exec the program named in its command-line argument:

           /* execve.c */

           #include <stdio.h>
           #include <stdlib.h>
           #include <unistd.h>

           int
           main(int argc, char *argv[])
           {
               static char *newargv[] = { NULL, "hello", "world", NULL };
               static char *newenviron[] = { NULL };

               if (argc != 2) {
                   fprintf(stderr, "Usage: %s <file-to-exec>\n", argv[0]);
                   exit(EXIT_FAILURE);
               }

               newargv[0] = argv[1];

               execve(argv[1], newargv, newenviron);
               perror("execve");   /* execve() returns only on error */
               exit(EXIT_FAILURE);
           }

       We can use the second program to exec the first as follows:

           $ cc myecho.c -o myecho
           $ cc execve.c -o execve
           $ ./execve ./myecho
           argv[0]: ./myecho
           argv[1]: hello
           argv[2]: world

       We can also use these programs to demonstrate the use of a script interpreter.  To do this we create a script whose "interpreter" is our myecho program:

           $ cat > script
           #!./myecho script-arg
           ^D
           $ chmod +x script

       We can then use our program to exec the script:

           $ ./execve ./script
           argv[0]: ./myecho
           argv[1]: script-arg
           argv[2]: ./script
           argv[3]: hello
           argv[4]: world

SEE ALSO
       chmod(2), execveat(2), fork(2), get_robust_list(2), ptrace(2), exec(3), fexecve(3), getauxval(3), getopt(3), system(3), capabilities(7), credentials(7), environ(7), path_resolution(7), ld.so(8)

Linux man-pages 6.04                                                                            2023-03-30                                                                                       execve(2)
EXEC(3P)                                                                                 POSIX Programmer's Manual                                                                                EXEC(3P)

PROLOG
       This  manual  page is part of the POSIX Programmer's Manual.  The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or
       the interface may not be implemented on Linux.

NAME
       environ, execl, execle, execlp, execv, execve, execvp, fexecve — execute a file

SYNOPSIS
       #include <unistd.h>

       extern char **environ;
       int execl(const char *path, const char *arg0, ... /*, (char *)0 */);
       int execle(const char *path, const char *arg0, ... /*,
           (char *)0, char *const envp[]*/);
       int execlp(const char *file, const char *arg0, ... /*, (char *)0 */);
       int execv(const char *path, char *const argv[]);
       int execve(const char *path, char *const argv[], char *const envp[]);
       int execvp(const char *file, char *const argv[]);
       int fexecve(int fd, char *const argv[], char *const envp[]);

DESCRIPTION
       The exec family of functions shall replace the current process image with a new process image. The new image shall be constructed from a regular, executable file  called  the  new  process  image
       file.  There shall be no return from a successful exec, because the calling process image is overlaid by the new process image.

       The fexecve() function shall be equivalent to the execve() function except that the file to be executed is determined by the file descriptor fd instead of a pathname. The file offset of fd is ig‐
       nored.

       When a C-language program is executed as a result of a call to one of the exec family of functions, it shall be entered as a C-language function call as follows:

           int main (int argc, char *argv[]);

       where argc is the argument count and argv is an array of character pointers to the arguments themselves.  In addition, the following variable, which must be declared by the user if it  is  to  be
       used directly:

           extern char **environ;

       is  initialized as a pointer to an array of character pointers to the environment strings. The argv and environ arrays are each terminated by a null pointer. The null pointer terminating the argv
       array is not counted in argc.

       Applications can change the entire environment in a single operation by assigning the environ variable to point to an array of character pointers to the new environment strings. After assigning a
       new value to environ, applications should not rely on the new environment strings remaining part of the environment, as a call to getenv(), putenv(), setenv(), unsetenv(), or any function that is
       dependent on an environment variable may, on noticing that environ has changed, copy the environment strings to a new array and assign environ to point to it.

       Any application that directly modifies the pointers to which the environ variable points has undefined behavior.

       Conforming multi-threaded applications shall not use the environ variable to access or modify any environment variable while any other thread is concurrently modifying any environment variable. A
       call to any function dependent on any environment variable shall be considered a use of the environ variable to access that environment variable.

       The arguments specified by a program with one of the exec functions shall be passed on to the new process image in the corresponding main() arguments.

       The argument path points to a pathname that identifies the new process image file.

       The  argument  file  is used to construct a pathname that identifies the new process image file. If the file argument contains a <slash> character, the file argument shall be used as the pathname
       for this file. Otherwise, the path prefix for this file is obtained by a search of the directories passed as the environment variable PATH (see the Base Definitions volume of POSIX.1‐2017,  Chap‐
       ter 8, Environment Variables).  If this environment variable is not present, the results of the search are implementation-defined.

       There  are two distinct ways in which the contents of the process image file may cause the execution to fail, distinguished by the setting of errno to either [ENOEXEC] or [EINVAL] (see the ERRORS
       section). In the cases where the other members of the exec family of functions would fail and set errno to [ENOEXEC], the execlp() and execvp() functions shall execute a command  interpreter  and
       the environment of the executed command shall be as if the process invoked the sh utility using execl() as follows:

           execl(<shell path>, arg0, file, arg1, ..., (char *)0);

       where  <shell path>  is  an  unspecified  pathname for the sh utility, file is the process image file, and for execvp(), where arg0, arg1, and so on correspond to the values passed to execvp() in
       argv[0], argv[1], and so on.

       The arguments represented by arg0,...  are pointers to null-terminated character strings. These strings shall constitute the argument list available to the new process image. The list  is  termi‐
       nated by a null pointer. The argument arg0 should point to a filename string that is associated with the process being started by one of the exec functions.

       The  argument  argv is an array of character pointers to null-terminated strings. The application shall ensure that the last member of this array is a null pointer. These strings shall constitute
       the argument list available to the new process image. The value in argv[0] should point to a filename string that is associated with the process being started by one of the exec functions.

       The argument envp is an array of character pointers to null-terminated strings. These strings shall constitute the environment for the new process image.  The envp array is terminated by  a  null
       pointer.

       For those forms not containing an envp pointer (execl(), execv(), execlp(), and execvp()), the environment for the new process image shall be taken from the external variable environ in the call‐
       ing process.

       The number of bytes available for the new process' combined argument and environment lists is {ARG_MAX}.  It is implementation-defined whether null terminators,  pointers,  and/or  any  alignment
       bytes are included in this total.

       File descriptors open in the calling process image shall remain open in the new process image, except for those whose close-on-exec flag FD_CLOEXEC is set.  For those file descriptors that remain
       open, all attributes of the open file description remain unchanged. For any file descriptor that is closed for this reason, file locks are removed as  a  result  of  the  close  as  described  in
       close().  Locks that are not removed by closing of file descriptors remain unchanged.

       If file descriptor 0, 1, or 2 would otherwise be closed after a successful call to one of the exec family of functions, implementations may open an unspecified file for the file descriptor in the
       new process image. If a standard utility or a conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing,  the  environment
       in which the utility or application is executed shall be deemed non-conforming, and consequently the utility or application might not behave as described in this standard.

       Directory streams open in the calling process image shall be closed in the new process image.

       The state of the floating-point environment in the initial thread of the new process image shall be set to the default.

       The state of conversion descriptors and message catalog descriptors in the new process image is undefined.

       For the new process image, the equivalent of:

           setlocale(LC_ALL, "C")

       shall be executed at start-up.

       Signals  set  to the default action (SIG_DFL) in the calling process image shall be set to the default action in the new process image.  Except for SIGCHLD, signals set to be ignored (SIG_IGN) by
       the calling process image shall be set to be ignored by the new process image. Signals set to be caught by the calling process image shall be set to the default action in the  new  process  image
       (see <signal.h>).

       If the SIGCHLD signal is set to be ignored by the calling process image, it is unspecified whether the SIGCHLD signal is set to be ignored or to the default action in the new process image.

       After a successful call to any of the exec functions, alternate signal stacks are not preserved and the SA_ONSTACK flag shall be cleared for all signals.

       After a successful call to any of the exec functions, any functions previously registered by the atexit() or pthread_atfork() functions are no longer registered.

       If  the  ST_NOSUID bit is set for the file system containing the new process image file, then the effective user ID, effective group ID, saved set-user-ID, and saved set-group-ID are unchanged in
       the new process image. Otherwise, if the set-user-ID mode bit of the new process image file is set, the effective user ID of the new process image shall be set to the user ID of the  new  process
       image  file.  Similarly,  if  the set-group-ID mode bit of the new process image file is set, the effective group ID of the new process image shall be set to the group ID of the new process image
       file. The real user ID, real group ID, and supplementary group IDs of the new process image shall remain the same as those of the calling process image. The effective user ID and effective  group
       ID of the new process image shall be saved (as the saved set-user-ID and the saved set-group-ID) for use by setuid().

       Any shared memory segments attached to the calling process image shall not be attached to the new process image.

       Any named semaphores open in the calling process shall be closed as if by appropriate calls to sem_close().

       Any blocks of typed memory that were mapped in the calling process are unmapped, as if munmap() was implicitly called to unmap them.

       Memory  locks  established by the calling process via calls to mlockall() or mlock() shall be removed. If locked pages in the address space of the calling process are also mapped into the address
       spaces of other processes and are locked by those processes, the locks established by the other processes shall be unaffected by the call by this process to the exec function. If the  exec  func‐
       tion fails, the effect on memory locks is unspecified.

       Memory mappings created in the process are unmapped before the address space is rebuilt for the new process image.

       When  the  calling process image does not use the SCHED_FIFO, SCHED_RR, or SCHED_SPORADIC scheduling policies, the scheduling policy and parameters of the new process image and the initial thread
       in that new process image are implementation-defined.

       When the calling process image uses the SCHED_FIFO, SCHED_RR, or SCHED_SPORADIC scheduling policies, the process policy and scheduling parameter settings shall not be changed by a call to an exec
       function.  The initial thread in the new process image shall inherit the process scheduling policy and parameters. It shall have the default system contention scope, but shall inherit its alloca‐
       tion domain from the calling process image.

       Per-process timers created by the calling process shall be deleted before replacing the current process image with the new process image.

       All open message queue descriptors in the calling process shall be closed, as described in mq_close().

       Any outstanding asynchronous I/O operations may be canceled. Those asynchronous I/O operations that are not canceled shall complete as if the exec function had not yet occurred, but  any  associ‐
       ated signal notifications shall be suppressed. It is unspecified whether the exec function itself blocks awaiting such I/O completion. In no event, however, shall the new process image created by
       the exec function be affected by the presence of outstanding asynchronous I/O operations at the time the exec function is called. Whether any I/O is canceled, and which I/O may be  canceled  upon
       exec, is implementation-defined.

       The new process image shall inherit the CPU-time clock of the calling process image. This inheritance means that the process CPU-time clock of the process being exec-ed shall not be reinitialized
       or altered as a result of the exec function other than to reflect the time spent by the process executing the exec function itself.

       The initial value of the CPU-time clock of the initial thread of the new process image shall be set to zero.

       If the calling process is being traced, the new process image shall continue to be traced into the same trace stream as the original process image, but the new process image shall not inherit the
       mapping  of  trace  event names to trace event type identifiers that was defined by calls to the posix_trace_eventid_open() or the posix_trace_trid_eventid_open() functions in the calling process
       image.

       If the calling process is a trace controller process, any trace streams that were created by the calling process shall be shut down as described in the posix_trace_shutdown() function.

       The thread ID of the initial thread in the new process image is unspecified.

       The size and location of the stack on which the initial thread in the new process image runs is unspecified.

       The initial thread in the new process image shall have its cancellation type set to PTHREAD_CANCEL_DEFERRED and its cancellation state set to PTHREAD_CANCEL_ENABLED.

       The initial thread in the new process image shall have all thread-specific data values set to NULL and all thread-specific data keys shall be removed by the call to exec without running  destruc‐
       tors.

       The initial thread in the new process image shall be joinable, as if created with the detachstate attribute set to PTHREAD_CREATE_JOINABLE.

       The new process shall inherit at least the following attributes from the calling process image:

        *  Nice value (see nice())

        *  semadj values (see semop())

        *  Process ID

        *  Parent process ID

        *  Process group ID

        *  Session membership

        *  Real user ID

        *  Real group ID

        *  Supplementary group IDs

        *  Time left until an alarm clock signal (see alarm())

        *  Current working directory

        *  Root directory

        *  File mode creation mask (see umask())

        *  File size limit (see getrlimit() and setrlimit())

        *  Process signal mask (see pthread_sigmask())

        *  Pending signal (see sigpending())

        *  tms_utime, tms_stime, tms_cutime, and tms_cstime (see times())

        *  Resource limits

        *  Controlling terminal

        *  Interval timers

       The initial thread of the new process shall inherit at least the following attributes from the calling thread:

        *  Signal mask (see sigprocmask() and pthread_sigmask())

        *  Pending signals (see sigpending())

       All  other  process attributes defined in this volume of POSIX.1‐2017 shall be inherited in the new process image from the old process image. All other thread attributes defined in this volume of
       POSIX.1‐2017 shall be inherited in the initial thread in the new process image from the calling thread in the old process image.  The inheritance of process or thread attributes  not  defined  by
       this volume of POSIX.1‐2017 is implementation-defined.

       A  call  to any exec function from a process with more than one thread shall result in all threads being terminated and the new executable image being loaded and executed. No destructor functions
       or cleanup handlers shall be called.

       Upon successful completion, the exec functions shall mark for update the last data access timestamp of the file. If an exec function failed but was able to locate the process image file,  whether
       the  last data access timestamp is marked for update is unspecified. Should the exec function succeed, the process image file shall be considered to have been opened with open().  The correspond‐
       ing close() shall be considered to occur at a time after this open, but before process termination or successful completion of a subsequent call to one of the exec  functions,  posix_spawn(),  or
       posix_spawnp().   The argv[] and envp[] arrays of pointers and the strings to which those arrays point shall not be modified by a call to one of the exec functions, except as a consequence of re‐
       placing the process image.

       The saved resource limits in the new process image are set to be a copy of the process' corresponding hard and soft limits.

RETURN VALUE
       If one of the exec functions returns to the calling process image, an error has occurred; the return value shall be -1, and errno shall be set to indicate the error.

ERRORS
       The exec functions shall fail if:

       E2BIG  The number of bytes used by the new process image's argument list and environment list is greater than the system-imposed limit of {ARG_MAX} bytes.

       EACCES The new process image file is not a regular file and the implementation does not support execution of files of its type.

       EINVAL The new process image file has appropriate privileges and has a recognized executable binary format, but the system does not support execution of a file with this format.

       The exec functions, except for fexecve(), shall fail if:

       EACCES Search permission is denied for a directory listed in the new process image file's path prefix, or the new process image file denies execution permission.

       ELOOP  A loop exists in symbolic links encountered during resolution of the path or file argument.

       ENAMETOOLONG
              The length of a component of a pathname is longer than {NAME_MAX}.

       ENOENT A component of path or file does not name an existing file or path or file is an empty string.

       ENOTDIR
              A component of the new process image file's path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the new process image file's pathname con‐
              tains at least one non-<slash> character and ends with one or more trailing <slash> characters and the last pathname component names an existing file that is neither a directory nor a sym‐
              bolic link to a directory.

       The exec functions, except for execlp() and execvp(), shall fail if:

       ENOEXEC
              The new process image file has the appropriate access permission but has an unrecognized format.

       The fexecve() function shall fail if:

       EBADF  The fd argument is not a valid file descriptor open for executing.

       The exec functions may fail if:

       ENOMEM The new process image requires more memory than is allowed by the hardware or system-imposed memory management constraints.

       The exec functions, except for fexecve(), may fail if:

       ELOOP  More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path or file argument.

       ENAMETOOLONG
              The length of the path argument or the length of the pathname constructed from the file argument exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate  re‐
              sult with a length that exceeds {PATH_MAX}.

       ETXTBSY
              The new process image file is a pure procedure (shared text) file that is currently open for writing by some process.

       The following sections are informative.

EXAMPLES
   Using execl()
       The following example executes the ls command, specifying the pathname of the executable (/bin/ls) and using arguments supplied directly to the command to produce single-column output.

           #include <unistd.h>

           int ret;
           ...
           ret = execl ("/bin/ls", "ls", "-1", (char *)0);

   Using execle()
       The following example is similar to Using execl().  In addition, it specifies the environment for the new process image using the env argument.

           #include <unistd.h>

           int ret;
           char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
           ...
           ret = execle ("/bin/ls", "ls", "-l", (char *)0, env);

   Using execlp()
       The following example searches for the location of the ls command among the directories specified by the PATH environment variable.

           #include <unistd.h>

           int ret;
           ...
           ret = execlp ("ls", "ls", "-l", (char *)0);

   Using execv()
       The following example passes arguments to the ls command in the cmd array.

           #include <unistd.h>

           int ret;
           char *cmd[] = { "ls", "-l", (char *)0 };
           ...
           ret = execv ("/bin/ls", cmd);

   Using execve()
       The following example passes arguments to the ls command in the cmd array, and specifies the environment for the new process image using the env argument.

           #include <unistd.h>

           int ret;
           char *cmd[] = { "ls", "-l", (char *)0 };
           char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
           ...
           ret = execve ("/bin/ls", cmd, env);

   Using execvp()
       The following example searches for the location of the ls command among the directories specified by the PATH environment variable, and passes arguments to the ls command in the cmd array.

           #include <unistd.h>

           int ret;
           char *cmd[] = { "ls", "-l", (char *)0 };
           ...
           ret = execvp ("ls", cmd);

APPLICATION USAGE
       As  the  state of conversion descriptors and message catalog descriptors in the new process image is undefined, conforming applications should not rely on their use and should close them prior to
       calling one of the exec functions.

       Applications that require other than the default POSIX locale as the global locale in the new process image should call setlocale() with the appropriate parameters.

       When assigning a new value to the environ variable, applications should ensure that the environment to which it will point contains at least the following:

        1. Any implementation-defined variables required by the implementation to provide a conforming environment. See the _CS_V7_ENV entry in <unistd.h> and confstr() for details.

        2. A value for PATH which finds conforming versions of all standard utilities before any other versions.

       The same constraint applies to the envp array passed to execle() or execve(), in order to ensure that the new process image is invoked in a conforming environment.

       Applications should not execute programs with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing, as this might cause the executed program to misbehave. In
       order  not  to  pass  on these file descriptors to an executed program, applications should not just close them but should reopen them on, for example, /dev/null.  Some implementations may reopen
       them automatically, but applications should not rely on this being done.

       If an application wants to perform a checksum test of the file being executed before executing it, the file will need to be opened with read permission to perform the checksum test.

       Since execute permission is checked by fexecve(), the file description fd need not have been opened with the O_EXEC flag. However, if the file to be executed denies read and write permission  for
       the  process  preparing  to  do  the exec, the only way to provide the fd to fexecve() will be to use the O_EXEC flag when opening fd.  In this case, the application will not be able to perform a
       checksum test since it will not be able to read the contents of the file.

       Note that when a file descriptor is opened with O_RDONLY, O_RDWR, or O_WRONLY mode, the file descriptor can be used to read, read and write, or write the file, respectively, even if the  mode  of
       the file changes after the file was opened. Using the O_EXEC open mode is different; fexecve() will ignore the mode that was used when the file descriptor was opened and the exec will fail if the
       mode of the file associated with fd does not grant execute permission to the calling process at the time fexecve() is called.

RATIONALE
       Early proposals required that the value of argc passed to main() be ``one or greater''. This was driven by the same requirement in drafts of the ISO C standard.  In fact,  historical  implementa‐
       tions  have passed a value of zero when no arguments are supplied to the caller of the exec functions. This requirement was removed from the ISO C standard and subsequently removed from this vol‐
       ume of POSIX.1‐2017 as well. The wording, in particular the use of the word should, requires a Strictly Conforming POSIX Application to pass at least one argument to the exec function, thus guar‐
       anteeing  that  argc  be one or greater when invoked by such an application. In fact, this is good practice, since many existing applications reference argv[0] without first checking the value of
       argc.

       The requirement on a Strictly Conforming POSIX Application also states that the value passed as the first argument be a filename string associated with the process being  started.  Although  some
       existing  applications  pass  a pathname rather than a filename string in some circumstances, a filename string is more generally useful, since the common usage of argv[0] is in printing diagnos‐
       tics. In some cases the filename passed is not the actual filename of the file; for example, many implementations of the login utility use a convention of prefixing a <hyphen-minus> ('‐') to  the
       actual filename, which indicates to the command interpreter being invoked that it is a ``login shell''.

       Also, note that the test and [ utilities require specific strings for the argv[0] argument to have deterministic behavior across all implementations.

       Historically, there have been two ways that implementations can exec shell scripts.

       One  common  historical  implementation  is  that  the  execl(), execv(), execle(), and execve() functions return an [ENOEXEC] error for any file not recognizable as executable, including a shell
       script. When the execlp() and execvp() functions encounter such a file, they assume the file to be a shell script and invoke a known command interpreter to interpret such files.  This is now  re‐
       quired by POSIX.1‐2008. These implementations of execvp() and execlp() only give the [ENOEXEC] error in the rare case of a problem with the command interpreter's executable file. Because of these
       implementations, the [ENOEXEC] error is not mentioned for execlp() or execvp(), although implementations can still give it.

       Another way that some historical implementations handle shell scripts is by recognizing the first two bytes of the file as the character string "#!" and using the remainder of the first  line  of
       the file as the name of the command interpreter to execute.

       One  potential  source  of  confusion noted by the standard developers is over how the contents of a process image file affect the behavior of the exec family of functions. The following is a de‐
       scription of the actions taken:

        1. If the process image file is a valid executable (in a format that is executable and valid and having appropriate privileges) for this system, then the system executes the file.

        2. If the process image file has appropriate privileges and is in a format that is executable but not valid for this system (such as a recognized binary for another architecture), then  this  is
           an error and errno is set to [EINVAL] (see later RATIONALE on [EINVAL]).

        3. If the process image file has appropriate privileges but is not otherwise recognized:

            a. If this is a call to execlp() or execvp(), then they invoke a command interpreter assuming that the process image file is a shell script.

            b. If this is not a call to execlp() or execvp(), then an error occurs and errno is set to [ENOEXEC].

       Applications that do not require to access their arguments may use the form:

           main(void)

       as specified in the ISO C standard. However, the implementation will always provide the two arguments argc and argv, even if they are not used.

       Some  implementations  provide a third argument to main() called envp.  This is defined as a pointer to the environment. The ISO C standard specifies invoking main() with two arguments, so imple‐
       mentations must support applications written this way. Since this volume of POSIX.1‐2017 defines the global variable environ, which is also provided by historical implementations and can be  used
       anywhere  that  envp could be used, there is no functional need for the envp argument. Applications should use the getenv() function rather than accessing the environment directly via either envp
       or environ.  Implementations are required to support the two-argument calling sequence, but this does not prohibit an implementation from supporting envp as an optional third argument.

       This volume of POSIX.1‐2017 specifies that signals set to SIG_IGN remain set to SIG_IGN, and that the new process image inherits the signal mask of the thread that called exec in the old  process
       image. This is consistent with historical implementations, and it permits some useful functionality, such as the nohup command. However, it should be noted that many existing applications wrongly
       assume that they start with certain signals set to the default action and/or unblocked. In particular, applications written with a simpler signal model that does not include blocking of  signals,
       such  as  the one in the ISO C standard, may not behave properly if invoked with some signals blocked. Therefore, it is best not to block or ignore signals across execs without explicit reason to
       do so, and especially not to block signals across execs of arbitrary (not closely cooperating) programs.

       The exec functions always save the value of the effective user ID and effective group ID of the process at the completion of the exec, whether or not the set-user-ID or the  set-group-ID  bit  of
       the process image file is set.

       The  statement  about  argv[] and envp[] being constants is included to make explicit to future writers of language bindings that these objects are completely constant. Due to a limitation of the
       ISO C standard, it is not possible to state that idea in standard C. Specifying two levels of const-qualification for the argv[] and envp[] parameters for the exec functions may seem  to  be  the
       natural choice, given that these functions do not modify either the array of pointers or the characters to which the function points, but this would disallow existing correct code.  Instead, only
       the array of pointers is noted as constant. The table of assignment compatibility for dst=src derived from the ISO C standard summarizes the compatibility:

                                                             ┌────────────────────┬──────────┬────────────────┬───────────────┬─────────────────────┐
                                                             │               dst: │ char *[] │ const char *[] │ char *const[] │ const char *const[] │
                                                             ├────────────────────┼──────────┼────────────────┼───────────────┼─────────────────────┤
                                                             │src:                │          │                │               │                     │
                                                             │char *[]            │  VALID   │       —        │     VALID     │          —          │
                                                             │const char *[]      │    —     │     VALID      │       —       │        VALID        │
                                                             │char * const []     │    —     │       —        │     VALID     │          —          │
                                                             │const char *const[] │    —     │       —        │       —       │        VALID        │
                                                             └────────────────────┴──────────┴────────────────┴───────────────┴─────────────────────┘
       Since all existing code has a source type matching the first row, the column that gives the most valid combinations is the third column. The only other possibility is the fourth column, but using
       it  would require a cast on the argv or envp arguments. It is unfortunate that the fourth column cannot be used, because the declaration a non-expert would naturally use would be that in the sec‐
       ond row.

       The ISO C standard and this volume of POSIX.1‐2017 do not conflict on the use of environ, but some historical implementations of environ may cause a conflict. As long as environ is treated in the
       same way as an entry point (for example, fork()), it conforms to both standards. A library can contain fork(), but if there is a user-provided fork(), that fork() is given precedence and no prob‐
       lem ensues. The situation is similar for environ: the definition in this volume of POSIX.1‐2017 is to be used if there is no user-provided environ to take precedence. At least  three  implementa‐
       tions are known to exist that solve this problem.

       E2BIG  The limit {ARG_MAX} applies not just to the size of the argument list, but to the sum of that and the size of the environment list.

       EFAULT Some historical systems return [EFAULT] rather than [ENOEXEC] when the new process image file is corrupted. They are non-conforming.

       EINVAL This  error condition was added to POSIX.1‐2008 to allow an implementation to detect executable files generated for different architectures, and indicate this situation to the application.
              Historical implementations of shells, execvp(), and execlp() that encounter an [ENOEXEC] error will execute a shell on the assumption that the file is a shell script. This will not produce
              the  desired  effect  when the file is a valid executable for a different architecture. An implementation may now choose to avoid this problem by returning [EINVAL] when a valid executable
              for a different architecture is encountered.  Some historical implementations return [EINVAL] to indicate that the path argument contains a character with the high order bit set. The stan‐
              dard developers chose to deviate from historical practice for the following reasons:

                    1. The new utilization of [EINVAL] will provide some measure of utility to the user community.

                    2. Historical use of [EINVAL] is not acceptable in an internationalized operating environment.

       ENAMETOOLONG
              Since  the  file  pathname  may be constructed by taking elements in the PATH variable and putting them together with the filename, the [ENAMETOOLONG] error condition could also be reached
              this way.

       ETXTBSY
              System V returns this error when the executable file is currently open for writing by some process. This volume of POSIX.1‐2017 neither requires nor prohibits this behavior.

       Other systems (such as System V) may return [EINTR] from exec.  This is not addressed by this volume of POSIX.1‐2017, but implementations may have a window between the call to exec and  the  time
       that a signal could cause one of the exec calls to return with [EINTR].

       An explicit statement regarding the floating-point environment (as defined in the <fenv.h> header) was added to make it clear that the floating-point environment is set to its default when a call
       to one of the exec functions succeeds. The requirements for inheritance or setting to the default for other process and thread start-up functions is covered by more generic  statements  in  their
       descriptions and can be summarized as follows:

       posix_spawn() Set to default.

       fork()        Inherit.

       pthread_create()
                     Inherit.

       The  purpose of the fexecve() function is to enable executing a file which has been verified to be the intended file. It is possible to actively check the file by reading from the file descriptor
       and be sure that the file is not exchanged for another between the reading and the execution. Alternatively, a function like openat() can be used to open a file which has been  found  by  reading
       the content of a directory using readdir().

FUTURE DIRECTIONS
       None.

SEE ALSO
       alarm(), atexit(), chmod(), close(), confstr(), exit(), fcntl(), fork(), fstatvfs(), getenv(), getitimer(), getrlimit(), mknod(), mmap(), nice(), open(), posix_spawn(), posix_trace_create(),
       posix_trace_event(), posix_trace_eventid_equal(), pthread_atfork(), pthread_sigmask(), putenv(), readdir(), semop(), setlocale(), shmat(), sigaction(), sigaltstack(), sigpending(), system(),
       times(), ulimit(), umask()

       The Base Definitions volume of POSIX.1‐2017, Chapter 8, Environment Variables, <unistd.h>

       The Shell and Utilities volume of POSIX.1‐2017, test

COPYRIGHT
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group
       Base Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any discrepancy between this  ver‐
       sion  and  the  original  IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be obtained online at http://www.open‐
       group.org/unix/online.html .

       Any typographical or formatting errors that appear in this page are most likely to have been introduced during the conversion of the source files to man page format. To report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                                                                2017                                                                                           EXEC(3P)
