TEST(1)                                                                                        User Commands                                                                                       TEST(1)

NAME
       test - check file types and compare values

SYNOPSIS
       test EXPRESSION
       test
       [ EXPRESSION ]
       [ ]
       [ OPTION

DESCRIPTION
       Exit with the status determined by EXPRESSION.

       --help display this help and exit

       --version
              output version information and exit

       An omitted EXPRESSION defaults to false.  Otherwise, EXPRESSION is true or false and sets exit status.  It is one of:

       ( EXPRESSION )
              EXPRESSION is true

       ! EXPRESSION
              EXPRESSION is false

       EXPRESSION1 -a EXPRESSION2
              both EXPRESSION1 and EXPRESSION2 are true

       EXPRESSION1 -o EXPRESSION2
              either EXPRESSION1 or EXPRESSION2 is true

       -n STRING
              the length of STRING is nonzero

       STRING equivalent to -n STRING

       -z STRING
              the length of STRING is zero

       STRING1 = STRING2
              the strings are equal

       STRING1 != STRING2
              the strings are not equal

       INTEGER1 -eq INTEGER2
              INTEGER1 is equal to INTEGER2

       INTEGER1 -ge INTEGER2
              INTEGER1 is greater than or equal to INTEGER2

       INTEGER1 -gt INTEGER2
              INTEGER1 is greater than INTEGER2

       INTEGER1 -le INTEGER2
              INTEGER1 is less than or equal to INTEGER2

       INTEGER1 -lt INTEGER2
              INTEGER1 is less than INTEGER2

       INTEGER1 -ne INTEGER2
              INTEGER1 is not equal to INTEGER2

       FILE1 -ef FILE2
              FILE1 and FILE2 have the same device and inode numbers

       FILE1 -nt FILE2
              FILE1 is newer (modification date) than FILE2

       FILE1 -ot FILE2
              FILE1 is older than FILE2

       -b FILE
              FILE exists and is block special

       -c FILE
              FILE exists and is character special

       -d FILE
              FILE exists and is a directory

       -e FILE
              FILE exists

       -f FILE
              FILE exists and is a regular file

       -g FILE
              FILE exists and is set-group-ID

       -G FILE
              FILE exists and is owned by the effective group ID

       -h FILE
              FILE exists and is a symbolic link (same as -L)

       -k FILE
              FILE exists and has its sticky bit set

       -L FILE
              FILE exists and is a symbolic link (same as -h)

       -N FILE
              FILE exists and has been modified since it was last read

       -O FILE
              FILE exists and is owned by the effective user ID

       -p FILE
              FILE exists and is a named pipe

       -r FILE
              FILE exists and the user has read access

       -s FILE
              FILE exists and has a size greater than zero

       -S FILE
              FILE exists and is a socket

       -t FD  file descriptor FD is opened on a terminal

       -u FILE
              FILE exists and its set-user-ID bit is set

       -w FILE
              FILE exists and the user has write access

       -x FILE
              FILE exists and the user has execute (or search) access

       Except for -h and -L, all FILE-related tests dereference symbolic links.  Beware that parentheses need to be escaped (e.g., by backslashes) for shells.  INTEGER may also be -l STRING, which eval‐
       uates to the length of STRING.

       NOTE: Binary -a and -o are inherently ambiguous.  Use 'test EXPR1 && test EXPR2' or 'test EXPR1 || test EXPR2' instead.

       NOTE: [ honors the --help and --version options, but test does not.  test treats each of those as it treats any other nonempty STRING.

       NOTE: your shell may have its own version of test and/or [, which usually supersedes the version described here.  Please refer to your shell's documentation for details about the options it  sup‐
       ports.

AUTHOR
       Written by Kevin Braunsdorf and Matthew Bradburn.

REPORTING BUGS
       GNU coreutils online help: <https://www.gnu.org/software/coreutils/>
       Report any translation bugs to <https://translationproject.org/team/>

COPYRIGHT
       Copyright © 2023 Free Software Foundation, Inc.  License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.
       This is free software: you are free to change and redistribute it.  There is NO WARRANTY, to the extent permitted by law.

SEE ALSO
       access(2)

       Full documentation <https://www.gnu.org/software/coreutils/test>
       or available locally via: info '(coreutils) test invocation'

GNU coreutils 9.2                                                                               April 2023                                                                                         TEST(1)
TEST(1P)                                                                                 POSIX Programmer's Manual                                                                                TEST(1P)

PROLOG
       This  manual  page is part of the POSIX Programmer's Manual.  The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or
       the interface may not be implemented on Linux.

NAME
       test — evaluate expression

SYNOPSIS
       test [expression]

       [ [expression] ]

DESCRIPTION
       The test utility shall evaluate the expression and indicate the result of the evaluation by its exit status. An exit status of zero indicates that the expression evaluated as  true  and  an  exit
       status of 1 indicates that the expression evaluated as false.

       In the second form of the utility, where the utility name used is [ rather than test, the application shall ensure that the closing square bracket is a separate argument. The test and [ utilities
       may be implemented as a single linked utility which examines the basename of the zeroth command line argument to determine whether to behave as the test  or  [  variant.  Applications  using  the
       exec()  family of functions to execute these utilities shall ensure that the argument passed in arg0 or argv[0] is '[' when executing the [ utility and has a basename of "test" when executing the
       test utility.

OPTIONS
       The test utility shall not recognize the "--" argument in the manner specified by Guideline 10 in the Base Definitions volume of POSIX.1‐2017, Section 12.2, Utility Syntax Guidelines.

       No options shall be supported.

OPERANDS
       The application shall ensure that all operators and elements of primaries are presented as separate arguments to the test utility.

       The following primaries can be used to construct expression:

       -b pathname
                 True if pathname resolves to an existing directory entry for a block special file.  False if pathname cannot be resolved, or if pathname resolves to an existing directory  entry  for  a
                 file that is not a block special file.

       -c pathname
                 True  if pathname resolves to an existing directory entry for a character special file.  False if pathname cannot be resolved, or if pathname resolves to an existing directory entry for
                 a file that is not a character special file.

       -d pathname
                 True if pathname resolves to an existing directory entry for a directory. False if pathname cannot be resolved, or if pathname resolves to an existing directory entry for a file that is
                 not a directory.

       -e pathname
                 True if pathname resolves to an existing directory entry. False if pathname cannot be resolved.

       -f pathname
                 True if pathname resolves to an existing directory entry for a regular file. False if pathname cannot be resolved, or if pathname resolves to an existing directory entry for a file that
                 is not a regular file.

       -g pathname
                 True if pathname resolves to an existing directory entry for a file that has its set-group-ID flag set. False if pathname cannot be resolved, or if pathname resolves to an existing  di‐
                 rectory entry for a file that does not have its set-group-ID flag set.

       -h pathname
                 True  if  pathname  resolves  to an existing directory entry for a symbolic link. False if pathname cannot be resolved, or if pathname resolves to an existing directory entry for a file
                 that is not a symbolic link. If the final component of pathname is a symbolic link, that symbolic link is not followed.

       -L pathname
                 True if pathname resolves to an existing directory entry for a symbolic link. False if pathname cannot be resolved, or if pathname resolves to an existing directory  entry  for  a  file
                 that is not a symbolic link. If the final component of pathname is a symbolic link, that symbolic link is not followed.

       -n string True if the length of string is non-zero; otherwise, false.

       -p pathname
                 True  if pathname resolves to an existing directory entry for a FIFO. False if pathname cannot be resolved, or if pathname resolves to an existing directory entry for a file that is not
                 a FIFO.

       -r pathname
                 True if pathname resolves to an existing directory entry for a file for which permission to read from the file will be granted, as defined in Section 1.1.1.4, File Read, Write, and Cre‐
                 ation.  False if pathname cannot be resolved, or if pathname resolves to an existing directory entry for a file for which permission to read from the file will not be granted.

       -S pathname
                 True  if  pathname  resolves to an existing directory entry for a socket. False if pathname cannot be resolved, or if pathname resolves to an existing directory entry for a file that is
                 not a socket.

       -s pathname
                 True if pathname resolves to an existing directory entry for a file that has a size greater than zero. False if pathname cannot be resolved, or if pathname resolves to an  existing  di‐
                 rectory entry for a file that does not have a size greater than zero.

       -t file_descriptor
                 True  if  file  descriptor number file_descriptor is open and is associated with a terminal. False if file_descriptor is not a valid file descriptor number, or if file descriptor number
                 file_descriptor is not open, or if it is open but is not associated with a terminal.

       -u pathname
                 True if pathname resolves to an existing directory entry for a file that has its set-user-ID flag set. False if pathname cannot be resolved, or if pathname resolves to an  existing  di‐
                 rectory entry for a file that does not have its set-user-ID flag set.

       -w pathname
                 True  if pathname resolves to an existing directory entry for a file for which permission to write to the file will be granted, as defined in Section 1.1.1.4, File Read, Write, and Cre‐
                 ation.  False if pathname cannot be resolved, or if pathname resolves to an existing directory entry for a file for which permission to write to the file will not be granted.

       -x pathname
                 True if pathname resolves to an existing directory entry for a file for which permission to execute the file (or search it, if it is a directory) will be granted, as defined in  Section
                 1.1.1.4,  File  Read,  Write,  and Creation.  False if pathname cannot be resolved, or if pathname resolves to an existing directory entry for a file for which permission to execute (or
                 search) the file will not be granted.

       -z string True if the length of string string is zero; otherwise, false.

       string    True if the string string is not the null string; otherwise, false.

       s1 = s2   True if the strings s1 and s2 are identical; otherwise, false.

       s1 != s2  True if the strings s1 and s2 are not identical; otherwise, false.

       n1 -eq n2 True if the integers n1 and n2 are algebraically equal; otherwise, false.

       n1 -ne n2 True if the integers n1 and n2 are not algebraically equal; otherwise, false.

       n1 -gt n2 True if the integer n1 is algebraically greater than the integer n2; otherwise, false.

       n1 -ge n2 True if the integer n1 is algebraically greater than or equal to the integer n2; otherwise, false.

       n1 -lt n2 True if the integer n1 is algebraically less than the integer n2; otherwise, false.

       n1 -le n2 True if the integer n1 is algebraically less than or equal to the integer n2; otherwise, false.

       expression1 -a expression2
                 True if both expression1 and expression2 are true; otherwise, false. The -a binary primary is left associative. It has a higher precedence than -o.

       expression1 -o expression2
                 True if either expression1 or expression2 is true; otherwise, false. The -o binary primary is left associative.

       With the exception of the -h pathname and -L pathname primaries, if a pathname argument is a symbolic link, test shall evaluate the expression by resolving the symbolic link and  using  the  file
       referenced by the link.

       These primaries can be combined with the following operators:

       ! expression
                 True if expression is false. False if expression is true.

       ( expression )
                 True if expression is true. False if expression is false. The parentheses can be used to alter the normal precedence and associativity.

       The primaries with two elements of the form:

           -primary_operator primary_operand

       are known as unary primaries.  The primaries with three elements in either of the two forms:

           primary_operand -primary_operator primary_operand

           primary_operand primary_operator primary_operand

       are known as binary primaries.  Additional implementation-defined operators and primary_operators may be provided by implementations. They shall be of the form -operator where the first character
       of operator is not a digit.

       The algorithm for determining the precedence of the operators and the return value that shall be generated is based on the number of arguments presented to test.  (However, when using the "[...]"
       form, the <right-square-bracket> final argument shall not be counted in this algorithm.)

       In the following list, $1, $2, $3, and $4 represent the arguments presented to test:

       0 arguments:
                   Exit false (1).

       1 argument: Exit true (0) if $1 is not null; otherwise, exit false.

       2 arguments:
                    *  If $1 is '!', exit true if $2 is null, false if $2 is not null.

                    *  If $1 is a unary primary, exit true if the unary test is true, false if the unary test is false.

                    *  Otherwise, produce unspecified results.

       3 arguments:
                    *  If $2 is a binary primary, perform the binary test of $1 and $3.

                    *  If $1 is '!', negate the two-argument test of $2 and $3.

                    *  If $1 is '(' and $3 is ')', perform the unary test of $2.  On systems that do not support the XSI option, the results are unspecified if $1 is '(' and $3 is ')'.

                    *  Otherwise, produce unspecified results.

       4 arguments:
                    *  If $1 is '!', negate the three-argument test of $2, $3, and $4.

                    *  If $1 is '(' and $4 is ')', perform the two-argument test of $2 and $3.  On systems that do not support the XSI option, the results are unspecified if $1 is '(' and $4 is ')'.

                    *  Otherwise, the results are unspecified.

       >4 arguments:
                   The results are unspecified.

                   On  XSI-conformant  systems, combinations of primaries and operators shall be evaluated using the precedence and associativity rules described previously. In addition, the string com‐
                   parison binary primaries '=' and "!=" shall have a higher precedence than any unary primary.

STDIN
       Not used.

INPUT FILES
       None.

ENVIRONMENT VARIABLES
       The following environment variables shall affect the execution of test:

       LANG      Provide a default value for the internationalization variables that are unset or null. (See the Base Definitions volume of POSIX.1‐2017, Section 8.2, Internationalization Variables  for
                 the precedence of internationalization variables used to determine the values of locale categories.)

       LC_ALL    If set to a non-empty string value, override the values of all the other internationalization variables.

       LC_CTYPE  Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as opposed to multi-byte characters in arguments).

       LC_MESSAGES
                 Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.

       NLSPATH   Determine the location of message catalogs for the processing of LC_MESSAGES.

ASYNCHRONOUS EVENTS
       Default.

STDOUT
       Not used.

STDERR
       The standard error shall be used only for diagnostic messages.

OUTPUT FILES
       None.

EXTENDED DESCRIPTION
       None.

EXIT STATUS
       The following exit values shall be returned:

        0    expression evaluated to true.

        1    expression evaluated to false or expression was missing.

       >1    An error occurred.

CONSEQUENCES OF ERRORS
       Default.

       The following sections are informative.

APPLICATION USAGE
       The  XSI  extensions  specifying the -a and -o binary primaries and the '(' and ')' operators have been marked obsolescent. (Many expressions using them are ambiguously defined by the grammar de‐
       pending on the specific expressions being evaluated.) Scripts using these expressions should be converted to the forms given below. Even though many implementations will continue to support these
       obsolescent  forms, scripts should be extremely careful when dealing with user-supplied input that could be confused with these and other primaries and operators. Unless the application developer
       knows all the cases that produce input to the script, invocations like:

           test "$1" -a "$2"

       should be written as:

           test "$1" && test "$2"

       to avoid problems if a user supplied values such as $1 set to '!'  and $2 set to the null string. That is, in cases where maximal portability is of concern, replace:

           test expr1 -a expr2

       with:

           test expr1 && test expr2

       and replace:

           test expr1 -o expr2

       with:

           test expr1 || test expr2

       but note that, in test, -a has higher precedence than -o while "&&" and "||" have equal precedence in the shell.

       Parentheses or braces can be used in the shell command language to effect grouping.

       Parentheses must be escaped when using sh; for example:

           test \( expr1 -a expr2 \) -o expr3

       This command is not always portable even on XSI-conformant systems depending on the expressions specified by expr1, expr2, and expr3.  The following form can be used instead:

           ( test expr1 && test expr2 ) || test expr3

       The two commands:

           test "$1"
           test ! "$1"

       could not be used reliably on some historical systems. Unexpected results would occur if such a string expression were used and $1 expanded to '!', '(', or a  known  unary  primary.  Better  con‐
       structs are:

           test -n "$1"
           test -z "$1"

       respectively.

       Historical systems have also been unreliable given the common construct:

           test "$response" = "expected string"

       One of the following is a more reliable form:

           test "X$response" = "Xexpected string"
           test "expected string" = "$response"

       Note  that  the second form assumes that expected string could not be confused with any unary primary. If expected string starts with '-', '(', '!', or even '=', the first form should be used in‐
       stead. Using the preceding rules without the XSI marked extensions, any of the three comparison forms is reliable, given any input. (However, note that the strings are quoted in all cases.)

       Because the string comparison binary primaries, '=' and "!=", have a higher precedence than any unary primary in the greater than 4 argument case, unexpected results can occur  if  arguments  are
       not properly prepared. For example, in:

           test -d $1 -o -d $2

       If  $1  evaluates to a possible directory name of '=', the first three arguments are considered a string comparison, which shall cause a syntax error when the second -d is encountered. One of the
       following forms prevents this; the second is preferred:

           test \( -d "$1" \) -o \( -d "$2" \)
           test -d "$1" || test -d "$2"

       Also in the greater than 4 argument case:

           test "$1" = "bat" -a "$2" = "ball"

       syntax errors occur if $1 evaluates to '(' or '!'.  One of the following forms prevents this; the third is preferred:

           test "X$1" = "Xbat" -a "X$2" = "Xball"
           test "$1" = "bat" && test "$2" = "ball"
           test "X$1" = "Xbat" && test "X$2" = "Xball"

       Note that none of the following examples are permitted by the syntax described:

           [-f file]
           [-f file ]
           [ -f file]
           [ -f file
           test -f file ]

       In the first two cases, if a utility named [‐f exists, that utility would be invoked, and not test.  In the remaining cases, the brackets are mismatched, and the behavior is unspecified. However:

           test ! ]

       does have a defined meaning, and must exit with status 1. Similarly:

           test ]

       must exit with status 0.

EXAMPLES
        1. Exit if there are not two or three arguments (two variations):

               if [ $# -ne 2 ] && [ $# -ne 3 ]; then exit 1; fi
               if [ $# -lt 2 ] || [ $# -gt 3 ]; then exit 1; fi

        2. Perform a mkdir if a directory does not exist:

               test ! -d tempdir && mkdir tempdir

        3. Wait for a file to become non-readable:

               while test -r thefile
               do
                   sleep 30
               done
               echo '"thefile" is no longer readable'

        4. Perform a command if the argument is one of three strings (two variations):

               if [ "$1" = "pear" ] || [ "$1" = "grape" ] || [ "$1" = "apple" ]
               then
                   command
               fi

               case "$1" in
                   pear|grape|apple) command ;;
               esac

RATIONALE
       The KornShell-derived conditional command (double bracket [[]]) was removed from the shell command language description in an early proposal. Objections were raised that the real problem is  mis‐
       use of the test command ([), and putting it into the shell is the wrong way to fix the problem.  Instead, proper documentation and a new shell reserved word (!)  are sufficient.

       Tests that require multiple test operations can be done at the shell level using individual invocations of the test command and shell logicals, rather than using the error-prone -o flag of test.

       XSI-conformant systems support more than four arguments.

       XSI-conformant systems support the combining of primaries with the following constructs:

       expression1 -a expression2
             True if both expression1 and expression2 are true.

       expression1 -o expression2
             True if at least one of expression1 and expression2 are true.

       ( expression )
             True if expression is true.

       In evaluating these more complex combined expressions, the following precedence rules are used:

        *  The unary primaries have higher precedence than the algebraic binary primaries.

        *  The unary primaries have lower precedence than the string binary primaries.

        *  The unary and binary primaries have higher precedence than the unary string primary.

        *  The !  operator has higher precedence than the -a operator, and the -a operator has higher precedence than the -o operator.

        *  The -a and -o operators are left associative.

        *  The parentheses can be used to alter the normal precedence and associativity.

       The BSD and System V versions of -f are not the same. The BSD definition was:

       -f file   True if file exists and is not a directory.

       The  SVID version (true if the file exists and is a regular file) was chosen for this volume of POSIX.1‐2017 because its use is consistent with the -b, -c, -d, and -p operands (file exists and is
       a specific file type).

       The -e primary, possessing similar functionality to that provided by the C shell, was added because it provides the only way for a shell script to find out if a file exists without trying to open
       the file. Since implementations are allowed to add additional file types, a portable script cannot use:

           test -b foo -o -c foo -o -d foo -o -f foo -o -p foo

       to find out if foo is an existing file. On historical BSD systems, the existence of a file could be determined by:

           test -f foo -o -d foo

       but  there was no easy way to determine that an existing file was a regular file. An early proposal used the KornShell -a primary (with the same meaning), but this was changed to -e because there
       were concerns about the high probability of humans confusing the -a primary with the -a binary operator.

       The following options were not included in this volume of POSIX.1‐2017, although they are provided by some implementations. These operands should not be used by new implementations for other pur‐
       poses:

       -k file   True if file exists and its sticky bit is set.

       -C file   True if file is a contiguous file.

       -V file   True if file is a version file.

       The  following  option  was not included because it was undocumented in most implementations, has been removed from some implementations (including System V), and the functionality is provided by
       the shell (see Section 2.6.2, Parameter Expansion.

       -l string The length of the string string.

       The -b, -c, -g, -p, -u, and -x operands are derived from the SVID; historical BSD does not provide them. The -k operand is derived from System V; historical BSD does not provide it.

       On historical BSD systems, test -w directory always returned false because test tried to open the directory for writing, which always fails.

       Some additional primaries newly invented or from the KornShell appeared in an early proposal as part of the conditional command ([[]]): s1 > s2, s1 < s2, str = pattern, str != pattern, f1 -nt f2,
       f1  -ot  f2,  and  f1  -ef f2.  They were not carried forward into the test utility when the conditional command was removed from the shell because they have not been included in the test utility
       built into historical implementations of the sh utility.

       The -t file_descriptor primary is shown with a mandatory argument because the grammar is ambiguous if it can be omitted. Historical implementations have allowed it to be omitted, providing a  de‐
       fault of 1.

       It  is noted that '[' is not part of the portable filename character set; however, since it is required to be encoded by a single byte, and is part of the portable character set, the name of this
       utility forms a character string across all supported locales.

FUTURE DIRECTIONS
       None.

SEE ALSO
       Section 1.1.1.4, File Read, Write, and Creation, find

       The Base Definitions volume of POSIX.1‐2017, Chapter 8, Environment Variables, Section 12.2, Utility Syntax Guidelines

COPYRIGHT
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group
       Base  Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any discrepancy between this ver‐
       sion and the original IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be  obtained  online  at  http://www.open‐
       group.org/unix/online.html .

       Any  typographical  or  formatting errors that appear in this page are most likely to have been introduced during the conversion of the source files to man page format. To report such errors, see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                                                                2017                                                                                           TEST(1P)
Test(3perl)                                                                          Perl Programmers Reference Guide                                                                          Test(3perl)

NAME
       Test - provides a simple framework for writing test scripts

SYNOPSIS
         use strict;
         use Test;

         # use a BEGIN block so we print our plan before MyModule is loaded
         BEGIN { plan tests => 14, todo => [3,4] }

         # load your module...
         use MyModule;

         # Helpful notes.  All note-lines must start with a "#".
         print "# I'm testing MyModule version $MyModule::VERSION\n";

         ok(0); # failure
         ok(1); # success

         ok(0); # ok, expected failure (see todo list, above)
         ok(1); # surprise success!

         ok(0,1);             # failure: '0' ne '1'
         ok('broke','fixed'); # failure: 'broke' ne 'fixed'
         ok('fixed','fixed'); # success: 'fixed' eq 'fixed'
         ok('fixed',qr/x/);   # success: 'fixed' =~ qr/x/

         ok(sub { 1+1 }, 2);  # success: '2' eq '2'
         ok(sub { 1+1 }, 3);  # failure: '2' ne '3'

         my @list = (0,0);
         ok @list, 3, "\@list=".join(',',@list);      #extra notes
         ok 'segmentation fault', '/(?i)success/';    #regex match

         skip(
           $^O =~ m/MSWin/ ? "Skip if MSWin" : 0,  # whether to skip
           $foo, $bar  # arguments just like for ok(...)
         );
         skip(
           $^O =~ m/MSWin/ ? 0 : "Skip unless MSWin",  # whether to skip
           $foo, $bar  # arguments just like for ok(...)
         );

DESCRIPTION
       This module simplifies the task of writing test files for Perl modules, such that their output is in the format that Test::Harness expects to see.

QUICK START GUIDE
       To write a test for your new (and probably not even done) module, create a new file called t/test.t (in a new t directory). If you have multiple test files, to test the "foo", "bar", and "baz"
       feature sets, then feel free to call your files t/foo.t, t/bar.t, and t/baz.t

   Functions
       This module defines three public functions, "plan(...)", "ok(...)", and "skip(...)".  By default, all three are exported by the "use Test;" statement.

       "plan(...)"
                BEGIN { plan %theplan; }

           This should be the first thing you call in your test script.  It declares your testing plan, how many there will be, if any of them should be allowed to fail, and so on.

           Typical usage is just:

                use Test;
                BEGIN { plan tests => 23 }

           These are the things that you can put in the parameters to plan:

           "tests => number"
               The number of tests in your script.  This means all ok() and skip() calls.

           "todo => [1,5,14]"
               A reference to a list of tests which are allowed to fail.  See "TODO TESTS".

           "onfail => sub { ... }"
           "onfail => \&some_sub"
               A subroutine reference to be run at the end of the test script, if any of the tests fail.  See "ONFAIL".

           You must call "plan(...)" once and only once.  You should call it in a "BEGIN {...}" block, like so:

                BEGIN { plan tests => 23 }

       "ok(...)"
             ok(1 + 1 == 2);
             ok($have, $expect);
             ok($have, $expect, $diagnostics);

           This function is the reason for "Test"'s existence.  It's the basic function that handles printing ""ok"" or ""not ok"", along with the current test number.  (That's what "Test::Harness"
           wants to see.)

           In its most basic usage, "ok(...)" simply takes a single scalar expression.  If its value is true, the test passes; if false, the test fails.  Examples:

               # Examples of ok(scalar)

               ok( 1 + 1 == 2 );           # ok if 1 + 1 == 2
               ok( $foo =~ /bar/ );        # ok if $foo contains 'bar'
               ok( baz($x + $y) eq 'Armondo' );    # ok if baz($x + $y) returns
                                                   # 'Armondo'
               ok( @a == @b );             # ok if @a and @b are the same
                                           # length

           The expression is evaluated in scalar context.  So the following will work:

               ok( @stuff );                       # ok if @stuff has any
                                                   # elements
               ok( !grep !defined $_, @stuff );    # ok if everything in @stuff
                                                   # is defined.

           A special case is if the expression is a subroutine reference (in either "sub {...}" syntax or "\&foo" syntax).  In that case, it is executed and its value (true or false) determines if the
           test passes or fails.  For example,

               ok( sub {   # See whether sleep works at least passably
                 my $start_time = time;
                 sleep 5;
                 time() - $start_time  >= 4
               });

           In its two-argument form, "ok(arg1, arg2)" compares the two scalar values to see if they match.  They match if both are undefined, or if arg2 is a regex that matches arg1, or if they compare
           equal with "eq".

               # Example of ok(scalar, scalar)

               ok( "this", "that" );               # not ok, 'this' ne 'that'
               ok( "", undef );                    # not ok, "" is defined

           The second argument is considered a regex if it is either a regex object or a string that looks like a regex.  Regex objects are constructed with the qr// operator in recent versions of perl.
           A string is considered to look like a regex if its first and last characters are "/", or if the first character is "m" and its second and last characters are both the same non-alphanumeric
           non-whitespace character.  These regexp

           Regex examples:

               ok( 'JaffO', '/Jaff/' );    # ok, 'JaffO' =~ /Jaff/
               ok( 'JaffO', 'm|Jaff|' );   # ok, 'JaffO' =~ m|Jaff|
               ok( 'JaffO', qr/Jaff/ );    # ok, 'JaffO' =~ qr/Jaff/;
               ok( 'JaffO', '/(?i)jaff/ ); # ok, 'JaffO' =~ /jaff/i;

           If either (or both!) is a subroutine reference, it is run and used as the value for comparing.  For example:

               ok sub {
                   open(OUT, '>', 'x.dat') || die $!;
                   print OUT "\x{e000}";
                   close OUT;
                   my $bytecount = -s 'x.dat';
                   unlink 'x.dat' or warn "Can't unlink : $!";
                   return $bytecount;
                 },
                 4
               ;

           The above test passes two values to "ok(arg1, arg2)" -- the first a coderef, and the second is the number 4.  Before "ok" compares them, it calls the coderef, and uses its return value as the
           real value of this parameter. Assuming that $bytecount returns 4, "ok" ends up testing "4 eq 4".  Since that's true, this test passes.

           Finally, you can append an optional third argument, in "ok(arg1,arg2, note)", where note is a string value that will be printed if the test fails.  This should be some useful information
           about the test, pertaining to why it failed, and/or a description of the test.  For example:

               ok( grep($_ eq 'something unique', @stuff), 1,
                   "Something that should be unique isn't!\n".
                   '@stuff = '.join ', ', @stuff
                 );

           Unfortunately, a note cannot be used with the single argument style of "ok()".  That is, if you try "ok(arg1, note)", then "Test" will interpret this as "ok(arg1, arg2)", and probably end up
           testing "arg1 eq arg2" -- and that's not what you want!

           All of the above special cases can occasionally cause some problems.  See "BUGS and CAVEATS".

       "skip(skip_if_true, args...)"
           This is used for tests that under some conditions can be skipped.  It's basically equivalent to:

             if( $skip_if_true ) {
               ok(1);
             } else {
               ok( args... );
             }

           ...except that the ok(1) emits not just ""ok testnum"" but actually ""ok testnum # skip_if_true_value"".

           The arguments after the skip_if_true are what is fed to "ok(...)" if this test isn't skipped.

           Example usage:

             my $if_MSWin =
               $^O =~ m/MSWin/ ? 'Skip if under MSWin' : '';

             # A test to be skipped if under MSWin (i.e., run except under
             # MSWin)
             skip($if_MSWin, thing($foo), thing($bar) );

           Or, going the other way:

             my $unless_MSWin =
               $^O =~ m/MSWin/ ? '' : 'Skip unless under MSWin';

             # A test to be skipped unless under MSWin (i.e., run only under
             # MSWin)
             skip($unless_MSWin, thing($foo), thing($bar) );

           The tricky thing to remember is that the first parameter is true if you want to skip the test, not run it; and it also doubles as a note about why it's being skipped. So in the first
           codeblock above, read the code as "skip if MSWin -- (otherwise) test whether "thing($foo)" is "thing($bar)"" or for the second case, "skip unless MSWin...".

           Also, when your skip_if_reason string is true, it really should (for backwards compatibility with older Test.pm versions) start with the string "Skip", as shown in the above examples.

           Note that in the above cases, "thing($foo)" and "thing($bar)" are evaluated -- but as long as the "skip_if_true" is true, then we "skip(...)" just tosses out their value (i.e., not bothering
           to treat them like values to "ok(...)".  But if you need to not eval the arguments when skipping the test, use this format:

             skip( $unless_MSWin,
               sub {
                 # This code returns true if the test passes.
                 # (But it doesn't even get called if the test is skipped.)
                 thing($foo) eq thing($bar)
               }
             );

           or even this, which is basically equivalent:

             skip( $unless_MSWin,
               sub { thing($foo) }, sub { thing($bar) }
             );

           That is, both are like this:

             if( $unless_MSWin ) {
               ok(1);  # but it actually appends "# $unless_MSWin"
                       #  so that Test::Harness can tell it's a skip
             } else {
               # Not skipping, so actually call and evaluate...
               ok( sub { thing($foo) }, sub { thing($bar) } );
             }

TEST TYPES
       •   NORMAL TESTS

           These tests are expected to succeed.  Usually, most or all of your tests are in this category.  If a normal test doesn't succeed, then that means that something is wrong.

       •   SKIPPED TESTS

           The "skip(...)" function is for tests that might or might not be possible to run, depending on the availability of platform-specific features.  The first argument should evaluate to true
           (think "yes, please skip") if the required feature is not available.  After the first argument, "skip(...)" works exactly the same way as "ok(...)" does.

       •   TODO TESTS

           TODO tests are designed for maintaining an executable TODO list.  These tests are expected to fail.  If a TODO test does succeed, then the feature in question shouldn't be on the TODO list,
           now should it?

           Packages should NOT be released with succeeding TODO tests.  As soon as a TODO test starts working, it should be promoted to a normal test, and the newly working feature should be documented
           in the release notes or in the change log.

ONFAIL
         BEGIN { plan test => 4, onfail => sub { warn "CALL 911!" } }

       Although test failures should be enough, extra diagnostics can be triggered at the end of a test run.  "onfail" is passed an array ref of hash refs that describe each test failure.  Each hash
       will contain at least the following fields: "package", "repetition", and "result".  (You shouldn't rely on any other fields being present.)  If the test had an expected value or a diagnostic (or
       "note") string, these will also be included.

       The optional "onfail" hook might be used simply to print out the version of your package and/or how to report problems.  It might also be used to generate extremely sophisticated diagnostics for
       a particularly bizarre test failure.  However it's not a panacea.  Core dumps or other unrecoverable errors prevent the "onfail" hook from running.  (It is run inside an "END" block.)  Besides,
       "onfail" is probably over-kill in most cases.  (Your test code should be simpler than the code it is testing, yes?)

BUGS and CAVEATS
       •   "ok(...)"'s special handing of strings which look like they might be regexes can also cause unexpected behavior.  An innocent:

               ok( $fileglob, '/path/to/some/*stuff/' );

           will fail, since Test.pm considers the second argument to be a regex!  The best bet is to use the one-argument form:

               ok( $fileglob eq '/path/to/some/*stuff/' );

       •   "ok(...)"'s use of string "eq" can sometimes cause odd problems when comparing numbers, especially if you're casting a string to a number:

               $foo = "1.0";
               ok( $foo, 1 );      # not ok, "1.0" ne 1

           Your best bet is to use the single argument form:

               ok( $foo == 1 );    # ok "1.0" == 1

       •   As you may have inferred from the above documentation and examples, "ok"'s prototype is "($;$$)" (and, incidentally, "skip"'s is "($;$$$)"). This means, for example, that you can do "ok @foo,
           @bar" to compare the size of the two arrays. But don't be fooled into thinking that "ok @foo, @bar" means a comparison of the contents of two arrays -- you're comparing just the number of
           elements of each. It's so easy to make that mistake in reading "ok @foo, @bar" that you might want to be very explicit about it, and instead write "ok scalar(@foo), scalar(@bar)".

       •   This almost definitely doesn't do what you expect:

                ok $thingy->can('some_method');

           Why?  Because "can" returns a coderef to mean "yes it can (and the method is this...)", and then "ok" sees a coderef and thinks you're passing a function that you want it to call and consider
           the truth of the result of!  I.e., just like:

                ok $thingy->can('some_method')->();

           What you probably want instead is this:

                ok $thingy->can('some_method') && 1;

           If the "can" returns false, then that is passed to "ok".  If it returns true, then the larger expression "$thingy->can('some_method') && 1" returns 1, which "ok" sees as a simple signal of
           success, as you would expect.

       •   The syntax for "skip" is about the only way it can be, but it's still quite confusing.  Just start with the above examples and you'll be okay.

           Moreover, users may expect this:

             skip $unless_mswin, foo($bar), baz($quux);

           to not evaluate "foo($bar)" and "baz($quux)" when the test is being skipped.  But in reality, they are evaluated, but "skip" just won't bother comparing them if $unless_mswin is true.

           You could do this:

             skip $unless_mswin, sub{foo($bar)}, sub{baz($quux)};

           But that's not terribly pretty.  You may find it simpler or clearer in the long run to just do things like this:

             if( $^O =~ m/MSWin/ ) {
               print "# Yay, we're under $^O\n";
               ok foo($bar), baz($quux);
               ok thing($whatever), baz($stuff);
               ok blorp($quux, $whatever);
               ok foo($barzbarz), thang($quux);
             } else {
               print "# Feh, we're under $^O.  Watch me skip some tests...\n";
               for(1 .. 4) { skip "Skip unless under MSWin" }
             }

           But be quite sure that "ok" is called exactly as many times in the first block as "skip" is called in the second block.

ENVIRONMENT
       If "PERL_TEST_DIFF" environment variable is set, it will be used as a command for comparing unexpected multiline results.  If you have GNU diff installed, you might want to set "PERL_TEST_DIFF"
       to "diff -u".  If you don't have a suitable program, you might install the "Text::Diff" module and then set "PERL_TEST_DIFF" to be "perl -MText::Diff -e 'print diff(@ARGV)'".  If "PERL_TEST_DIFF"
       isn't set but the "Algorithm::Diff" module is available, then it will be used to show the differences in multiline results.

NOTE
       A past developer of this module once said that it was no longer being actively developed.  However, rumors of its demise were greatly exaggerated.  Feedback and suggestions are quite welcome.

       Be aware that the main value of this module is its simplicity.  Note that there are already more ambitious modules out there, such as Test::More and Test::Unit.

       Some earlier versions of this module had docs with some confusing typos in the description of "skip(...)".

SEE ALSO
       Test::Harness

       Test::Simple, Test::More, Devel::Cover

       Test::Builder for building your own testing library.

       Test::Unit is an interesting XUnit-style testing library.

       Test::Inline lets you embed tests in code.

AUTHOR
       Copyright (c) 1998-2000 Joshua Nathaniel Pritikin.

       Copyright (c) 2001-2002 Michael G. Schwern.

       Copyright (c) 2002-2004 Sean M. Burke.

       Current maintainer: Jesse Vincent. <jesse@bestpractical.com>

       This package is free software and is provided "as is" without express or implied warranty.  It may be used, redistributed and/or modified under the same terms as Perl itself.

perl v5.36.0                                                                                    2022-12-12                                                                                     Test(3perl)
