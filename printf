PRINTF(1)                        User Commands                       PRINTF(1)

NAME
       printf - format and print data

SYNOPSIS
       printf FORMAT [ARGUMENT]...
       printf OPTION

DESCRIPTION
       Print ARGUMENT(s) according to FORMAT, or execute according to OPTION:

       --help display this help and exit

       --version
              output version information and exit

       FORMAT controls the output as in C printf.  Interpreted sequences are:

       \"     double quote

       \\     backslash

       \a     alert (BEL)

       \b     backspace

       \c     produce no further output

       \e     escape

       \f     form feed

       \n     new line

       \r     carriage return

       \t     horizontal tab

       \v     vertical tab

       \NNN   byte with octal value NNN (1 to 3 digits)

       \xHH   byte with hexadecimal value HH (1 to 2 digits)

       \uHHHH Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)

       \UHHHHHHHH
              Unicode character with hex value HHHHHHHH (8 digits)

       %%     a single %

       %b     ARGUMENT  as  a string with '\' escapes interpreted, except that
              octal escapes are of the form \0 or \0NNN

       %q     ARGUMENT is printed in a format that can be reused as shell  in‐
              put,  escaping  non-printable characters with the proposed POSIX
              $'' syntax.

       and all C format specifications ending with one of diouxXfeEgGcs,  with
       ARGUMENTs converted to proper type first.  Variable widths are handled.

       NOTE:  your shell may have its own version of printf, which usually su‐
       persedes the version described here.  Please refer to your shell's doc‐
       umentation for details about the options it supports.

AUTHOR
       Written by David MacKenzie.

REPORTING BUGS
       GNU coreutils online help: <https://www.gnu.org/software/coreutils/>
       Report any translation bugs to <https://translationproject.org/team/>

COPYRIGHT
       Copyright  ©  2023  Free Software Foundation, Inc.  License GPLv3+: GNU
       GPL version 3 or later <https://gnu.org/licenses/gpl.html>.
       This is free software: you are free  to  change  and  redistribute  it.
       There is NO WARRANTY, to the extent permitted by law.

SEE ALSO
       printf(3)

       Full documentation <https://www.gnu.org/software/coreutils/printf>
       or available locally via: info '(coreutils) printf invocation'

GNU coreutils 9.2                 April 2023                         PRINTF(1)
PRINTF(1P)                 POSIX Programmer's Manual                PRINTF(1P)

PROLOG
       This  manual  page is part of the POSIX Programmer's Manual.  The Linux
       implementation of this interface may differ (consult the  corresponding
       Linux  manual page for details of Linux behavior), or the interface may
       not be implemented on Linux.

NAME
       printf — write formatted output

SYNOPSIS
       printf format [argument...]

DESCRIPTION
       The printf utility shall write formatted operands to the standard  out‐
       put. The argument operands shall be formatted under control of the for‐
       mat operand.

OPTIONS
       None.

OPERANDS
       The following operands shall be supported:

       format    A string describing the format to use to write the  remaining
                 operands.  See the EXTENDED DESCRIPTION section.

       argument  The  strings to be written to standard output, under the con‐
                 trol of format.  See the EXTENDED DESCRIPTION section.

STDIN
       Not used.

INPUT FILES
       None.

ENVIRONMENT VARIABLES
       The following environment  variables  shall  affect  the  execution  of
       printf:

       LANG      Provide  a  default  value for the internationalization vari‐
                 ables that are unset or null. (See the Base Definitions  vol‐
                 ume  of POSIX.1‐2017, Section 8.2, Internationalization Vari‐
                 ables the precedence of internationalization  variables  used
                 to determine the values of locale categories.)

       LC_ALL    If  set  to  a non-empty string value, override the values of
                 all the other internationalization variables.

       LC_CTYPE  Determine the locale for the interpretation of  sequences  of
                 bytes of text data as characters (for example, single-byte as
                 opposed to multi-byte characters in arguments).

       LC_MESSAGES
                 Determine the locale that should be used to affect the format
                 and  contents  of diagnostic messages written to standard er‐
                 ror.

       LC_NUMERIC
                 Determine the locale for numeric formatting. It shall  affect
                 the  format  of  numbers  written using the e, E, f, g, and G
                 conversion specifier characters (if supported).

       NLSPATH   Determine the location of message catalogs for the processing
                 of LC_MESSAGES.

ASYNCHRONOUS EVENTS
       Default.

STDOUT
       See the EXTENDED DESCRIPTION section.

STDERR
       The standard error shall be used only for diagnostic messages.

OUTPUT FILES
       None.

EXTENDED DESCRIPTION
       The  format operand shall be used as the format string described in the
       Base Definitions volume of POSIX.1‐2017, Chapter 5, File  Format  Nota‐
       tion with the following exceptions:

        1. A <space> in the format string, in any context other than a flag of
           a conversion specification, shall be treated as an ordinary charac‐
           ter that is copied to the output.

        2. A  '' character in the format string shall be treated as a '' char‐
           acter, not as a <space>.

        3. In addition to the escape sequences shown in the  Base  Definitions
           volume  of  POSIX.1‐2017,  Chapter  5,  File Format Notation ('\\',
           '\a', '\b', '\f', '\n', '\r', '\t', '\v'), "\ddd", where ddd  is  a
           one,  two,  or three-digit octal number, shall be written as a byte
           with the numeric value specified by the octal number.

        4. The implementation shall not precede or follow output from the d or
           u  conversion  specifiers  with <blank> characters not specified by
           the format operand.

        5. The implementation shall not precede output from the  o  conversion
           specifier with zeros not specified by the format operand.

        6. The  a,  A,  e, E, f, F, g, and G conversion specifiers need not be
           supported.

        7. An additional conversion specifier character, b, shall be supported
           as  follows.  The  argument  shall be taken to be a string that can
           contain <backslash>-escape sequences. The following <backslash>-es‐
           cape sequences shall be supported:

           --  The  escape  sequences listed in the Base Definitions volume of
               POSIX.1‐2017, Chapter 5,  File  Format  Notation  ('\\',  '\a',
               '\b',  '\f',  '\n', '\r', '\t', '\v'), which shall be converted
               to the characters they represent

           --  "\0ddd", where ddd is a zero, one, two,  or  three-digit  octal
               number that shall be converted to a byte with the numeric value
               specified by the octal number

           --  '\c', which shall not be written and shall cause printf to  ig‐
               nore  any remaining characters in the string operand containing
               it, any remaining string operands, and any  additional  charac‐
               ters in the format operand

           The  interpretation of a <backslash> followed by any other sequence
           of characters is unspecified.

           Bytes from the converted string shall be written until the  end  of
           the string or the number of bytes indicated by the precision speci‐
           fication is reached. If the precision is omitted, it shall be taken
           to  be infinite, so all bytes up to the end of the converted string
           shall be written.

        8. For each conversion specification that consumes  an  argument,  the
           next  argument  operand shall be evaluated and converted to the ap‐
           propriate type for the conversion as specified below.

        9. The format operand shall be reused as often as necessary to satisfy
           the  argument  operands. Any extra b, c, or s conversion specifiers
           shall be evaluated as if a  null  string  argument  were  supplied;
           other  extra  conversion  specifications shall be evaluated as if a
           zero argument were supplied. If the format operand contains no con‐
           version  specifications  and argument operands are present, the re‐
           sults are unspecified.

       10. If a character sequence in the format operand  begins  with  a  '%'
           character,  but does not form a valid conversion specification, the
           behavior is unspecified.

       11. The argument to the c conversion specifier can be a string contain‐
           ing zero or more bytes. If it contains one or more bytes, the first
           byte shall be written and any additional bytes shall be ignored. If
           the  argument is an empty string, it is unspecified whether nothing
           is written or a null byte is written.

       The argument operands shall be treated as strings if the  corresponding
       conversion specifier is b, c, or s, and shall be evaluated as if by the
       strtod() function if the corresponding conversion specifier is a, A, e,
       E,  f,  F, g, or G.  Otherwise, they shall be evaluated as unsuffixed C
       integer constants, as described by the ISO C standard, with the follow‐
       ing extensions:

        *  A leading <plus-sign> or <hyphen-minus> shall be allowed.

        *  If  the  leading  character  is a single-quote or double-quote, the
           value shall be the numeric value in the underlying codeset  of  the
           character following the single-quote or double-quote.

        *  Suffixed integer constants may be allowed.

       If  an argument operand cannot be completely converted into an internal
       value appropriate to the corresponding conversion specification, a  di‐
       agnostic  message  shall  be  written to standard error and the utility
       shall not exit with a zero exit status, but shall  continue  processing
       any  remaining  operands  and  shall write the value accumulated at the
       time the error was detected to standard output.

       It shall not be considered an error if an argument operand is not  com‐
       pletely used for a b, c, or s conversion.

EXIT STATUS
       The following exit values shall be returned:

        0    Successful completion.

       >0    An error occurred.

CONSEQUENCES OF ERRORS
       Default.

       The following sections are informative.

APPLICATION USAGE
       The floating-point formatting conversion specifications of printf() are
       not required because all arithmetic in the shell is integer arithmetic.
       The  awk  utility performs floating-point calculations and provides its
       own printf function. The bc  utility  can  perform  arbitrary-precision
       floating-point  arithmetic,  but  does not provide extensive formatting
       capabilities. (This printf utility cannot really be used to  format  bc
       output;  it  does not support arbitrary precision.) Implementations are
       encouraged to support the floating-point conversions as an extension.

       Note that this printf utility, like the printf()  function  defined  in
       the  System  Interfaces  volume  of  POSIX.1‐2017 on which it is based,
       makes no special provision for dealing with multi-byte characters  when
       using  the %c conversion specification or when a precision is specified
       in a %b or %s conversion  specification.  Applications  should  be  ex‐
       tremely  cautious  using either of these features when there are multi-
       byte characters in the character set.

       No provision is made in this volume of POSIX.1‐2017 which allows  field
       widths  and  precisions to be specified as '*' since the '*' can be re‐
       placed directly in the format operand using  shell  variable  substitu‐
       tion.  Implementations can also provide this feature as an extension if
       they so choose.

       Hexadecimal character constants as defined in the  ISO C  standard  are
       not recognized in the format operand because there is no consistent way
       to detect the end of the constant. Octal character constants  are  lim‐
       ited  to,  at  most, three octal digits, but hexadecimal character con‐
       stants are only terminated by a non-hex-digit character. In  the  ISO C
       standard,  the  "##"  concatenation operator can be used to terminate a
       constant and follow it with a hexadecimal character to be  written.  In
       the  shell, concatenation occurs before the printf utility has a chance
       to parse the end of the hexadecimal constant.

       The %b conversion specification is not part of the ISO C  standard;  it
       has  been  added  here as a portable way to process <backslash>-escapes
       expanded in string operands as provided by the echo utility.  See  also
       the  APPLICATION  USAGE section of echo for ways to use printf as a re‐
       placement for all of the traditional versions of the echo utility.

       If an argument cannot be parsed correctly for the corresponding conver‐
       sion  specification, the printf utility is required to report an error.
       Thus, overflow and extraneous characters at the end of an argument  be‐
       ing used for a numeric conversion shall be reported as errors.

EXAMPLES
       To alert the user and then print and read a series of prompts:

           printf "\aPlease fill in the following: \nName: "
           read name
           printf "Phone number: "
           read phone

       To  read  out  a list of right and wrong answers from a file, calculate
       the percentage correctly, and print them out. The  numbers  are  right-
       justified  and  separated by a single <tab>.  The percentage is written
       to one decimal place of accuracy:

           while read right wrong ; do
               percent=$(echo "scale=1;($right*100)/($right+$wrong)" | bc)
               printf "%2d right\t%2d wrong\t(%s%%)\n" \
                   $right $wrong $percent
           done < database_file

       The command:

           printf "%5d%4d\n" 1 21 321 4321 54321

       produces:

               1  21
             3214321
           54321   0

       Note that the format operand is used three times to print  all  of  the
       given strings and that a '0' was supplied by printf to satisfy the last
       %4d conversion specification.

       The printf utility is required to notify the user when  conversion  er‐
       rors  are  detected while producing numeric output; thus, the following
       results would be expected on an implementation with 32-bit twos-comple‐
       ment integers when %d is specified as the format operand:

       ┌────────────┬─────────────┬───────────────────────────────────────────┐
       │            │  Standard   │                                           │
       │ Argument   │   Output    │             Diagnostic Output             │
       ├────────────┼─────────────┼───────────────────────────────────────────┤
       │5a          │ 5           │ printf: "5a" not completely converted     │
       │9999999999  │ 2147483647  │ printf: "9999999999" arithmetic overflow  │
       │-9999999999 │ -2147483648 │ printf: "-9999999999" arithmetic overflow │
       │ABC         │ 0           │ printf: "ABC" expected numeric value      │
       └────────────┴─────────────┴───────────────────────────────────────────┘
       The diagnostic message format is not specified, but these examples con‐
       vey the type of information that should  be  reported.  Note  that  the
       value  shown on standard output is what would be expected as the return
       value from the strtol() function as defined in  the  System  Interfaces
       volume  of POSIX.1‐2017. A similar correspondence exists between %u and
       strtoul() and %e, %f, and %g (if the implementation supports  floating-
       point conversions) and strtod().

       In a locale using the ISO/IEC 646:1991 standard as the underlying code‐
       set, the command:

           printf "%d\n" 3 +3 -3 \'3 \"+3 "'-3"

       produces:

       3     Numeric value of constant 3

       3     Numeric value of constant 3

       -3    Numeric value of constant -3

       51    Numeric value of the character '3' in the ISO/IEC 646:1991  stan‐
             dard codeset

       43    Numeric  value of the character '+' in the ISO/IEC 646:1991 stan‐
             dard codeset

       45    Numeric value of the character '-' in the ISO/IEC 646:1991  stan‐
             dard codeset

       Note  that in a locale with multi-byte characters, the value of a char‐
       acter is intended to be the value of the equivalent of the wchar_t rep‐
       resentation of the character as described in the System Interfaces vol‐
       ume of POSIX.1‐2017.

RATIONALE
       The printf utility was added to provide functionality that has histori‐
       cally  been  provided  by echo.  However, due to irreconcilable differ‐
       ences in the various versions of echo extant, the version has few  spe‐
       cial features, leaving those to this new printf utility, which is based
       on one in the Ninth Edition system.

       The EXTENDED DESCRIPTION section almost exactly  matches  the  printf()
       function  in  the  ISO C standard, although it is described in terms of
       the  file  format  notation  in  the   Base   Definitions   volume   of
       POSIX.1‐2017, Chapter 5, File Format Notation.

       Earlier versions of this standard specified that arguments for all con‐
       versions other than b, c, and s were evaluated in the same  way  (as  C
       constants,  but with stated exceptions). For implementations supporting
       the floating-point conversions it was not clear whether integer conver‐
       sions need only accept integer constants and floating-point conversions
       need only accept floating-point constants, or  whether  both  types  of
       conversions  should accept both types of constants. Also by not distin‐
       guishing between them, the requirement relating to  a  leading  single-
       quote or double-quote applied to floating-point conversions even though
       this provided no useful functionality to applications that was not  al‐
       ready  available  through the integer conversions. The current standard
       clarifies the situation by specifying that the arguments for  floating-
       point  conversions  are  evaluated as if by strtod(), and the arguments
       for integer conversions are evaluated as C integer constants, with  the
       special  treatment  of  leading  single-quote and double-quote applying
       only to integer conversions.

FUTURE DIRECTIONS
       None.

SEE ALSO
       awk, bc, echo

       The Base Definitions volume of POSIX.1‐2017, Chapter 5, File Format No‐
       tation, Chapter 8, Environment Variables

       The System Interfaces volume of POSIX.1‐2017, fprintf(), strtod()

COPYRIGHT
       Portions  of  this text are reprinted and reproduced in electronic form
       from IEEE Std 1003.1-2017, Standard for Information Technology --  Por‐
       table  Operating System Interface (POSIX), The Open Group Base Specifi‐
       cations Issue 7, 2018 Edition, Copyright (C) 2018 by the  Institute  of
       Electrical  and  Electronics Engineers, Inc and The Open Group.  In the
       event of any discrepancy between this version and the original IEEE and
       The  Open Group Standard, the original IEEE and The Open Group Standard
       is the referee document. The original Standard can be  obtained  online
       at http://www.opengroup.org/unix/online.html .

       Any  typographical  or  formatting  errors that appear in this page are
       most likely to have been introduced during the conversion of the source
       files  to  man page format. To report such errors, see https://www.ker‐
       nel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                  2017                           PRINTF(1P)
printf(3)                  Library Functions Manual                  printf(3)

NAME
       printf,  fprintf,  dprintf,  sprintf,  snprintf, vprintf, vfprintf, vd‐
       printf, vsprintf, vsnprintf - formatted output conversion

LIBRARY
       Standard C library (libc, -lc)

SYNOPSIS
       #include <stdio.h>

       int printf(const char *restrict format, ...);
       int fprintf(FILE *restrict stream,
                   const char *restrict format, ...);
       int dprintf(int fd,
                   const char *restrict format, ...);
       int sprintf(char *restrict str,
                   const char *restrict format, ...);
       int snprintf(char str[restrict .size], size_t size,
                   const char *restrict format, ...);

       int vprintf(const char *restrict format, va_list ap);
       int vfprintf(FILE *restrict stream,
                   const char *restrict format, va_list ap);
       int vdprintf(int fd,
                   const char *restrict format, va_list ap);
       int vsprintf(char *restrict str,
                   const char *restrict format, va_list ap);
       int vsnprintf(char str[restrict .size], size_t size,
                   const char *restrict format, va_list ap);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       snprintf(), vsnprintf():
           _XOPEN_SOURCE >= 500 || _ISOC99_SOURCE
               || /* glibc <= 2.19: */ _BSD_SOURCE

       dprintf(), vdprintf():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _GNU_SOURCE

DESCRIPTION
       The functions in the printf() family produce output according to a for‐
       mat  as  described  below.   The functions printf() and vprintf() write
       output to stdout, the standard output stream; fprintf() and  vfprintf()
       write  output  to  the  given  output  stream;  sprintf(),  snprintf(),
       vsprintf(), and vsnprintf() write to the character string str.

       The function dprintf() is the same as fprintf() except that it  outputs
       to a file descriptor, fd, instead of to a stdio(3) stream.

       The  functions snprintf() and vsnprintf() write at most size bytes (in‐
       cluding the terminating null byte ('\0')) to str.

       The  functions  vprintf(),  vfprintf(),  vdprintf(),  vsprintf(),   vs‐
       nprintf()   are   equivalent  to  the  functions  printf(),  fprintf(),
       dprintf(), sprintf(), snprintf(), respectively, except  that  they  are
       called with a va_list instead of a variable number of arguments.  These
       functions do not call the va_end macro.  Because they invoke the va_arg
       macro, the value of ap is undefined after the call.  See stdarg(3).

       All  of  these functions write the output under the control of a format
       string that specifies how subsequent arguments (or  arguments  accessed
       via the variable-length argument facilities of stdarg(3)) are converted
       for output.

       C99 and POSIX.1-2001 specify that the results are undefined if  a  call
       to  sprintf(), snprintf(), vsprintf(), or vsnprintf() would cause copy‐
       ing to take place between objects that overlap  (e.g.,  if  the  target
       string  array and one of the supplied input arguments refer to the same
       buffer).  See NOTES.

   Format of the format string
       The format string is a character string, beginning and  ending  in  its
       initial  shift state, if any.  The format string is composed of zero or
       more directives: ordinary characters (not  %),  which  are  copied  un‐
       changed  to  the  output stream; and conversion specifications, each of
       which results in fetching zero or more subsequent arguments.  Each con‐
       version specification is introduced by the character %, and ends with a
       conversion specifier.  In between there may be (in this order) zero  or
       more  flags, an optional minimum field width, an optional precision and
       an optional length modifier.

       The overall syntax of a conversion specification is:

           %[$][flags][width][.precision][length modifier]conversion

       The arguments must correspond properly (after type promotion) with  the
       conversion  specifier.  By default, the arguments are used in the order
       given, where each '*' (see Field width and Precision  below)  and  each
       conversion  specifier asks for the next argument (and it is an error if
       insufficiently many arguments are given).  One can also specify explic‐
       itly  which  argument  is taken, at each place where an argument is re‐
       quired, by writing "%m$" instead of '%' and "*m$" instead of '*', where
       the  decimal integer m denotes the position in the argument list of the
       desired argument, indexed starting from 1.  Thus,

           printf("%*d", width, num);

       and

           printf("%2$*1$d", width, num);

       are equivalent.  The second style allows  repeated  references  to  the
       same  argument.  The C99 standard does not include the style using '$',
       which comes from the Single UNIX Specification.  If the style using '$'
       is used, it must be used throughout for all conversions taking an argu‐
       ment and all width and precision arguments, but it may  be  mixed  with
       "%%"  formats,  which do not consume an argument.  There may be no gaps
       in the numbers of arguments specified using '$'; for example, if  argu‐
       ments  1  and  3 are specified, argument 2 must also be specified some‐
       where in the format string.

       For some numeric conversions a radix  character  ("decimal  point")  or
       thousands'  grouping  character is used.  The actual character used de‐
       pends on the LC_NUMERIC part of the locale.  (See  setlocale(3).)   The
       POSIX  locale uses '.' as radix character, and does not have a grouping
       character.  Thus,

           printf("%'.2f", 1234567.89);

       results in "1234567.89" in the POSIX locale,  in  "1234567,89"  in  the
       nl_NL locale, and in "1.234.567,89" in the da_DK locale.

   Flag characters
       The character % is followed by zero or more of the following flags:

       #      The  value  should  be  converted to an "alternate form".  For o
              conversions, the first character of the output  string  is  made
              zero (by prefixing a 0 if it was not zero already).  For x and X
              conversions, a nonzero result has the string "0x" (or "0X" for X
              conversions)  prepended  to  it.  For a, A, e, E, f, F, g, and G
              conversions, the result will always  contain  a  decimal  point,
              even  if  no digits follow it (normally, a decimal point appears
              in the results of those conversions only if  a  digit  follows).
              For g and G conversions, trailing zeros are not removed from the
              result as they would otherwise be.  For m, if errno  contains  a
              valid  error  code,  the  output  of  strerrorname_np(errno)  is
              printed; otherwise, the value stored in errno is  printed  as  a
              decimal number.  For other conversions, the result is undefined.

       0      The value should be zero padded.  For d, i, o, u, x, X, a, A, e,
              E, f, F, g, and G conversions, the converted value is padded  on
              the  left  with  zeros rather than blanks.  If the 0 and - flags
              both appear, the 0 flag is ignored.  If  a  precision  is  given
              with an integer conversion (d, i, o, u, x, and X), the 0 flag is
              ignored.  For other conversions, the behavior is undefined.

       -      The converted value is to be left adjusted on the  field  bound‐
              ary.  (The default is right justification.)  The converted value
              is padded on the right with blanks, rather than on the left with
              blanks or zeros.  A - overrides a 0 if both are given.

       ' '    (a  space)  A  blank should be left before a positive number (or
              empty string) produced by a signed conversion.

       +      A sign (+ or -) should always be placed before a number produced
              by  a  signed  conversion.   By default, a sign is used only for
              negative numbers.  A + overrides a space if both are used.

       The five flag characters above are defined in the  C99  standard.   The
       Single UNIX Specification specifies one further flag character.

       '      For decimal conversion (i, d, u, f, F, g, G) the output is to be
              grouped with thousands' grouping characters if the locale infor‐
              mation  indicates any.  (See setlocale(3).)  Note that many ver‐
              sions of gcc(1) cannot parse this option and will issue a  warn‐
              ing.   (SUSv2  did  not  include %'F, but SUSv3 added it.)  Note
              also that the default locale of a C program is "C" whose  locale
              information  indicates no thousands' grouping character.  There‐
              fore, without a prior call to setlocale(3), no thousands' group‐
              ing characters will be printed.

       glibc 2.2 adds one further flag character.

       I      For decimal integer conversion (i, d, u) the output uses the lo‐
              cale's alternative output digits, if any.   For  example,  since
              glibc  2.2.3  this  will give Arabic-Indic digits in the Persian
              ("fa_IR") locale.

   Field width
       An optional decimal digit string (with nonzero first digit)  specifying
       a  minimum  field  width.   If the converted value has fewer characters
       than the field width, it will be padded with spaces  on  the  left  (or
       right, if the left-adjustment flag has been given).  Instead of a deci‐
       mal digit string one may write "*" or "*m$" (for some  decimal  integer
       m) to specify that the field width is given in the next argument, or in
       the m-th argument, respectively, which must be of type int.  A negative
       field  width is taken as a '-' flag followed by a positive field width.
       In no case does a nonexistent or small field width cause truncation  of
       a  field;  if the result of a conversion is wider than the field width,
       the field is expanded to contain the conversion result.

   Precision
       An optional precision, in the form of a period ('.')   followed  by  an
       optional  decimal  digit string.  Instead of a decimal digit string one
       may write "*" or "*m$" (for some decimal integer m) to specify that the
       precision  is  given in the next argument, or in the m-th argument, re‐
       spectively, which must be of type int.  If the precision  is  given  as
       just  '.',  the precision is taken to be zero.  A negative precision is
       taken as if the precision were omitted.  This gives the minimum  number
       of digits to appear for d, i, o, u, x, and X conversions, the number of
       digits to appear after the radix character for a, A, e,  E,  f,  and  F
       conversions,  the maximum number of significant digits for g and G con‐
       versions, or the maximum number of characters  to  be  printed  from  a
       string for s and S conversions.

   Length modifier
       Here, "integer conversion" stands for d, i, o, u, x, or X conversion.

       hh     A  following  integer conversion corresponds to a signed char or
              unsigned char argument, or a following n conversion  corresponds
              to a pointer to a signed char argument.

       h      A  following  integer  conversion  corresponds to a short or un‐
              signed short argument, or a following n  conversion  corresponds
              to a pointer to a short argument.

       l      (ell)  A  following  integer conversion corresponds to a long or
              unsigned long argument, or a following n conversion  corresponds
              to  a  pointer  to  a long argument, or a following c conversion
              corresponds to a wint_t argument, or a  following  s  conversion
              corresponds to a pointer to wchar_t argument.  On a following a,
              A, e, E, f, F, g, or G conversion, this length modifier  is  ig‐
              nored (C99; not in SUSv2).

       ll     (ell-ell).  A following integer conversion corresponds to a long
              long or unsigned long long argument, or a following n conversion
              corresponds to a pointer to a long long argument.

       q      A synonym for ll.  This is a nonstandard extension, derived from
              BSD; avoid its use in new code.

       L      A following a, A, e, E, f, F, g, or G conversion corresponds  to
              a long double argument.  (C99 allows %LF, but SUSv2 does not.)

       j      A  following  integer  conversion  corresponds to an intmax_t or
              uintmax_t argument, or a following n conversion corresponds to a
              pointer to an intmax_t argument.

       z      A  following  integer  conversion  corresponds  to  a  size_t or
              ssize_t argument, or a following n conversion corresponds  to  a
              pointer to a size_t argument.

       Z      A  nonstandard  synonym for z that predates the appearance of z.
              Do not use in new code.

       t      A following integer conversion corresponds to a ptrdiff_t  argu‐
              ment,  or a following n conversion corresponds to a pointer to a
              ptrdiff_t argument.

       SUSv3 specifies all of the above, except for those modifiers explicitly
       noted as being nonstandard extensions.  SUSv2 specified only the length
       modifiers h (in hd, hi, ho, hx, hX, hn) and l (in ld, li, lo,  lx,  lX,
       ln, lc, ls) and L (in Le, LE, Lf, Lg, LG).

       As  a nonstandard extension, the GNU implementations treats ll and L as
       synonyms, so that one can, for example, write llg (as a synonym for the
       standards-compliant  Lg) and Ld (as a synonym for the standards compli‐
       ant lld).  Such usage is nonportable.

   Conversion specifiers
       A character that specifies the type of conversion to be  applied.   The
       conversion specifiers and their meanings are:

       d, i   The  int  argument is converted to signed decimal notation.  The
              precision, if any, gives the minimum number of digits that  must
              appear;  if  the  converted  value  requires fewer digits, it is
              padded on the left with zeros.   The  default  precision  is  1.
              When  0  is  printed with an explicit precision 0, the output is
              empty.

       o, u, x, X
              The unsigned int argument is converted to  unsigned  octal  (o),
              unsigned  decimal  (u),  or unsigned hexadecimal (x and X) nota‐
              tion.  The letters abcdef are used for x conversions;  the  let‐
              ters  ABCDEF are used for X conversions.  The precision, if any,
              gives the minimum number of digits that must appear; if the con‐
              verted  value  requires  fewer  digits, it is padded on the left
              with zeros.  The default precision is 1.  When 0 is printed with
              an explicit precision 0, the output is empty.

       e, E   The  double  argument  is  rounded  and  converted  in the style
              [-]d.ddde±dd where there is one digit (which is nonzero  if  the
              argument  is nonzero) before the decimal-point character and the
              number of digits after it is equal to the precision; if the pre‐
              cision  is  missing, it is taken as 6; if the precision is zero,
              no decimal-point character appears.  An E  conversion  uses  the
              letter  E  (rather than e) to introduce the exponent.  The expo‐
              nent always contains at least two digits; if the value is  zero,
              the exponent is 00.

       f, F   The double argument is rounded and converted to decimal notation
              in the style [-]ddd.ddd, where the number of  digits  after  the
              decimal-point character is equal to the precision specification.
              If the precision is missing, it is taken as 6; if the  precision
              is  explicitly  zero,  no decimal-point character appears.  If a
              decimal point appears, at least one digit appears before it.

              (SUSv2 does not know about F and says that character string rep‐
              resentations  for infinity and NaN may be made available.  SUSv3
              adds a specification for F.  The C99 standard specifies "[-]inf"
              or  "[-]infinity" for infinity, and a string starting with "nan"
              for NaN, in the case of f conversion, and "[-]INF" or "[-]INFIN‐
              ITY" or "NAN" in the case of F conversion.)

       g, G   The  double argument is converted in style f or e (or F or E for
              G conversions).  The precision specifies the number of  signifi‐
              cant  digits.   If the precision is missing, 6 digits are given;
              if the precision is zero, it is treated as 1.  Style e  is  used
              if  the  exponent from its conversion is less than -4 or greater
              than or equal to the precision.  Trailing zeros are removed from
              the  fractional part of the result; a decimal point appears only
              if it is followed by at least one digit.

       a, A   (C99; not in SUSv2, but added in SUSv3) For  a  conversion,  the
              double  argument is converted to hexadecimal notation (using the
              letters abcdef) in the style [-]0xh.hhhhp±d;  for  A  conversion
              the  prefix 0X, the letters ABCDEF, and the exponent separator P
              is used.  There is one  hexadecimal  digit  before  the  decimal
              point,  and the number of digits after it is equal to the preci‐
              sion.  The default precision suffices for an  exact  representa‐
              tion  of  the  value if an exact representation in base 2 exists
              and otherwise is sufficiently large  to  distinguish  values  of
              type  double.  The digit before the decimal point is unspecified
              for nonnormalized numbers, and nonzero but otherwise unspecified
              for  normalized  numbers.  The exponent always contains at least
              one digit; if the value is zero, the exponent is 0.

       c      If no l modifier is present, the int argument is converted to an
              unsigned  char, and the resulting character is written.  If an l
              modifier is present, the wint_t  (wide  character)  argument  is
              converted  to  a  multibyte sequence by a call to the wcrtomb(3)
              function, with a conversion state starting in the initial state,
              and the resulting multibyte string is written.

       s      If  no  l  modifier is present: the const char * argument is ex‐
              pected to be a pointer to an array of character type (pointer to
              a string).  Characters from the array are written up to (but not
              including) a terminating null byte ('\0');  if  a  precision  is
              specified,  no more than the number specified are written.  If a
              precision is given, no null byte need be present; if the  preci‐
              sion is not specified, or is greater than the size of the array,
              the array must contain a terminating null byte.

              If an l modifier is present: the const wchar_t * argument is ex‐
              pected  to  be  a  pointer to an array of wide characters.  Wide
              characters from the array are converted to multibyte  characters
              (each  by  a  call to the wcrtomb(3) function, with a conversion
              state starting in the initial state before the first wide  char‐
              acter),  up  to and including a terminating null wide character.
              The resulting multibyte characters are written up  to  (but  not
              including)  the terminating null byte.  If a precision is speci‐
              fied, no more bytes than the number specified are  written,  but
              no partial multibyte characters are written.  Note that the pre‐
              cision determines the number of bytes written, not the number of
              wide  characters  or screen positions.  The array must contain a
              terminating null wide character, unless a precision is given and
              it  is  so small that the number of bytes written exceeds it be‐
              fore the end of the array is reached.

       C      (Not in C99 or C11, but in SUSv2, SUSv3,  and  SUSv4.)   Synonym
              for lc.  Don't use.

       S      (Not  in  C99  or C11, but in SUSv2, SUSv3, and SUSv4.)  Synonym
              for ls.  Don't use.

       p      The void * pointer argument is printed in hexadecimal (as if  by
              %#x or %#lx).

       n      The number of characters written so far is stored into the inte‐
              ger pointed to by the  corresponding  argument.   That  argument
              shall  be  an  int *, or variant whose size matches the (option‐
              ally) supplied integer length modifier.   No  argument  is  con‐
              verted.   (This  specifier  is not supported by the bionic C li‐
              brary.)  The behavior is undefined if the conversion  specifica‐
              tion includes any flags, a field width, or a precision.

       m      (glibc  extension;  supported by uClibc and musl.)  Print output
              of strerror(errno) (or strerrorname_np(errno) in  the  alternate
              form).  No argument is required.

       %      A  '%' is written.  No argument is converted.  The complete con‐
              version specification is '%%'.

RETURN VALUE
       Upon successful return, these functions return the number of characters
       printed (excluding the null byte used to end output to strings).

       The  functions  snprintf()  and vsnprintf() do not write more than size
       bytes (including the terminating null byte ('\0')).  If the output  was
       truncated  due  to  this  limit, then the return value is the number of
       characters (excluding the terminating null byte) which would have  been
       written  to the final string if enough space had been available.  Thus,
       a return value of size or more means that  the  output  was  truncated.
       (See also below under NOTES.)

       If an output error is encountered, a negative value is returned.

ATTRIBUTES
       For  an  explanation  of  the  terms  used  in  this  section,  see at‐
       tributes(7).

       ┌─────────────────────────────────────┬───────────────┬────────────────┐
       │Interface                            │ Attribute     │ Value          │
       ├─────────────────────────────────────┼───────────────┼────────────────┤
       │printf(), fprintf(), sprintf(),      │ Thread safety │ MT-Safe locale │
       │snprintf(), vprintf(), vfprintf(),   │               │                │
       │vsprintf(), vsnprintf()              │               │                │
       └─────────────────────────────────────┴───────────────┴────────────────┘

STANDARDS
       fprintf()
       printf()
       sprintf()
       vprintf()
       vfprintf()
       vsprintf()
       snprintf()
       vsnprintf()
              C11, POSIX.1-2008.

       dprintf()
       vdprintf()
              GNU, POSIX.1-2008.

HISTORY
       fprintf()
       printf()
       sprintf()
       vprintf()
       vfprintf()
       vsprintf()
              C89, POSIX.1-2001.

       snprintf()
       vsnprintf()
              SUSv2, C99, POSIX.1-2001.

              Concerning the return value of snprintf(), SUSv2 and C99 contra‐
              dict  each  other:  when  snprintf()  is called with size=0 then
              SUSv2 stipulates an unspecified return value less than 1,  while
              C99  allows  str  to  be NULL in this case, and gives the return
              value (as always) as the number of characters  that  would  have
              been  written  in  case the output string has been large enough.
              POSIX.1-2001 and later align their specification  of  snprintf()
              with C99.

       dprintf()
       vdprintf()
              GNU, POSIX.1-2008.

       glibc  2.1 adds length modifiers hh, j, t, and z and conversion charac‐
       ters a and A.

       glibc 2.2 adds the conversion character F with C99 semantics,  and  the
       flag character I.

       glibc  2.35  gives a meaning to the alternate form (#) of the m conver‐
       sion specifier, that is %#m.

CAVEATS
       Some programs imprudently rely on code such as the following

           sprintf(buf, "%s some further text", buf);

       to append text to buf.  However, the standards explicitly note that the
       results  are  undefined  if source and destination buffers overlap when
       calling sprintf(), snprintf(), vsprintf(), and vsnprintf().   Depending
       on the version of gcc(1) used, and the compiler options employed, calls
       such as the above will not produce the expected results.

       The glibc implementation of the functions  snprintf()  and  vsnprintf()
       conforms  to  the  C99  standard,  that is, behaves as described above,
       since glibc 2.1.  Until glibc 2.0.6, they would return -1 when the out‐
       put was truncated.

BUGS
       Because  sprintf()  and  vsprintf()  assume an arbitrarily long string,
       callers must be careful not to overflow the actual space; this is often
       impossible  to assure.  Note that the length of the strings produced is
       locale-dependent and difficult to  predict.   Use  snprintf()  and  vs‐
       nprintf() instead (or asprintf(3) and vasprintf(3)).

       Code  such as printf(foo); often indicates a bug, since foo may contain
       a % character.  If foo comes from untrusted user input, it may  contain
       %n,  causing  the printf() call to write to memory and creating a secu‐
       rity hole.

EXAMPLES
       To print Pi to five decimal places:

           #include <math.h>
           #include <stdio.h>
           fprintf(stdout, "pi = %.5f\n", 4 * atan(1.0));

       To print a date and time in the form "Sunday,  July  3,  10:02",  where
       weekday and month are pointers to strings:

           #include <stdio.h>
           fprintf(stdout, "%s, %s %d, %.2d:%.2d\n",
                   weekday, month, day, hour, min);

       Many  countries use the day-month-year order.  Hence, an international‐
       ized version must be able to print the arguments in an order  specified
       by the format:

           #include <stdio.h>
           fprintf(stdout, format,
                   weekday, month, day, hour, min);

       where  format  depends  on locale, and may permute the arguments.  With
       the value:

           "%1$s, %3$d. %2$s, %4$d:%5$.2d\n"

       one might obtain "Sonntag, 3. Juli, 10:02".

       To allocate a sufficiently large string and print into it (code correct
       for both glibc 2.0 and glibc 2.1):

       #include <stdio.h>
       #include <stdlib.h>
       #include <stdarg.h>

       char *
       make_message(const char *fmt, ...)
       {
           int n = 0;
           size_t size = 0;
           char *p = NULL;
           va_list ap;

           /* Determine required size. */

           va_start(ap, fmt);
           n = vsnprintf(p, size, fmt, ap);
           va_end(ap);

           if (n < 0)
               return NULL;

           size = (size_t) n + 1;      /* One extra byte for '\0' */
           p = malloc(size);
           if (p == NULL)
               return NULL;

           va_start(ap, fmt);
           n = vsnprintf(p, size, fmt, ap);
           va_end(ap);

           if (n < 0) {
               free(p);
               return NULL;
           }

           return p;
       }

       If  truncation  occurs  in glibc versions prior to glibc 2.0.6, this is
       treated as an error instead of being handled gracefully.

SEE ALSO
       printf(1), asprintf(3), puts(3), scanf(3),  setlocale(3),  strfromd(3),
       wcrtomb(3), wprintf(3), locale(5)

Linux man-pages 6.04              2023-04-01                         printf(3)
PRINTF(3P)                 POSIX Programmer's Manual                PRINTF(3P)

PROLOG
       This  manual  page is part of the POSIX Programmer's Manual.  The Linux
       implementation of this interface may differ (consult the  corresponding
       Linux  manual page for details of Linux behavior), or the interface may
       not be implemented on Linux.

NAME
       printf — print formatted output

SYNOPSIS
       #include <stdio.h>

       int printf(const char *restrict format, ...);

DESCRIPTION
       Refer to fprintf().

COPYRIGHT
       Portions of this text are reprinted and reproduced in  electronic  form
       from  IEEE Std 1003.1-2017, Standard for Information Technology -- Por‐
       table Operating System Interface (POSIX), The Open Group Base  Specifi‐
       cations  Issue  7, 2018 Edition, Copyright (C) 2018 by the Institute of
       Electrical and Electronics Engineers, Inc and The Open Group.   In  the
       event of any discrepancy between this version and the original IEEE and
       The Open Group Standard, the original IEEE and The Open Group  Standard
       is  the  referee document. The original Standard can be obtained online
       at http://www.opengroup.org/unix/online.html .

       Any typographical or formatting errors that appear  in  this  page  are
       most likely to have been introduced during the conversion of the source
       files to man page format. To report such errors,  see  https://www.ker‐
       nel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                  2017                           PRINTF(3P)
