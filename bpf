bpf(2)                                                                                      System Calls Manual                                                                                     bpf(2)

NAME
       bpf - perform a command on an extended BPF map or program

SYNOPSIS
       #include <linux/bpf.h>

       int bpf(int cmd, union bpf_attr *attr, unsigned int size);

DESCRIPTION
       The  bpf() system call performs a range of operations related to extended Berkeley Packet Filters.  Extended BPF (or eBPF) is similar to the original ("classic") BPF (cBPF) used to filter network
       packets.  For both cBPF and eBPF programs, the kernel statically analyzes the programs before loading them, in order to ensure that they cannot harm the running system.

       eBPF extends cBPF in multiple ways, including the ability to call a fixed set of in-kernel helper functions (via the BPF_CALL opcode extension provided by eBPF) and access shared data  structures
       such as eBPF maps.

   Extended BPF Design/Architecture
       eBPF  maps  are  a  generic data structure for storage of different data types.  Data types are generally treated as binary blobs, so a user just specifies the size of the key and the size of the
       value at map-creation time.  In other words, a key/value for a given map can have an arbitrary structure.

       A user process can create multiple maps (with key/value-pairs being opaque bytes of data) and access them via file descriptors.  Different eBPF programs can access  the  same  maps  in  parallel.
       It's up to the user process and eBPF program to decide what they store inside maps.

       There's one special map type, called a program array.  This type of map stores file descriptors referring to other eBPF programs.  When a lookup in the map is performed, the program flow is redi‐
       rected in-place to the beginning of another eBPF program and does not return back to the calling program.  The level of nesting has a fixed limit of 32, so that infinite loops cannot be  crafted.
       At  run  time, the program file descriptors stored in the map can be modified, so program functionality can be altered based on specific requirements.  All programs referred to in a program-array
       map must have been previously loaded into the kernel via bpf().  If a map lookup fails, the current program continues its execution.  See BPF_MAP_TYPE_PROG_ARRAY below for further details.

       Generally, eBPF programs are loaded by the user process and automatically unloaded when the process exits.  In some cases, for example, tc-bpf(8), the program will continue to stay  alive  inside
       the  kernel even after the process that loaded the program exits.  In that case, the tc subsystem holds a reference to the eBPF program after the file descriptor has been closed by the user-space
       program.  Thus, whether a specific program continues to live inside the kernel depends on how it is further attached to a given kernel subsystem after it was loaded via bpf().

       Each eBPF program is a set of instructions that is safe to run until its completion.  An in-kernel verifier statically determines that the eBPF program terminates and is safe to execute.   During
       verification, the kernel increments reference counts for each of the maps that the eBPF program uses, so that the attached maps can't be removed until the program is unloaded.

       eBPF  programs  can be attached to different events.  These events can be the arrival of network packets, tracing events, classification events by network queueing  disciplines (for eBPF programs
       attached to a tc(8) classifier), and other types that may be added in the future.  A new event triggers execution of the eBPF program, which may store information about the event  in  eBPF  maps.
       Beyond storing data, eBPF programs may call a fixed set of in-kernel helper functions.

       The same eBPF program can be attached to multiple events and different eBPF programs can access the same map:

           tracing     tracing    tracing    packet      packet     packet
           event A     event B    event C    on eth0     on eth1    on eth2
            |             |         |          |           |          ^
            |             |         |          |           v          |
            --> tracing <--     tracing      socket    tc ingress   tc egress
                 prog_1          prog_2      prog_3    classifier    action
                 |  |              |           |         prog_4      prog_5
              |---  -----|  |------|          map_3        |           |
            map_1       map_2                              --| map_4 |--

   Arguments
       The  operation to be performed by the bpf() system call is determined by the cmd argument.  Each operation takes an accompanying argument, provided via attr, which is a pointer to a union of type
       bpf_attr (see below).  The unused fields and padding must be zeroed out before the call.  The size argument is the size of the union pointed to by attr.

       The value provided in cmd is one of the following:

       BPF_MAP_CREATE
              Create a map and return a file descriptor that refers to the map.  The close-on-exec file descriptor flag (see fcntl(2)) is automatically enabled for the new file descriptor.

       BPF_MAP_LOOKUP_ELEM
              Look up an element by key in a specified map and return its value.

       BPF_MAP_UPDATE_ELEM
              Create or update an element (key/value pair) in a specified map.

       BPF_MAP_DELETE_ELEM
              Look up and delete an element by key in a specified map.

       BPF_MAP_GET_NEXT_KEY
              Look up an element by key in a specified map and return the key of the next element.

       BPF_PROG_LOAD
              Verify and load an eBPF program, returning a new file descriptor associated with the program.  The close-on-exec file descriptor flag (see fcntl(2)) is automatically enabled  for  the  new
              file descriptor.

              The bpf_attr union consists of various anonymous structures that are used by different bpf() commands:

           union bpf_attr {
               struct {    /* Used by BPF_MAP_CREATE */
                   __u32         map_type;
                   __u32         key_size;    /* size of key in bytes */
                   __u32         value_size;  /* size of value in bytes */
                   __u32         max_entries; /* maximum number of entries
                                                 in a map */
               };

               struct {    /* Used by BPF_MAP_*_ELEM and BPF_MAP_GET_NEXT_KEY
                              commands */
                   __u32         map_fd;
                   __aligned_u64 key;
                   union {
                       __aligned_u64 value;
                       __aligned_u64 next_key;
                   };
                   __u64         flags;
               };

               struct {    /* Used by BPF_PROG_LOAD */
                   __u32         prog_type;
                   __u32         insn_cnt;
                   __aligned_u64 insns;      /* 'const struct bpf_insn *' */
                   __aligned_u64 license;    /* 'const char *' */
                   __u32         log_level;  /* verbosity level of verifier */
                   __u32         log_size;   /* size of user buffer */
                   __aligned_u64 log_buf;    /* user supplied 'char *'
                                                buffer */
                   __u32         kern_version;
                                             /* checked when prog_type=kprobe
                                                (since Linux 4.1) */
               };
           } __attribute__((aligned(8)));

   eBPF maps
       Maps are a generic data structure for storage of different types of data.  They allow sharing of data between eBPF kernel programs, and also between kernel and user-space applications.

       Each map type has the following attributes:

       •  type

       •  maximum number of elements

       •  key size in bytes

       •  value size in bytes

       The following wrapper functions demonstrate how various bpf() commands can be used to access the maps.  The functions use the cmd argument to invoke different operations.

       BPF_MAP_CREATE
              The BPF_MAP_CREATE command creates a new map, returning a new file descriptor that refers to the map.

                  int
                  bpf_create_map(enum bpf_map_type map_type,
                                 unsigned int key_size,
                                 unsigned int value_size,
                                 unsigned int max_entries)
                  {
                      union bpf_attr attr = {
                          .map_type    = map_type,
                          .key_size    = key_size,
                          .value_size  = value_size,
                          .max_entries = max_entries
                      };

                      return bpf(BPF_MAP_CREATE, &attr, sizeof(attr));
                  }

              The  new  map has the type specified by map_type, and attributes as specified in key_size, value_size, and max_entries.  On success, this operation returns a file descriptor.  On error, -1
              is returned and errno is set to EINVAL, EPERM, or ENOMEM.

              The key_size and value_size attributes will be used by the verifier during program loading to check that the program is calling bpf_map_*_elem() helper functions with a correctly  initial‐
              ized  key  and to check that the program doesn't access the map element value beyond the specified value_size.  For example, when a map is created with a key_size of 8 and the eBPF program
              calls

                  bpf_map_lookup_elem(map_fd, fp - 4)

              the program will be rejected, since the in-kernel helper function

                  bpf_map_lookup_elem(map_fd, void *key)

              expects to read 8 bytes from the location pointed to by key, but the fp - 4 (where fp is the top of the stack) starting address will cause out-of-bounds stack access.

              Similarly, when a map is created with a value_size of 1 and the eBPF program contains

                  value = bpf_map_lookup_elem(...);
                  *(u32 *) value = 1;

              the program will be rejected, since it accesses the value pointer beyond the specified 1 byte value_size limit.

              Currently, the following values are supported for map_type:

                  enum bpf_map_type {
                      BPF_MAP_TYPE_UNSPEC,  /* Reserve 0 as invalid map type */
                      BPF_MAP_TYPE_HASH,
                      BPF_MAP_TYPE_ARRAY,
                      BPF_MAP_TYPE_PROG_ARRAY,
                      BPF_MAP_TYPE_PERF_EVENT_ARRAY,
                      BPF_MAP_TYPE_PERCPU_HASH,
                      BPF_MAP_TYPE_PERCPU_ARRAY,
                      BPF_MAP_TYPE_STACK_TRACE,
                      BPF_MAP_TYPE_CGROUP_ARRAY,
                      BPF_MAP_TYPE_LRU_HASH,
                      BPF_MAP_TYPE_LRU_PERCPU_HASH,
                      BPF_MAP_TYPE_LPM_TRIE,
                      BPF_MAP_TYPE_ARRAY_OF_MAPS,
                      BPF_MAP_TYPE_HASH_OF_MAPS,
                      BPF_MAP_TYPE_DEVMAP,
                      BPF_MAP_TYPE_SOCKMAP,
                      BPF_MAP_TYPE_CPUMAP,
                      BPF_MAP_TYPE_XSKMAP,
                      BPF_MAP_TYPE_SOCKHASH,
                      BPF_MAP_TYPE_CGROUP_STORAGE,
                      BPF_MAP_TYPE_REUSEPORT_SOCKARRAY,
                      BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE,
                      BPF_MAP_TYPE_QUEUE,
                      BPF_MAP_TYPE_STACK,
                      /* See /usr/include/linux/bpf.h for the full list. */
                  };

              map_type selects one of the available map implementations in the kernel.  For all map types, eBPF programs access maps with the same bpf_map_lookup_elem() and bpf_map_update_elem()  helper
              functions.  Further details of the various map types are given below.

       BPF_MAP_LOOKUP_ELEM
              The BPF_MAP_LOOKUP_ELEM command looks up an element with a given key in the map referred to by the file descriptor fd.

                  int
                  bpf_lookup_elem(int fd, const void *key, void *value)
                  {
                      union bpf_attr attr = {
                          .map_fd = fd,
                          .key    = ptr_to_u64(key),
                          .value  = ptr_to_u64(value),
                      };

                      return bpf(BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));
                  }

              If an element is found, the operation returns zero and stores the element's value into value, which must point to a buffer of value_size bytes.

              If no element is found, the operation returns -1 and sets errno to ENOENT.

       BPF_MAP_UPDATE_ELEM
              The BPF_MAP_UPDATE_ELEM command creates or updates an element with a given key/value in the map referred to by the file descriptor fd.

                  int
                  bpf_update_elem(int fd, const void *key, const void *value,
                                  uint64_t flags)
                  {
                      union bpf_attr attr = {
                          .map_fd = fd,
                          .key    = ptr_to_u64(key),
                          .value  = ptr_to_u64(value),
                          .flags  = flags,
                      };

                      return bpf(BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));
                  }

              The flags argument should be specified as one of the following:

              BPF_ANY
                     Create a new element or update an existing element.

              BPF_NOEXIST
                     Create a new element only if it did not exist.

              BPF_EXIST
                     Update an existing element.

              On  success,  the operation returns zero.  On error, -1 is returned and errno is set to EINVAL, EPERM, ENOMEM, or E2BIG.  E2BIG indicates that the number of elements in the map reached the
              max_entries limit specified at map creation time.  EEXIST will be returned if flags specifies BPF_NOEXIST and the element with key already exists in the map.  ENOENT will  be  returned  if
              flags specifies BPF_EXIST and the element with key doesn't exist in the map.

       BPF_MAP_DELETE_ELEM
              The BPF_MAP_DELETE_ELEM command deletes the element whose key is key from the map referred to by the file descriptor fd.

                  int
                  bpf_delete_elem(int fd, const void *key)
                  {
                      union bpf_attr attr = {
                          .map_fd = fd,
                          .key    = ptr_to_u64(key),
                      };

                      return bpf(BPF_MAP_DELETE_ELEM, &attr, sizeof(attr));
                  }

              On success, zero is returned.  If the element is not found, -1 is returned and errno is set to ENOENT.

       BPF_MAP_GET_NEXT_KEY
              The BPF_MAP_GET_NEXT_KEY command looks up an element by key in the map referred to by the file descriptor fd and sets the next_key pointer to the key of the next element.

                  int
                  bpf_get_next_key(int fd, const void *key, void *next_key)
                  {
                      union bpf_attr attr = {
                          .map_fd   = fd,
                          .key      = ptr_to_u64(key),
                          .next_key = ptr_to_u64(next_key),
                      };

                      return bpf(BPF_MAP_GET_NEXT_KEY, &attr, sizeof(attr));
                  }

              If  key is found, the operation returns zero and sets the next_key pointer to the key of the next element.  If key is not found, the operation returns zero and sets the next_key pointer to
              the key of the first element.  If key is the last element, -1 is returned and errno is set to ENOENT.  Other possible errno values are ENOMEM, EFAULT, EPERM, and EINVAL.  This  method  can
              be used to iterate over all elements in the map.

       close(map_fd)
              Delete the map referred to by the file descriptor map_fd.  When the user-space program that created a map exits, all maps will be deleted automatically (but see NOTES).

   eBPF map types
       The following map types are supported:

       BPF_MAP_TYPE_HASH
              Hash-table maps have the following characteristics:

              •  Maps are created and destroyed by user-space programs.  Both user-space and eBPF programs can perform lookup, update, and delete operations.

              •  The kernel takes care of allocating and freeing key/value pairs.

              •  The map_update_elem() helper will fail to insert new element when the max_entries limit is reached.  (This ensures that eBPF programs cannot exhaust memory.)

              •  map_update_elem() replaces existing elements atomically.

              Hash-table maps are optimized for speed of lookup.

       BPF_MAP_TYPE_ARRAY
              Array maps have the following characteristics:

              •  Optimized  for  fastest possible lookup.  In the future the verifier/JIT compiler may recognize lookup() operations that employ a constant key and optimize it into constant pointer.  It
                 is possible to optimize a non-constant key into direct pointer arithmetic as well, since pointers and value_size are constant for the life of the eBPF  program.   In  other  words,  ar‐
                 ray_map_lookup_elem() may be 'inlined' by the verifier/JIT compiler while preserving concurrent access to this map from user space.

              •  All array elements pre-allocated and zero initialized at init time

              •  The key is an array index, and must be exactly four bytes.

              •  map_delete_elem() fails with the error EINVAL, since elements cannot be deleted.

              •  map_update_elem()  replaces  elements  in a nonatomic fashion; for atomic updates, a hash-table map should be used instead.  There is however one special case that can also be used with
                 arrays: the atomic built-in __sync_fetch_and_add() can be used on 32 and 64 bit atomic counters.  For example, it can be applied on the whole value itself  if  it  represents  a  single
                 counter, or in case of a structure containing multiple counters, it could be used on individual counters.  This is quite often useful for aggregation and accounting of events.

              Among the uses for array maps are the following:

              •  As  "global"  eBPF  variables:  an  array of 1 element whose key is (index) 0 and where the value is a collection of 'global' variables which eBPF programs can use to keep state between
                 events.

              •  Aggregation of tracing events into a fixed set of buckets.

              •  Accounting of networking events, for example, number of packets and packet sizes.

       BPF_MAP_TYPE_PROG_ARRAY (since Linux 4.2)
              A program array map is a special kind of array map whose map values contain only file descriptors referring to other eBPF programs.  Thus, both the key_size and value_size must be  exactly
              four bytes.  This map is used in conjunction with the bpf_tail_call() helper.

              This means that an eBPF program with a program array map attached to it can call from kernel side into

                  void bpf_tail_call(void *context, void *prog_map,
                                     unsigned int index);

              and therefore replace its own program flow with the one from the program at the given program array slot, if present.  This can be regarded as kind of a jump table to a different eBPF pro‐
              gram.  The invoked program will then reuse the same stack.  When a jump into the new program has been performed, it won't return to the old program anymore.

              If no eBPF program is found at the given index of the program array (because the map slot doesn't contain a valid program file descriptor, the specified lookup index/key is out of  bounds,
              or the limit of 32 nested calls has been exceed), execution continues with the current eBPF program.  This can be used as a fall-through for default cases.

              A program array map is useful, for example, in tracing or networking, to handle individual system calls or protocols in their own subprograms and use their identifiers as an individual map
              index.  This approach may result in performance benefits, and also makes it possible to overcome the maximum instruction limit of a single eBPF program.  In dynamic environments,  a  user-
              space daemon might atomically replace individual subprograms at run-time with newer versions to alter overall program behavior, for instance, if global policies change.

   eBPF programs
       The BPF_PROG_LOAD command is used to load an eBPF program into the kernel.  The return value for this command is a new file descriptor associated with this eBPF program.

           char bpf_log_buf[LOG_BUF_SIZE];

           int
           bpf_prog_load(enum bpf_prog_type type,
                         const struct bpf_insn *insns, int insn_cnt,
                         const char *license)
           {
               union bpf_attr attr = {
                   .prog_type = type,
                   .insns     = ptr_to_u64(insns),
                   .insn_cnt  = insn_cnt,
                   .license   = ptr_to_u64(license),
                   .log_buf   = ptr_to_u64(bpf_log_buf),
                   .log_size  = LOG_BUF_SIZE,
                   .log_level = 1,
               };

               return bpf(BPF_PROG_LOAD, &attr, sizeof(attr));
           }

       prog_type is one of the available program types:

                  enum bpf_prog_type {
                      BPF_PROG_TYPE_UNSPEC,        /* Reserve 0 as invalid
                                                      program type */
                      BPF_PROG_TYPE_SOCKET_FILTER,
                      BPF_PROG_TYPE_KPROBE,
                      BPF_PROG_TYPE_SCHED_CLS,
                      BPF_PROG_TYPE_SCHED_ACT,
                      BPF_PROG_TYPE_TRACEPOINT,
                      BPF_PROG_TYPE_XDP,
                      BPF_PROG_TYPE_PERF_EVENT,
                      BPF_PROG_TYPE_CGROUP_SKB,
                      BPF_PROG_TYPE_CGROUP_SOCK,
                      BPF_PROG_TYPE_LWT_IN,
                      BPF_PROG_TYPE_LWT_OUT,
                      BPF_PROG_TYPE_LWT_XMIT,
                      BPF_PROG_TYPE_SOCK_OPS,
                      BPF_PROG_TYPE_SK_SKB,
                      BPF_PROG_TYPE_CGROUP_DEVICE,
                      BPF_PROG_TYPE_SK_MSG,
                      BPF_PROG_TYPE_RAW_TRACEPOINT,
                      BPF_PROG_TYPE_CGROUP_SOCK_ADDR,
                      BPF_PROG_TYPE_LWT_SEG6LOCAL,
                      BPF_PROG_TYPE_LIRC_MODE2,
                      BPF_PROG_TYPE_SK_REUSEPORT,
                      BPF_PROG_TYPE_FLOW_DISSECTOR,
                      /* See /usr/include/linux/bpf.h for the full list. */
                  };

       For further details of eBPF program types, see below.

       The remaining fields of bpf_attr are set as follows:

       •  insns is an array of struct bpf_insn instructions.

       •  insn_cnt is the number of instructions in the program referred to by insns.

       •  license  is  a license string, which must be GPL compatible to call helper functions marked gpl_only.  (The licensing rules are the same as for kernel modules, so that also dual licenses, such
          as "Dual BSD/GPL", may be used.)

       •  log_buf is a pointer to a caller-allocated buffer in which the in-kernel verifier can store the verification log.  This log is a multi-line string that can be checked by the program author  in
          order to understand how the verifier came to the conclusion that the eBPF program is unsafe.  The format of the output can change at any time as the verifier evolves.

       •  log_size size of the buffer pointed to by log_buf.  If the size of the buffer is not large enough to store all verifier messages, -1 is returned and errno is set to ENOSPC.

       •  log_level verbosity level of the verifier.  A value of zero means that the verifier will not provide a log; in this case, log_buf must be a NULL pointer, and log_size must be zero.

       Applying close(2) to the file descriptor returned by BPF_PROG_LOAD will unload the eBPF program (but see NOTES).

       Maps  are  accessible  from  eBPF  programs  and are used to exchange data between eBPF programs and between eBPF programs and user-space programs.  For example, eBPF programs can process various
       events (like kprobe, packets) and store their data into a map, and user-space programs can then fetch data from the map.  Conversely, user-space programs can use a map as a  configuration  mecha‐
       nism, populating the map with values checked by the eBPF program, which then modifies its behavior on the fly according to those values.

   eBPF program types
       The  eBPF  program  type (prog_type) determines the subset of kernel helper functions that the program may call.  The program type also determines the program input (context)—the format of struct
       bpf_context (which is the data blob passed into the eBPF program as the first argument).

       For example, a tracing program does not have the exact same subset of helper functions as a socket filter program (though they may have some helpers in common).  Similarly,  the  input  (context)
       for a tracing program is a set of register values, while for a socket filter it is a network packet.

       The set of functions available to eBPF programs of a given type may increase in the future.

       The following program types are supported:

       BPF_PROG_TYPE_SOCKET_FILTER (since Linux 3.19)
              Currently, the set of functions for BPF_PROG_TYPE_SOCKET_FILTER is:

                  bpf_map_lookup_elem(map_fd, void *key)
                                      /* look up key in a map_fd */
                  bpf_map_update_elem(map_fd, void *key, void *value)
                                      /* update key/value */
                  bpf_map_delete_elem(map_fd, void *key)
                                      /* delete key in a map_fd */

              The bpf_context argument is a pointer to a struct __sk_buff.

       BPF_PROG_TYPE_KPROBE (since Linux 4.1)
              [To be documented]

       BPF_PROG_TYPE_SCHED_CLS (since Linux 4.1)
              [To be documented]

       BPF_PROG_TYPE_SCHED_ACT (since Linux 4.1)
              [To be documented]

   Events
       Once a program is loaded, it can be attached to an event.  Various kernel subsystems have different ways to do so.

       Since Linux 3.19, the following call will attach the program prog_fd to the socket sockfd, which was created by an earlier call to socket(2):

           setsockopt(sockfd, SOL_SOCKET, SO_ATTACH_BPF,
                      &prog_fd, sizeof(prog_fd));

       Since  Linux  4.1,  the  following call may be used to attach the eBPF program referred to by the file descriptor prog_fd to a perf event file descriptor, event_fd, that was created by a previous
       call to perf_event_open(2):

           ioctl(event_fd, PERF_EVENT_IOC_SET_BPF, prog_fd);

RETURN VALUE
       For a successful call, the return value depends on the operation:

       BPF_MAP_CREATE
              The new file descriptor associated with the eBPF map.

       BPF_PROG_LOAD
              The new file descriptor associated with the eBPF program.

       All other commands
              Zero.

       On error, -1 is returned, and errno is set to indicate the error.

ERRORS
       E2BIG  The eBPF program is too large or a map reached the max_entries limit (maximum number of elements).

       EACCES For BPF_PROG_LOAD, even though all program instructions are valid, the program has been rejected because it was deemed unsafe.  This may be because it may have accessed a disallowed memory
              region or an uninitialized stack/register or because the function constraints don't match the actual types or because there was a misaligned memory access.  In this case, it is recommended
              to call bpf() again with log_level = 1 and examine log_buf for the specific reason provided by the verifier.

       EBADF  fd is not an open file descriptor.

       EFAULT One of the pointers (key or value or log_buf or insns) is outside the accessible address space.

       EINVAL The value specified in cmd is not recognized by this kernel.

       EINVAL For BPF_MAP_CREATE, either map_type or attributes are invalid.

       EINVAL For BPF_MAP_*_ELEM commands, some of the fields of union bpf_attr that are not used by this command are not set to zero.

       EINVAL For BPF_PROG_LOAD, indicates an attempt to load an invalid program.  eBPF programs can be deemed invalid due to unrecognized instructions, the use of reserved fields, jumps out  of  range,
              infinite loops or calls of unknown functions.

       ENOENT For BPF_MAP_LOOKUP_ELEM or BPF_MAP_DELETE_ELEM, indicates that the element with the given key was not found.

       ENOMEM Cannot allocate sufficient memory.

       EPERM  The call was made without sufficient privilege (without the CAP_SYS_ADMIN capability).

STANDARDS
       Linux.

HISTORY
       Linux 3.18.

NOTES
       Prior  to  Linux  4.4,  all  bpf()  commands  require  the  caller  to  have  the  CAP_SYS_ADMIN  capability.   From  Linux  4.4  onwards, an unprivileged user may create limited programs of type
       BPF_PROG_TYPE_SOCKET_FILTER and associated maps.  However they may not store kernel pointers within the maps and are presently limited to the following helper functions:

       •  get_random
       •  get_smp_processor_id
       •  tail_call
       •  ktime_get_ns

       Unprivileged access may be blocked by writing the value 1 to the file /proc/sys/kernel/unprivileged_bpf_disabled.

       eBPF objects (maps and programs) can be shared between processes.  For example, after fork(2), the child inherits file descriptors referring to the same eBPF objects.  In addition, file  descrip‐
       tors  referring  to  eBPF  objects can be transferred over UNIX domain sockets.  File descriptors referring to eBPF objects can be duplicated in the usual way, using dup(2) and similar calls.  An
       eBPF object is deallocated only after all file descriptors referring to the object have been closed.

       eBPF programs can be written in a restricted C that is compiled (using the clang compiler) into eBPF bytecode.  Various features are omitted from this restricted C, such as  loops,  global  vari‐
       ables, variadic functions, floating-point numbers, and passing structures as function arguments.  Some examples can be found in the samples/bpf/*_kern.c files in the kernel source tree.

       The  kernel  contains a just-in-time (JIT) compiler that translates eBPF bytecode into native machine code for better performance.  Before Linux 4.15, the JIT compiler is disabled by default, but
       its operation can be controlled by writing one of the following integer strings to the file /proc/sys/net/core/bpf_jit_enable:

       0      Disable JIT compilation (default).

       1      Normal compilation.

       2      Debugging mode.  The generated opcodes are dumped in hexadecimal into the kernel log.  These opcodes can then be disassembled using the program tools/net/bpf_jit_disasm.c provided  in  the
              kernel source tree.

       Since  Linux  4.15,  the  kernel  may configured with the CONFIG_BPF_JIT_ALWAYS_ON option.  In this case, the JIT compiler is always enabled, and the bpf_jit_enable is initialized to 1 and is im‐
       mutable.  (This kernel configuration option was provided as a mitigation for one of the Spectre attacks against the BPF interpreter.)

       The JIT compiler for eBPF is currently available for the following architectures:

       •  x86-64 (since Linux 3.18; cBPF since Linux 3.0);
       •  ARM32 (since Linux 3.18; cBPF since Linux 3.4);
       •  SPARC 32 (since Linux 3.18; cBPF since Linux 3.5);
       •  ARM-64 (since Linux 3.18);
       •  s390 (since Linux 4.1; cBPF since Linux 3.7);
       •  PowerPC 64 (since Linux 4.8; cBPF since Linux 3.1);
       •  SPARC 64 (since Linux 4.12);
       •  x86-32 (since Linux 4.18);
       •  MIPS 64 (since Linux 4.18; cBPF since Linux 3.16);
       •  riscv (since Linux 5.1).

EXAMPLES
       /* bpf+sockets example:
        * 1. create array map of 256 elements
        * 2. load program that counts number of packets received
        *    r0 = skb->data[ETH_HLEN + offsetof(struct iphdr, protocol)]
        *    map[r0]++
        * 3. attach prog_fd to raw socket via setsockopt()
        * 4. print number of received TCP/UDP packets every second
        */
       int
       main(int argc, char *argv[])
       {
           int sock, map_fd, prog_fd, key;
           long long value = 0, tcp_cnt, udp_cnt;

           map_fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(key),
                                   sizeof(value), 256);
           if (map_fd < 0) {
               printf("failed to create map '%s'\n", strerror(errno));
               /* likely not run as root */
               return 1;
           }

           struct bpf_insn prog[] = {
               BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),        /* r6 = r1 */
               BPF_LD_ABS(BPF_B, ETH_HLEN + offsetof(struct iphdr, protocol)),
                                       /* r0 = ip->proto */
               BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),
                                       /* *(u32 *)(fp - 4) = r0 */
               BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),       /* r2 = fp */
               BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),      /* r2 = r2 - 4 */
               BPF_LD_MAP_FD(BPF_REG_1, map_fd),           /* r1 = map_fd */
               BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),
                                       /* r0 = map_lookup(r1, r2) */
               BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2),
                                       /* if (r0 == 0) goto pc+2 */
               BPF_MOV64_IMM(BPF_REG_1, 1),                /* r1 = 1 */
               BPF_XADD(BPF_DW, BPF_REG_0, BPF_REG_1, 0, 0),
                                       /* lock *(u64 *) r0 += r1 */
               BPF_MOV64_IMM(BPF_REG_0, 0),                /* r0 = 0 */
               BPF_EXIT_INSN(),                            /* return r0 */
           };

           prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog,
                                   sizeof(prog) / sizeof(prog[0]), "GPL");

           sock = open_raw_sock("lo");

           assert(setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &prog_fd,
                             sizeof(prog_fd)) == 0);

           for (;;) {
               key = IPPROTO_TCP;
               assert(bpf_lookup_elem(map_fd, &key, &tcp_cnt) == 0);
               key = IPPROTO_UDP;
               assert(bpf_lookup_elem(map_fd, &key, &udp_cnt) == 0);
               printf("TCP %lld UDP %lld packets\n", tcp_cnt, udp_cnt);
               sleep(1);
           }

           return 0;
       }

       Some complete working code can be found in the samples/bpf directory in the kernel source tree.

SEE ALSO
       seccomp(2), bpf-helpers(7), socket(7), tc(8), tc-bpf(8)

       Both classic and extended BPF are explained in the kernel source file Documentation/networking/filter.txt.

Linux man-pages 6.04                                                                            2023-03-30                                                                                          bpf(2)
BPF classifier and actions in tc(8)                                                                Linux                                                               BPF classifier and actions in tc(8)

NAME
       BPF - BPF programmable classifier and actions for ingress/egress queueing disciplines

SYNOPSIS
   eBPF classifier (filter) or action:
       tc  filter ... bpf [ object-file OBJ_FILE ] [ section CLS_NAME ] [ export UDS_FILE ] [ verbose ] [ direct-action | da ] [ skip_hw | skip_sw ] [ police POLICE_SPEC ] [ action ACTION_SPEC ] [ clas‐
       sid CLASSID ]
       tc action ... bpf [ object-file OBJ_FILE ] [ section CLS_NAME ] [ export UDS_FILE ] [ verbose ]

   cBPF classifier (filter) or action:
       tc filter ... bpf [ bytecode-file BPF_FILE | bytecode BPF_BYTECODE ] [ police POLICE_SPEC ] [ action ACTION_SPEC ] [ classid CLASSID ]
       tc action ... bpf [ bytecode-file BPF_FILE | bytecode BPF_BYTECODE ]

DESCRIPTION
       Extended Berkeley Packet Filter ( eBPF ) and classic Berkeley Packet Filter (originally known as BPF, for better distinction referred to as cBPF here) are both available as a  fully  programmable
       and  highly efficient classifier and actions. They both offer a minimal instruction set for implementing small programs which can safely be loaded into the kernel and thus executed in a tiny vir‐
       tual machine from kernel space. An in-kernel verifier guarantees that a specified program always terminates and neither crashes nor leaks data from the kernel.

       In Linux, it's generally considered that eBPF is the successor of cBPF.  The kernel internally transforms cBPF expressions into eBPF expressions and executes the latter. Execution of them can  be
       performed in an interpreter or at setup time, they can be just-in-time compiled (JIT'ed) to run as native machine code.

       Currently, the eBPF JIT compiler is available for the following architectures:

       *   x86_64 (since Linux 3.18)
       *   arm64 (since Linux 3.18)
       *   s390 (since Linux 4.1)
       *   ppc64 (since Linux 4.8)
       *   sparc64 (since Linux 4.12)
       *   mips64 (since Linux 4.13)
       *   arm32 (since Linux 4.14)
       *   x86_32 (since Linux 4.18)

       Whereas the following architectures have cBPF, but did not (yet) switch to eBPF JIT support:

       *   ppc32
       *   sparc32
       *   mips32

       eBPF's instruction set has similar underlying principles as the cBPF instruction set, it however is modelled closer to the underlying architecture to better mimic native instruction sets with the
       aim to achieve a better run-time performance. It is designed to be JIT'ed with a one to one mapping, which can also open up the possibility for compilers to generate optimized eBPF  code  through
       an  eBPF  backend that performs almost as fast as natively compiled code. Given that LLVM provides such an eBPF backend, eBPF programs can therefore easily be programmed in a subset of the C lan‐
       guage. Other than that, eBPF infrastructure also comes with a construct called "maps". eBPF maps are key/value stores that are shared between multiple eBPF programs, but also  between  eBPF  pro‐
       grams and user space applications.

       For the traffic control subsystem, classifier and actions that can be attached to ingress and egress qdiscs can be written in eBPF or cBPF. The advantage over other classifier and actions is that
       eBPF/cBPF provides the generic framework, while users can implement their highly specialized use cases efficiently. This means that the classifier or action written that way will not suffer  from
       feature  bloat, and can therefore execute its task highly efficient. It allows for non-linear classification and even merging the action part into the classification. Combined with efficient eBPF
       map data structures, user space can push new policies like classids into the kernel without reloading a classifier, or it can gather statistics that are pushed into one map and  use  another  one
       for dynamically load balancing traffic based on the determined load, just to provide a few examples.

PARAMETERS
   object-file
       points  to an object file that has an executable and linkable format (ELF) and contains eBPF opcodes and eBPF map definitions. The LLVM compiler infrastructure with clang(1) as a C language front
       end is one project that supports emitting eBPF object files that can be passed to the eBPF classifier (more details in the EXAMPLES section). This option is mandatory when an eBPF  classifier  or
       action is to be loaded.

   section
       is  the  name  of the ELF section from the object file, where the eBPF classifier or action resides. By default the section name for the classifier is called "classifier", and for the action "ac‐
       tion". Given that a single object file can contain multiple classifier and actions, the corresponding section name needs to be specified, if it differs from the defaults.

   export
       points to a Unix domain socket file. In case the eBPF object file also contains a section named "maps" with eBPF map specifications, then the map file descriptors can be handed off via  the  Unix
       domain  socket  to  an eBPF "agent" herding all descriptors after tc lifetime. This can be some third party application implementing the IPC counterpart for the import, that uses them for calling
       into bpf(2) system call to read out or update eBPF map data from user space, for example, for monitoring purposes or to push down new policies.

   verbose
       if set, it will dump the eBPF verifier output, even if loading the eBPF program was successful. By default, only on error, the verifier log is being emitted to the user.

   direct-action | da
       instructs eBPF classifier to not invoke external TC actions, instead use the TC actions return codes (TC_ACT_OK, TC_ACT_SHOT etc.) for classifiers.

   skip_hw | skip_sw
       hardware offload control flags. By default TC will try to offload filters to hardware if possible.  skip_hw explicitly disables the attempt to offload.  skip_sw forces the  offload  and  disables
       running the eBPF program in the kernel.  If hardware offload is not possible and this flag was set kernel will report an error and filter will not be installed at all.

   police
       is an optional parameter for an eBPF/cBPF classifier that specifies a police in tc(1) which is attached to the classifier, for example, on an ingress qdisc.

   action
       is an optional parameter for an eBPF/cBPF classifier that specifies a subsequent action in tc(1) which is attached to a classifier.

   classid
   flowid
       provides  the  default  traffic control class identifier for this eBPF/cBPF classifier. The default class identifier can also be overwritten by the return code of the eBPF/cBPF program. A default
       return code of -1 specifies the here provided default class identifier to be used. A return code of the eBPF/cBPF program of 0 implies that no match took place, and a return code other than these
       two  will  override  the  default  classid. This allows for efficient, non-linear classification with only a single eBPF/cBPF program as opposed to having multiple individual programs for various
       class identifiers which would need to reparse packet contents.

   bytecode
       is being used for loading cBPF classifier and actions only. The cBPF bytecode is directly passed as a text string in the form of 's,c t f k,c t f k,c t f k,...'  , where s denotes the  number  of
       subsequent  4-tuples.  One  such  4-tuple  consists of c t f k decimals, where c represents the cBPF opcode, t the jump true offset target, f the jump false offset target and k the immediate con‐
       stant/literal. There are various tools that generate code in this loadable format, for example, bpf_asm that ships with the Linux kernel source tree under tools/net/ , so it is certainly not  ex‐
       pected to hack this by hand. The bytecode or bytecode-file option is mandatory when a cBPF classifier or action is to be loaded.

   bytecode-file
       also being used to load a cBPF classifier or action. It's effectively the same as bytecode only that the cBPF bytecode is not passed directly via command line, but rather resides in a text file.

EXAMPLES
   eBPF TOOLING
       A full blown example including eBPF agent code can be found inside the iproute2 source package under: examples/bpf/

       As  prerequisites, the kernel needs to have the eBPF system call namely bpf(2) enabled and ships with cls_bpf and act_bpf kernel modules for the traffic control subsystem. To enable eBPF/eBPF JIT
       support, depending which of the two the given architecture supports:

           echo 1 > /proc/sys/net/core/bpf_jit_enable

       A given restricted C file can be compiled via LLVM as:

           clang -O2 -emit-llvm -c bpf.c -o - | llc -march=bpf -filetype=obj -o bpf.o

       The compiler invocation might still simplify in future, so for now, it's quite handy to alias this construct in one way or another, for example:

           __bcc() {
                   clang -O2 -emit-llvm -c $1 -o - | \
                   llc -march=bpf -filetype=obj -o "`basename $1 .c`.o"
           }

           alias bcc=__bcc

       A minimal, stand-alone unit, which matches on all traffic with the default classid (return code of -1) looks like:

           #include <linux/bpf.h>

           #ifndef __section
           # define __section(x)  __attribute__((section(x), used))
           #endif

           __section("classifier") int cls_main(struct __sk_buff *skb)
           {
                   return -1;
           }

           char __license[] __section("license") = "GPL";

       More examples can be found further below in subsection eBPF PROGRAMMING as focus here will be on tooling.

       There can be various other sections, for example, also for actions.  Thus, an object file in eBPF can contain multiple entrance points.  Always a specific entrance point, however, must be  speci‐
       fied  when  configuring  with  tc. A license must be part of the restricted C code and the license string syntax is the same as with Linux kernel modules.  The kernel reserves its right that some
       eBPF helper functions can be restricted to GPL compatible licenses only, and thus may reject a program from loading into the kernel when such a license mismatch occurs.

       The resulting object file from the compilation can be inspected with the usual set of tools that also operate on normal object files, for example objdump(1) for inspecting ELF section headers:

           objdump -h bpf.o
           [...]
           3 classifier    000007f8  0000000000000000  0000000000000000  00000040  2**3
                           CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
           4 action-mark   00000088  0000000000000000  0000000000000000  00000838  2**3
                           CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
           5 action-rand   00000098  0000000000000000  0000000000000000  000008c0  2**3
                           CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
           6 maps          00000030  0000000000000000  0000000000000000  00000958  2**2
                           CONTENTS, ALLOC, LOAD, DATA
           7 license       00000004  0000000000000000  0000000000000000  00000988  2**0
                           CONTENTS, ALLOC, LOAD, DATA
           [...]

       Adding an eBPF classifier from an object file that contains a classifier in the default ELF section is trivial (note that instead of "object-file" also shortcuts such as "obj" can be used):

           bcc bpf.c
           tc filter add dev em1 parent 1: bpf obj bpf.o flowid 1:1

       In case the classifier resides in ELF section "mycls", then that same command needs to be invoked as:

           tc filter add dev em1 parent 1: bpf obj bpf.o sec mycls flowid 1:1

       Dumping the classifier configuration will tell the location of the classifier, in other words that it's from object file "bpf.o" under section "mycls":

           tc filter show dev em1
           filter parent 1: protocol all pref 49152 bpf
           filter parent 1: protocol all pref 49152 bpf handle 0x1 flowid 1:1 bpf.o:[mycls]

       The same program can also be installed on ingress qdisc side as opposed to egress ...

           tc qdisc add dev em1 handle ffff: ingress
           tc filter add dev em1 parent ffff: bpf obj bpf.o sec mycls flowid ffff:1

       ... and again dumped from there:

           tc filter show dev em1 parent ffff:
           filter protocol all pref 49152 bpf
           filter protocol all pref 49152 bpf handle 0x1 flowid ffff:1 bpf.o:[mycls]

       Attaching a classifier and action on ingress has the restriction that it doesn't have an actual underlying queueing discipline. What ingress can do is to classify, mangle, redirect or drop  pack‐
       ets.  When queueing is required on ingress side, then ingress must redirect packets to the ifb device, otherwise policing can be used. Moreover, ingress can be used to have an early drop point of
       unwanted packets before they hit upper layers of the networking stack, perform network accounting with eBPF maps that could be shared with egress, or have an early mangle and/or redirection point
       to different networking devices.

       Multiple  eBPF actions and classifier can be placed into a single object file within various sections. In that case, non-default section names must be provided, which is the case for both actions
       in this example:

           tc filter add dev em1 parent 1: bpf obj bpf.o flowid 1:1 \
                                    action bpf obj bpf.o sec action-mark \
                                    action bpf obj bpf.o sec action-rand ok

       The advantage of this is that the classifier and the two actions can then share eBPF maps with each other, if implemented in the programs.

       In order to access eBPF maps from user space beyond tc(8) setup lifetime, the ownership can be transferred to an eBPF agent via Unix domain sockets. There are two possibilities  for  implementing
       this:

       1)  implementation  of  an  own  eBPF  agent that takes care of setting up the Unix domain socket and implementing the protocol that tc(8) dictates. A code example of this can be found inside the
       iproute2 source package under: examples/bpf/

       2) use tc exec for transferring the eBPF map file descriptors through a Unix domain socket, and spawning an application such as sh(1) . This approach's advantage is that tc will  place  the  file
       descriptors  into  the  environment and thus make them available just like stdin, stdout, stderr file descriptors, meaning, in case user applications run from within this fd-owner shell, they can
       terminate and restart without losing eBPF maps file descriptors. Example invocation with the previous classifier and action mixture:

           tc exec bpf imp /tmp/bpf
           tc filter add dev em1 parent 1: bpf obj bpf.o exp /tmp/bpf flowid 1:1 \
                                    action bpf obj bpf.o sec action-mark \
                                    action bpf obj bpf.o sec action-rand ok

       Assuming that eBPF maps are shared with classifier and actions, it's enough to export them once, for example, from within the classifier or action command. tc will setup all  eBPF  map  file  de‐
       scriptors at the time when the object file is first parsed.

       When a shell has been spawned, the environment will have a couple of eBPF related variables. BPF_NUM_MAPS provides the total number of maps that have been transferred over the Unix domain socket.
       BPF_MAP<X>'s value is the file descriptor number that can be accessed in eBPF agent applications, in other words, it can directly be used as the file descriptor value for the bpf(2)  system  call
       to retrieve or alter eBPF map values. <X> denotes the identifier of the eBPF map. It corresponds to the id member of struct bpf_elf_map  from the tc eBPF map specification.

       The environment in this example looks as follows:

           sh# env | grep BPF
               BPF_NUM_MAPS=3
               BPF_MAP1=6
               BPF_MAP0=5
               BPF_MAP2=7
           sh# ls -la /proc/self/fd
               [...]
               lrwx------. 1 root root 64 Apr 14 16:46 5 -> anon_inode:bpf-map
               lrwx------. 1 root root 64 Apr 14 16:46 6 -> anon_inode:bpf-map
               lrwx------. 1 root root 64 Apr 14 16:46 7 -> anon_inode:bpf-map
           sh# my_bpf_agent

       eBPF agents are very useful in that they can prepopulate eBPF maps from user space, monitor statistics via maps and based on that feedback, for example, rewrite classids in eBPF map values during
       runtime. Given that eBPF agents are implemented as normal applications, they can also dynamically receive traffic control policies from external controllers and thus push them down into eBPF maps
       to dynamically adapt to network conditions. Moreover, eBPF maps can also be shared with other eBPF program types (e.g. tracing), thus very powerful combination can therefore be implemented.

   eBPF PROGRAMMING
       eBPF classifier and actions are being implemented in restricted C syntax (in future, there could additionally be new language frontends supported).

       The header file linux/bpf.h provides eBPF helper functions that can be called from an eBPF program.  This man page will only provide two minimal, stand-alone examples, have a look at examples/bpf
       from the iproute2 source package for a fully fledged flow dissector example to better demonstrate some of the possibilities with eBPF.

       Supported 32 bit classifier return codes from the C program and their meanings:
           0 , denotes a mismatch
           -1 , denotes the default classid configured from the command line
           else , everything else will override the default classid to provide a facility for non-linear matching

       Supported 32 bit action return codes from the C program and their meanings ( linux/pkt_cls.h ):
           TC_ACT_OK (0) , will terminate the packet processing pipeline and allows the packet to proceed
           TC_ACT_SHOT (2) , will terminate the packet processing pipeline and drops the packet
           TC_ACT_UNSPEC (-1) , will use the default action configured from tc (similarly as returning -1 from a classifier)
           TC_ACT_PIPE (3) , will iterate to the next action, if available
           TC_ACT_RECLASSIFY (1) , will terminate the packet processing pipeline and start classification from the beginning
           else , everything else is an unspecified return code

       Both classifier and action return codes are supported in eBPF and cBPF programs.

       To demonstrate restricted C syntax, a minimal toy classifier example is provided, which assumes that egress packets, for instance originating from a container, have previously been marked in  in‐
       terval [0, 255]. The program keeps statistics on different marks for user space and maps the classid to the root qdisc with the marking itself as the minor handle:

           #include <stdint.h>
           #include <asm/types.h>

           #include <linux/bpf.h>
           #include <linux/pkt_sched.h>

           #include "helpers.h"

           struct tuple {
                   long packets;
                   long bytes;
           };

           #define BPF_MAP_ID_STATS        1 /* agent's map identifier */
           #define BPF_MAX_MARK            256

           struct bpf_elf_map __section("maps") map_stats = {
                   .type           =       BPF_MAP_TYPE_ARRAY,
                   .id             =       BPF_MAP_ID_STATS,
                   .size_key       =       sizeof(uint32_t),
                   .size_value     =       sizeof(struct tuple),
                   .max_elem       =       BPF_MAX_MARK,
                   .pinning        =       PIN_GLOBAL_NS,
           };

           static inline void cls_update_stats(const struct __sk_buff *skb,
                                               uint32_t mark)
           {
                   struct tuple *tu;

                   tu = bpf_map_lookup_elem(&map_stats, &mark);
                   if (likely(tu)) {
                           __sync_fetch_and_add(&tu->packets, 1);
                           __sync_fetch_and_add(&tu->bytes, skb->len);
                   }
           }

           __section("cls") int cls_main(struct __sk_buff *skb)
           {
                   uint32_t mark = skb->mark;

                   if (unlikely(mark >= BPF_MAX_MARK))
                           return 0;

                   cls_update_stats(skb, mark);

                   return TC_H_MAKE(TC_H_ROOT, mark);
           }

           char __license[] __section("license") = "GPL";

       Another  small example is a port redirector which demuxes destination port 80 into the interval [8080, 8087] steered by RSS, that can then be attached to ingress qdisc. The exercise of adding the
       egress counterpart and IPv6 support is left to the reader:

           #include <asm/types.h>
           #include <asm/byteorder.h>

           #include <linux/bpf.h>
           #include <linux/filter.h>
           #include <linux/in.h>
           #include <linux/if_ether.h>
           #include <linux/ip.h>
           #include <linux/tcp.h>

           #include "helpers.h"

           static inline void set_tcp_dport(struct __sk_buff *skb, int nh_off,
                                            __u16 old_port, __u16 new_port)
           {
                   bpf_l4_csum_replace(skb, nh_off + offsetof(struct tcphdr, check),
                                       old_port, new_port, sizeof(new_port));
                   bpf_skb_store_bytes(skb, nh_off + offsetof(struct tcphdr, dest),
                                       &new_port, sizeof(new_port), 0);
           }

           static inline int lb_do_ipv4(struct __sk_buff *skb, int nh_off)
           {
                   __u16 dport, dport_new = 8080, off;
                   __u8 ip_proto, ip_vl;

                   ip_proto = load_byte(skb, nh_off +
                                        offsetof(struct iphdr, protocol));
                   if (ip_proto != IPPROTO_TCP)
                           return 0;

                   ip_vl = load_byte(skb, nh_off);
                   if (likely(ip_vl == 0x45))
                           nh_off += sizeof(struct iphdr);
                   else
                           nh_off += (ip_vl & 0xF) << 2;

                   dport = load_half(skb, nh_off + offsetof(struct tcphdr, dest));
                   if (dport != 80)
                           return 0;

                   off = skb->queue_mapping & 7;
                   set_tcp_dport(skb, nh_off - BPF_LL_OFF, __constant_htons(80),
                                 __cpu_to_be16(dport_new + off));
                   return -1;
           }

           __section("lb") int lb_main(struct __sk_buff *skb)
           {
                   int ret = 0, nh_off = BPF_LL_OFF + ETH_HLEN;

                   if (likely(skb->protocol == __constant_htons(ETH_P_IP)))
                           ret = lb_do_ipv4(skb, nh_off);

                   return ret;
           }

           char __license[] __section("license") = "GPL";

       The related helper header file helpers.h in both examples was:

           /* Misc helper macros. */
           #define __section(x) __attribute__((section(x), used))
           #define offsetof(x, y) __builtin_offsetof(x, y)
           #define likely(x) __builtin_expect(!!(x), 1)
           #define unlikely(x) __builtin_expect(!!(x), 0)

           /* Object pinning settings */
           #define PIN_NONE       0
           #define PIN_OBJECT_NS  1
           #define PIN_GLOBAL_NS  2

           /* ELF map definition */
           struct bpf_elf_map {
               __u32 type;
               __u32 size_key;
               __u32 size_value;
               __u32 max_elem;
               __u32 flags;
               __u32 id;
               __u32 pinning;
               __u32 inner_id;
               __u32 inner_idx;
           };

           /* Some used BPF function calls. */
           static int (*bpf_skb_store_bytes)(void *ctx, int off, void *from,
                                             int len, int flags) =
                 (void *) BPF_FUNC_skb_store_bytes;
           static int (*bpf_l4_csum_replace)(void *ctx, int off, int from,
                                             int to, int flags) =
                 (void *) BPF_FUNC_l4_csum_replace;
           static void *(*bpf_map_lookup_elem)(void *map, void *key) =
                 (void *) BPF_FUNC_map_lookup_elem;

           /* Some used BPF intrinsics. */
           unsigned long long load_byte(void *skb, unsigned long long off)
               asm ("llvm.bpf.load.byte");
           unsigned long long load_half(void *skb, unsigned long long off)
               asm ("llvm.bpf.load.half");

       Best practice, we recommend to only have a single eBPF classifier loaded in tc and perform all necessary matching and mangling from there instead of a list of individual classifier  and  separate
       actions. Just a single classifier tailored for a given use-case will be most efficient to run.

   eBPF DEBUGGING
       Both tc filter and action commands for bpf support an optional verbose parameter that can be used to inspect the eBPF verifier log. It is dumped by default in case of an error.

       In case the eBPF/cBPF JIT compiler has been enabled, it can also be instructed to emit a debug output of the resulting opcode image into the kernel log, which can be read via dmesg(1) :

           echo 2 > /proc/sys/net/core/bpf_jit_enable

       The Linux kernel source tree ships additionally under tools/net/ a small helper called bpf_jit_disasm that reads out the opcode image dump from the kernel log and dumps the resulting disassembly:

           bpf_jit_disasm -o

       Other than that, the Linux kernel also contains an extensive eBPF/cBPF test suite module called test_bpf . Upon ...

           modprobe test_bpf

       ...  it  performs a diversity of test cases and dumps the results into the kernel log that can be inspected with dmesg(1) . The results can differ depending on whether the JIT compiler is enabled
       or not. In case of failed test cases, the module will fail to load. In such cases, we urge you to file a bug report to the related JIT authors, Linux kernel and networking mailing lists.

   cBPF
       Although we generally recommend switching to implementing eBPF classifier and actions, for the sake of completeness, a few words on how to program in cBPF will be lost here.

       Likewise, the bpf_jit_enable switch can be enabled as mentioned already. Tooling such as bpf_jit_disasm is also independent whether eBPF or cBPF code is being loaded.

       Unlike in eBPF, classifier and action are not implemented in restricted C, but rather in a minimal assembler-like language or with the help of other tooling.

       The raw interface with tc takes opcodes directly. For example, the most minimal classifier matching on every packet resulting in the default classid of 1:1 looks like:

           tc filter add dev em1 parent 1: bpf bytecode '1,6 0 0 4294967295,' flowid 1:1

       The first decimal of the bytecode sequence denotes the number of subsequent 4-tuples of cBPF opcodes. As mentioned, such a 4-tuple consists of c t f k decimals, where c represents  the  cBPF  op‐
       code, t the jump true offset target, f the jump false offset target and k the immediate constant/literal. Here, this denotes an unconditional return from the program with immediate value of -1.

       Thus,  for  egress  classification,  Willem  de Bruijn implemented a minimal stand-alone helper tool under the GNU General Public License version 2 for iptables(8) BPF extension, which abuses the
       libpcap internal classic BPF compiler, his code derived here for usage with tc(8) :

           #include <pcap.h>
           #include <stdio.h>

           int main(int argc, char **argv)
           {
                   struct bpf_program prog;
                   struct bpf_insn *ins;
                   int i, ret, dlt = DLT_RAW;

                   if (argc < 2 || argc > 3)
                           return 1;
                   if (argc == 3) {
                           dlt = pcap_datalink_name_to_val(argv[1]);
                           if (dlt == -1)
                                   return 1;
                   }

                   ret = pcap_compile_nopcap(-1, dlt, &prog, argv[argc - 1],
                                             1, PCAP_NETMASK_UNKNOWN);
                   if (ret)
                           return 1;

                   printf("%d,", prog.bf_len);
                   ins = prog.bf_insns;

                   for (i = 0; i < prog.bf_len - 1; ++ins, ++i)
                           printf("%u %u %u %u,", ins->code,
                                  ins->jt, ins->jf, ins->k);
                   printf("%u %u %u %u",
                          ins->code, ins->jt, ins->jf, ins->k);

                   pcap_freecode(&prog);
                   return 0;
           }

       Given this small helper, any tcpdump(8) filter expression can be abused as a classifier where a match will result in the default classid:

           bpftool EN10MB 'tcp[tcpflags] & tcp-syn != 0' > /var/bpf/tcp-syn
           tc filter add dev em1 parent 1: bpf bytecode-file /var/bpf/tcp-syn flowid 1:1

       Basically, such a minimal generator is equivalent to:

           tcpdump -iem1 -ddd 'tcp[tcpflags] & tcp-syn != 0' | tr '\n' ',' > /var/bpf/tcp-syn

       Since libpcap does not support all Linux' specific cBPF extensions in its compiler, the Linux kernel also ships under tools/net/ a minimal BPF assembler called bpf_asm for providing full control.
       For detailed syntax and semantics on implementing such programs by hand, see references under FURTHER READING .

       Trivial toy example in bpf_asm for classifying IPv4/TCP packets, saved in a text file called foobar :

           ldh [12]
           jne #0x800, drop
           ldb [23]
           jneq #6, drop
           ret #-1
           drop: ret #0

       Similarly, such a classifier can be loaded as:

           bpf_asm foobar > /var/bpf/tcp-syn
           tc filter add dev em1 parent 1: bpf bytecode-file /var/bpf/tcp-syn flowid 1:1

       For  BPF  classifiers,  the Linux kernel provides additionally under tools/net/ a small BPF debugger called bpf_dbg , which can be used to test a classifier against pcap files, single-step or add
       various breakpoints into the classifier program and dump register contents during runtime.

       Implementing an action in classic BPF is rather limited in the sense that packet mangling is not supported. Therefore, it's generally recommended to make the switch to eBPF, whenever possible.

FURTHER READING
       Further and more technical details about the BPF architecture can be found in the Linux kernel source tree under Documentation/networking/filter.txt .

       Further details on eBPF tc(8) examples can be found in the iproute2 source tree under examples/bpf/ .

SEE ALSO
       tc(8), tc-ematch(8) bpf(2) bpf(4)

AUTHORS
       Manpage written by Daniel Borkmann.

       Please report corrections or improvements to the Linux kernel networking mailing list: <netdev@vger.kernel.org>

iproute2                                                                                        18 May 2015                                                            BPF classifier and actions in tc(8)
