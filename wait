WAIT(1P)                                                                                 POSIX Programmer's Manual                                                                                WAIT(1P)

PROLOG
       This  manual  page is part of the POSIX Programmer's Manual.  The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or
       the interface may not be implemented on Linux.

NAME
       wait — await process completion

SYNOPSIS
       wait [pid...]

DESCRIPTION
       When an asynchronous list (see Section 2.9.3.1, Examples) is started by the shell, the process ID of the last command in each element of the asynchronous list shall become known  in  the  current
       shell execution environment; see Section 2.12, Shell Execution Environment.

       If the wait utility is invoked with no operands, it shall wait until all process IDs known to the invoking shell have terminated and exit with a zero exit status.

       If one or more pid operands are specified that represent known process IDs, the wait utility shall wait until all of them have terminated. If one or more pid operands are specified that represent
       unknown process IDs, wait shall treat them as if they were known process IDs that exited with exit status 127. The exit status returned by the wait utility shall be the exit status of the process
       requested by the last pid operand.

       The known process IDs are applicable only for invocations of wait in the current shell execution environment.

OPTIONS
       None.

OPERANDS
       The following operand shall be supported:

       pid       One of the following:

                  1. The unsigned decimal integer process ID of a command, for which the utility is to wait for the termination.

                  2. A  job  control job ID (see the Base Definitions volume of POSIX.1‐2017, Section 3.204, Job Control Job ID) that identifies a background process group to be waited for. The job con‐
                     trol job ID notation is applicable only for invocations of wait in the current shell execution environment; see Section 2.12, Shell Execution Environment.  The exit status  of  wait
                     shall be determined by the last command in the pipeline.

                     Note:     The job control job ID type of pid is only available on systems supporting the User Portability Utilities option.

STDIN
       Not used.

INPUT FILES
       None.

ENVIRONMENT VARIABLES
       The following environment variables shall affect the execution of wait:

       LANG      Provide  a default value for the internationalization variables that are unset or null. (See the Base Definitions volume of POSIX.1‐2017, Section 8.2, Internationalization Variables for
                 the precedence of internationalization variables used to determine the values of locale categories.)

       LC_ALL    If set to a non-empty string value, override the values of all the other internationalization variables.

       LC_CTYPE  Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as opposed to multi-byte characters in arguments).

       LC_MESSAGES
                 Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.

       NLSPATH   Determine the location of message catalogs for the processing of LC_MESSAGES.

ASYNCHRONOUS EVENTS
       Default.

STDOUT
       Not used.

STDERR
       The standard error shall be used only for diagnostic messages.

OUTPUT FILES
       None.

EXTENDED DESCRIPTION
       None.

EXIT STATUS
       If one or more operands were specified, all of them have terminated or were not known by the invoking shell, and the status of the last operand specified is known, then the exit  status  of  wait
       shall  be the exit status information of the command indicated by the last operand specified. If the process terminated abnormally due to the receipt of a signal, the exit status shall be greater
       than 128 and shall be distinct from the exit status generated by other signals, but the exact value is unspecified. (See the kill -l option.) Otherwise, the wait utility shall exit  with  one  of
       the following values:

           0   The wait utility was invoked with no operands and all process IDs known by the invoking shell have terminated.

       1‐126   The wait utility detected an error.

         127   The command identified by the last pid operand specified is unknown.

CONSEQUENCES OF ERRORS
       Default.

       The following sections are informative.

APPLICATION USAGE
       On most implementations, wait is a shell built-in. If it is called in a subshell or separate utility execution environment, such as one of the following:

           (wait)
           nohup wait ...
           find . -exec wait ... \;

       it returns immediately because there are no known process IDs to wait for in those environments.

       Historical implementations of interactive shells have discarded the exit status of terminated background processes before each shell prompt. Therefore, the status of background processes was usu‐
       ally lost unless it terminated while wait was waiting for it. This could be a serious problem when a job that was expected to run for a long time actually terminated quickly with a syntax or ini‐
       tialization error because the exit status returned was usually zero if the requested process ID was not found. This volume of POSIX.1‐2017 requires the implementation to keep the status of termi‐
       nated jobs available until the status is requested, so that scripts like:

           j1&
           p1=$!
           j2&
           wait $p1
           echo Job 1 exited with status $?
           wait $!
           echo Job 2 exited with status $?

       work without losing status on any of the jobs. The shell is allowed to discard the status of any process if it determines that the application cannot get the process ID for that process from  the
       shell. It is also required to remember only {CHILD_MAX} number of processes in this way. Since the only way to get the process ID from the shell is by using the '!'  shell parameter, the shell is
       allowed to discard the status of an asynchronous list if "$!" was not referenced before another asynchronous list was started. (This means that the shell only has to keep the status of  the  last
       asynchronous  list started if the application did not reference "$!".  If the implementation of the shell is smart enough to determine that a reference to "$!" was not saved anywhere that the ap‐
       plication can retrieve it later, it can use this information to trim the list of saved information. Note also that a successful call to wait with no operands discards the exit status of all asyn‐
       chronous lists.)

       If  the exit status of wait is greater than 128, there is no way for the application to know if the waited-for process exited with that value or was killed by a signal.  Since most utilities exit
       with small values, there is seldom any ambiguity. Even in the ambiguous cases, most applications just need to know that the asynchronous job failed; it does not matter whether it detected an  er‐
       ror and failed or was killed and did not complete its job normally.

EXAMPLES
       Although the exact value used when a process is terminated by a signal is unspecified, if it is known that a signal terminated a process, a script can still reliably determine which signal by us‐
       ing kill as shown by the following script:

           sleep 1000&
           pid=$!
           kill -kill $pid
           wait $pid
           echo $pid was terminated by a SIG$(kill -l $?) signal.

       If the following sequence of commands is run in less than 31 seconds:

           sleep 257 | sleep 31 &
           jobs -l %%

       either of the following commands returns the exit status of the second sleep in the pipeline:

           wait <pid of sleep 31>
           wait %%

RATIONALE
       The description of wait does not refer to the waitpid() function from the System Interfaces volume of POSIX.1‐2017 because that would needlessly overspecify this interface. However,  the  wording
       means  that  wait  is  required  to wait for an explicit process when it is given an argument so that the status information of other processes is not consumed. Historical implementations use the
       wait() function defined in the System Interfaces volume of POSIX.1‐2017 until wait() returns the requested process ID or finds that the requested process does not exist. Because this means that a
       shell  script could not reliably get the status of all background children if a second background job was ever started before the first job finished, it is recommended that the wait utility use a
       method such as the functionality provided by the waitpid() function.

       The ability to wait for multiple pid operands was adopted from the KornShell.

       This new functionality was added because it is needed to determine the exit status of any asynchronous list accurately. The only compatibility problem that this change creates  is  for  a  script
       like

           while sleep 60 do
               job& echo Job started $(date) as $!  done

       which  causes the shell to monitor all of the jobs started until the script terminates or runs out of memory. This would not be a problem if the loop did not reference "$!" or if the script would
       occasionally wait for jobs it started.

FUTURE DIRECTIONS
       None.

SEE ALSO
       Chapter 2, Shell Command Language, kill, sh

       The Base Definitions volume of POSIX.1‐2017, Section 3.204, Job Control Job ID, Chapter 8, Environment Variables

       The System Interfaces volume of POSIX.1‐2017, wait()

COPYRIGHT
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group
       Base  Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any discrepancy between this ver‐
       sion and the original IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be  obtained  online  at  http://www.open‐
       group.org/unix/online.html .

       Any  typographical  or  formatting errors that appear in this page are most likely to have been introduced during the conversion of the source files to man page format. To report such errors, see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                                                                2017                                                                                           WAIT(1P)
WAIT(3P)                                                                                 POSIX Programmer's Manual                                                                                WAIT(3P)

PROLOG
       This  manual  page is part of the POSIX Programmer's Manual.  The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or
       the interface may not be implemented on Linux.

NAME
       wait, waitpid — wait for a child process to stop or terminate

SYNOPSIS
       #include <sys/wait.h>

       pid_t wait(int *stat_loc);
       pid_t waitpid(pid_t pid, int *stat_loc, int options);

DESCRIPTION
       The wait() and waitpid() functions shall obtain status information (see Section 2.13, Status Information) pertaining to one of the caller's child processes. The wait() function obtains status in‐
       formation  for process termination from any child process. The waitpid() function obtains status information for process termination, and optionally process stop and/or continue, from a specified
       subset of the child processes.

       The wait() function shall cause the calling thread to become blocked until status information generated by child process termination is made available to the thread, or until delivery of a signal
       whose  action  is  either to execute a signal-catching function or to terminate the process, or an error occurs. If termination status information is available prior to the call to wait(), return
       shall be immediate. If termination status information is available for two or more child processes, the order in which their status is reported is unspecified.

       As described in Section 2.13, Status Information, the wait() and waitpid() functions consume the status information they obtain.

       The behavior when multiple threads are blocked in wait(), waitid(), or waitpid() is described in Section 2.13, Status Information.

       The waitpid() function shall be equivalent to wait() if the pid argument is (pid_t)-1 and the options argument is 0. Otherwise, its behavior shall be modified by the values of the pid and options
       arguments.

       The pid argument specifies a set of child processes for which status is requested. The waitpid() function shall only return the status of a child process from this set:

        *  If pid is equal to (pid_t)-1, status is requested for any child process. In this respect, waitpid() is then equivalent to wait().

        *  If pid is greater than 0, it specifies the process ID of a single child process for which status is requested.

        *  If pid is 0, status is requested for any child process whose process group ID is equal to that of the calling process.

        *  If pid is less than (pid_t)-1, status is requested for any child process whose process group ID is equal to the absolute value of pid.

       The options argument is constructed from the bitwise-inclusive OR of zero or more of the following flags, defined in the <sys/wait.h> header:

       WCONTINUED  The waitpid() function shall report the status of any continued child process specified by pid whose status has not been reported since it continued from a job control stop.

       WNOHANG     The waitpid() function shall not suspend execution of the calling thread if status is not immediately available for one of the child processes specified by pid.

       WUNTRACED   The status of any child processes specified by pid that are stopped, and whose status has not yet been reported since they stopped, shall also be reported to the requesting process.

       If  wait() or waitpid() return because the status of a child process is available, these functions shall return a value equal to the process ID of the child process. In this case, if the value of
       the argument stat_loc is not a null pointer, information shall be stored in the location pointed to by stat_loc.  The value stored at the location pointed to by stat_loc shall be 0 if and only if
       the status returned is from a terminated child process that terminated by one of the following means:

        1. The process returned 0 from main().

        2. The process called _exit() or exit() with a status argument of 0.

        3. The process was terminated because the last thread in the process terminated.

       Regardless of its value, this information may be interpreted using the following macros, which are defined in <sys/wait.h> and evaluate to integral expressions; the stat_val argument is the inte‐
       ger value pointed to by stat_loc.

       WIFEXITED(stat_val)
             Evaluates to a non-zero value if status was returned for a child process that terminated normally.

       WEXITSTATUS(stat_val)
             If the value of WIFEXITED(stat_val) is non-zero, this macro evaluates to the low-order 8 bits of the status argument that the child process passed to _exit() or exit(),  or  the  value  the
             child process returned from main().

       WIFSIGNALED(stat_val)
             Evaluates to a non-zero value if status was returned for a child process that terminated due to the receipt of a signal that was not caught (see <signal.h>).

       WTERMSIG(stat_val)
             If the value of WIFSIGNALED(stat_val) is non-zero, this macro evaluates to the number of the signal that caused the termination of the child process.

       WIFSTOPPED(stat_val)
             Evaluates to a non-zero value if status was returned for a child process that is currently stopped.

       WSTOPSIG(stat_val)
             If the value of WIFSTOPPED(stat_val) is non-zero, this macro evaluates to the number of the signal that caused the child process to stop.

       WIFCONTINUED(stat_val)
             Evaluates to a non-zero value if status was returned for a child process that has continued from a job control stop.

       It  is unspecified whether the status value returned by calls to wait() or waitpid() for processes created by posix_spawn() or posix_spawnp() can indicate a WIFSTOPPED(stat_val) before subsequent
       calls to wait() or waitpid() indicate WIFEXITED(stat_val) as the result of an error detected before the new process image starts executing.

       It is unspecified whether the status value returned by calls to wait() or waitpid() for processes created by posix_spawn() or posix_spawnp() can indicate a WIFSIGNALED(stat_val) if  a  signal  is
       sent to the parent's process group after posix_spawn() or posix_spawnp() is called.

       If  the  information  pointed  to  by  stat_loc  was  stored  by  a  call  to waitpid() that specified the WUNTRACED flag and did not specify the WCONTINUED flag, exactly one of the macros WIFEX‐
       ITED(*stat_loc), WIFSIGNALED(*stat_loc), and WIFSTOPPED(*stat_loc) shall evaluate to a non-zero value.

       If the information pointed to by stat_loc was stored by a call to waitpid() that  specified  the  WUNTRACED  and  WCONTINUED  flags,  exactly  one  of  the  macros  WIFEXITED(*stat_loc),  WIFSIG‐
       NALED(*stat_loc), WIFSTOPPED(*stat_loc), and WIFCONTINUED(*stat_loc) shall evaluate to a non-zero value.

       If  the information pointed to by stat_loc was stored by a call to waitpid() that did not specify the WUNTRACED or WCONTINUED flags, or by a call to the wait() function, exactly one of the macros
       WIFEXITED(*stat_loc) and WIFSIGNALED(*stat_loc) shall evaluate to a non-zero value.

       If the information pointed to by stat_loc was stored by a call to waitpid() that did not specify the WUNTRACED  flag  and  specified  the  WCONTINUED  flag,  exactly  one  of  the  macros  WIFEX‐
       ITED(*stat_loc), WIFSIGNALED(*stat_loc), and WIFCONTINUED(*stat_loc) shall evaluate to a non-zero value.

       If  _POSIX_REALTIME_SIGNALS  is  defined,  and  the  implementation  queues the SIGCHLD signal, then if wait() or waitpid() returns because the status of a child process is available, any pending
       SIGCHLD signal associated with the process ID of the child process shall be discarded. Any other pending SIGCHLD signals shall remain pending.

       Otherwise, if SIGCHLD is blocked, if wait() or waitpid() return because the status of a child process is available, any pending SIGCHLD signal shall be cleared unless the status of another  child
       process is available.

       For all other conditions, it is unspecified whether child status will be available when a SIGCHLD signal is delivered.

       There  may be additional implementation-defined circumstances under which wait() or waitpid() report status.  This shall not occur unless the calling process or one of its child processes explic‐
       itly makes use of a non-standard extension. In these cases the interpretation of the reported status is implementation-defined.

       If a parent process terminates without waiting for all of its child processes to terminate, the remaining child processes shall be assigned a new parent process ID corresponding to an implementa‐
       tion-defined system process.

RETURN VALUE
       If  wait() or waitpid() returns because the status of a child process is available, these functions shall return a value equal to the process ID of the child process for which status is reported.
       If wait() or waitpid() returns due to the delivery of a signal to the calling process, -1 shall be returned and errno set to [EINTR].  If waitpid() was invoked with WNOHANG set in options, it has
       at  least  one  child process specified by pid for which status is not available, and status is not available for any process specified by pid, 0 is returned. Otherwise, -1 shall be returned, and
       errno set to indicate the error.

ERRORS
       The wait() function shall fail if:

       ECHILD The calling process has no existing unwaited-for child processes.

       EINTR  The function was interrupted by a signal. The value of the location pointed to by stat_loc is undefined.

       The waitpid() function shall fail if:

       ECHILD The process specified by pid does not exist or is not a child of the calling process, or the process group specified by pid does not exist or does not have any member  process  that  is  a
              child of the calling process.

       EINTR  The function was interrupted by a signal. The value of the location pointed to by stat_loc is undefined.

       EINVAL The options argument is not valid.

       The following sections are informative.

EXAMPLES
   Waiting for a Child Process and then Checking its Status
       The  following  example  demonstrates the use of waitpid(), fork(), and the macros used to interpret the status value returned by waitpid() (and wait()).  The code segment creates a child process
       which does some unspecified work. Meanwhile the parent loops performing calls to waitpid() to monitor the status of the child. The loop terminates when child termination is detected.

           #include <stdio.h>
           #include <stdlib.h>
           #include <unistd.h>
           #include <sys/wait.h>
           ...

           pid_t child_pid, wpid;
           int status;

           child_pid = fork();
           if (child_pid == -1) {      /* fork() failed */
               perror("fork");
               exit(EXIT_FAILURE);
           }

           if (child_pid == 0) {       /* This is the child */
               /* Child does some work and then terminates */
               ...

           } else {                    /* This is the parent */
               do {
                   wpid = waitpid(child_pid, &status, WUNTRACED
           #ifdef WCONTINUED       /* Not all implementations support this */
                   | WCONTINUED
           #endif
                   );
                   if (wpid == -1) {
                       perror("waitpid");
                       exit(EXIT_FAILURE);
                   }

                   if (WIFEXITED(status)) {
                       printf("child exited, status=%d\n", WEXITSTATUS(status));

                   } else if (WIFSIGNALED(status)) {
                       printf("child killed (signal %d)\n", WTERMSIG(status));

                   } else if (WIFSTOPPED(status)) {
                       printf("child stopped (signal %d)\n", WSTOPSIG(status));

           #ifdef WIFCONTINUED     /* Not all implementations support this */
                   } else if (WIFCONTINUED(status)) {
                       printf("child continued\n");
           #endif
                   } else {    /* Non-standard case -- may never happen */
                       printf("Unexpected status (0x%x)\n", status);
                   }
               } while (!WIFEXITED(status) && !WIFSIGNALED(status));
           }

   Waiting for a Child Process in a Signal Handler for SIGCHLD
       The following example demonstrates how to use waitpid() in a signal handler for SIGCHLD without passing -1 as the pid argument. (See the APPLICATION USAGE section below for the reasons why  pass‐
       ing a pid of -1 is not recommended.) The method used here relies on the standard behavior of waitpid() when SIGCHLD is blocked. On historical non-conforming systems, the status of some child pro‐
       cesses might not be reported.

           #include <stdlib.h>
           #include <stdio.h>
           #include <signal.h>
           #include <sys/types.h>
           #include <sys/wait.h>
           #include <unistd.h>

           #define CHILDREN 10

           static void
           handle_sigchld(int signum, siginfo_t *sinfo, void *unused)
           {
               int sav_errno = errno;
               int status;

               /*
                * Obtain status information for the child which
                * caused the SIGCHLD signal and write its exit code
                * to stdout.
               */
               if (sinfo->si_code != CLD_EXITED)
               {
                   static char msg[] = "wrong si_code\n";
                   write(2, msg, sizeof msg - 1);
               }
               else if (waitpid(sinfo->si_pid, &status, 0) == -1)
               {
                   static char msg[] = "waitpid() failed\n";
                   write(2, msg, sizeof msg - 1);
               }
               else if (!WIFEXITED(status))
               {
                   static char msg[] = "WIFEXITED was false\n";
                   write(2, msg, sizeof msg - 1);
               }
               else
               {
                   int code = WEXITSTATUS(status);
                   char buf[2];
                   buf[0] = '0' + code;
                   buf[1] = '\n';
                   write(1, buf, 2);
               }
               errno = sav_errno;
           }

           int
           main(void)
           {
               int i;
               pid_t pid;
               struct sigaction sa;

               sa.sa_flags = SA_SIGINFO;
               sa.sa_sigaction = handle_sigchld;
               sigemptyset(&sa.sa_mask);
               if (sigaction(SIGCHLD, &sa, NULL) == -1)
               {
                   perror("sigaction");
                   exit(EXIT_FAILURE);
               }

               for (i = 0; i < CHILDREN; i++)
               {
                   switch (pid = fork())
                   {
                   case -1:
                       perror("fork");
                       exit(EXIT_FAILURE);
                   case 0:
                       sleep(2);
                       _exit(i);
                   }
               }

               /* Wait for all the SIGCHLD signals, then terminate on SIGALRM */
               alarm(3);
               for (;;)
                   pause();

               return 0; /* NOTREACHED */
           }

APPLICATION USAGE
       Calls to wait() will collect information about any child process. This may result in interactions with other interfaces that may be waiting for their own children (such as by  use  of  system()).
       For this and other reasons it is recommended that portable applications not use wait(), but instead use waitpid().  For these same reasons, the use of waitpid() with a pid argument of -1, and the
       use of waitid() with the idtype argument set to P_ALL, are also not recommended for portable applications.

       As specified in Consequences of Process Termination, if the calling process has SA_NOCLDWAIT set or has SIGCHLD set to SIG_IGN, then the termination of a child process will not cause  status  in‐
       formation  to  become  available to a thread blocked in wait(), waitid(), or waitpid().  Thus, a thread blocked in one of the wait functions will remain blocked unless some other condition causes
       the thread to resume execution (such as an [ECHILD] failure due to no remaining children in the set of waited-for children).

RATIONALE
       A call to the wait() or waitpid() function only returns status on an immediate child process of the calling process; that is, a child that was produced by a single fork() call  (perhaps  followed
       by  an exec or other function calls) from the parent. If a child produces grandchildren by further use of fork(), none of those grandchildren nor any of their descendants affect the behavior of a
       wait() from the original parent process. Nothing in this volume of POSIX.1‐2017 prevents an implementation from providing extensions that permit a process to get status from a grandchild  or  any
       other process, but a process that does not use such extensions must be guaranteed to see status from only its direct children.

       The waitpid() function is provided for three reasons:

        1. To support job control

        2. To permit a non-blocking version of the wait() function

        3. To permit a library routine, such as system() or pclose(), to wait for its children without interfering with other terminated children for which the process has not waited

       The first two of these facilities are based on the wait3() function provided by 4.3 BSD. The function uses the options argument, which is equivalent to an argument to wait3().  The WUNTRACED flag
       is used only in conjunction with job control on systems supporting job control. Its name comes from 4.3 BSD and refers to the fact that there are two types of stopped processes in that  implemen‐
       tation:  processes  being  traced  via the ptrace() debugging facility and (untraced) processes stopped by job control signals. Since ptrace() is not part of this volume of POSIX.1‐2017, only the
       second type is relevant. The name WUNTRACED was retained because its usage is the same, even though the name is not intuitively meaningful in this context.

       The third reason for the waitpid() function is to permit independent sections of a process to spawn and wait for children without interfering with each other. For example, the  following  problem
       occurs in developing a portable shell, or command interpreter:

           stream = popen("/bin/true");
           (void) system("sleep 100");
           (void) pclose(stream);

       On all historical implementations, the final pclose() fails to reap the wait() status of the popen().

       The  status values are retrieved by macros, rather than given as specific bit encodings as they are in most historical implementations (and thus expected by existing programs). This was necessary
       to eliminate a limitation on the number of signals an implementation can support that was inherent in the traditional encodings. This volume of POSIX.1‐2017 does require that a  status  value  of
       zero corresponds to a process calling _exit(0), as this is the most common encoding expected by existing programs.  Some of the macro names were adopted from 4.3 BSD.

       These  macros syntactically operate on an arbitrary integer value. The behavior is undefined unless that value is one stored by a successful call to wait() or waitpid() in the location pointed to
       by the stat_loc argument. An early proposal attempted to make this clearer by specifying each argument as *stat_loc rather than stat_val.  However, that did not follow the  conventions  of  other
       specifications  in  this  volume  of POSIX.1‐2017 or traditional usage. It also could have implied that the argument to the macro must literally be *stat_loc; in fact, that value can be stored or
       passed as an argument to other functions before being interpreted by these macros.

       The extension that affects wait() and waitpid() and is common in historical implementations is the ptrace() function. It is called by a child process and causes that child to stop  and  return  a
       status  that appears identical to the status indicated by WIFSTOPPED.  The status of ptrace() children is traditionally returned regardless of the WUNTRACED flag (or by the wait() function). Most
       applications do not need to concern themselves with such extensions because they have control over what extensions they or their children use. However, applications, such as command interpreters,
       that invoke arbitrary processes may see this behavior when those arbitrary processes misuse such extensions.

       Implementations  that  support core file creation or other implementation-defined actions on termination of some processes traditionally provide a bit in the status returned by wait() to indicate
       that such actions have occurred.

       Allowing the wait() family of functions to discard a pending SIGCHLD signal that is associated with a successfully waited-for child process puts them into the sigwait() and sigwaitinfo() category
       with respect to SIGCHLD.

       This  definition allows implementations to treat a pending SIGCHLD signal as accepted by the process in wait(), with the same meaning of ``accepted'' as when that word is applied to the sigwait()
       family of functions.

       Allowing the wait() family of functions to behave this way permits an implementation to be able to deal precisely with SIGCHLD signals.

       In particular, an implementation that does accept (discard) the SIGCHLD signal can make the following guarantees regardless of the queuing depth of signals in general (the list of waitable  chil‐
       dren can hold the SIGCHLD queue):

        1. If  a  SIGCHLD signal handler is established via sigaction() without the SA_RESETHAND flag, SIGCHLD signals can be accurately counted; that is, exactly one SIGCHLD signal will be delivered to
           or accepted by the process for every child process that terminates.

        2. A single wait() issued from a SIGCHLD signal handler can be guaranteed to return immediately with status information for a child process.

        3. When SA_SIGINFO is requested, the SIGCHLD signal handler can be guaranteed to receive a non-null pointer to a siginfo_t structure that describes a child process for which a wait via waitpid()
           or waitid() will not block or fail.

        4. The system() function will not cause the SIGCHLD handler of a process to be called as a result of the fork()/exec executed within system() because system() will accept the SIGCHLD signal when
           it performs a waitpid() for its child process. This is a desirable behavior of system() so that it can be used in a library without causing side-effects to the application linked with the li‐
           brary.

       An  implementation that does not permit the wait() family of functions to accept (discard) a pending SIGCHLD signal associated with a successfully waited-for child, cannot make the guarantees de‐
       scribed above for the following reasons:

       Guarantee #1
             Although it might be assumed that reliable queuing of all SIGCHLD signals generated by the system can make this guarantee, the counter-example is the case of a process that  blocks  SIGCHLD
             and  performs  an  indefinite loop of fork()/wait() operations. If the implementation supports queued signals, then eventually the system will run out of memory for the queue. The guarantee
             cannot be made because there must be some limit to the depth of queuing.

       Guarantees #2 and #3
             These cannot be guaranteed unless the wait() family of functions accepts the SIGCHLD signal. Otherwise, a fork()/wait() executed while SIGCHLD is blocked (as in the system() function)  will
             result in an invocation of the handler when SIGCHLD is unblocked, after the process has disappeared.

       Guarantee #4
             Although  possible  to  make this guarantee, system() would have to set the SIGCHLD handler to SIG_DFL so that the SIGCHLD signal generated by its fork() would be discarded (the SIGCHLD de‐
             fault action is to be ignored), then restore it to its previous setting. This would have the undesirable side-effect of discarding all SIGCHLD signals pending to the process.

FUTURE DIRECTIONS
       None.

SEE ALSO
       Section 2.13, Status Information, exec, exit(), fork(), system(), waitid()

       The Base Definitions volume of POSIX.1‐2017, Section 4.12, Memory Synchronization, <signal.h>, <sys_wait.h>

COPYRIGHT
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group
       Base  Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any discrepancy between this ver‐
       sion and the original IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be  obtained  online  at  http://www.open‐
       group.org/unix/online.html .

       Any  typographical  or  formatting errors that appear in this page are most likely to have been introduced during the conversion of the source files to man page format. To report such errors, see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                                                                2017                                                                                           WAIT(3P)
wait(2)                                                                                     System Calls Manual                                                                                    wait(2)

NAME
       wait, waitpid, waitid - wait for process to change state

LIBRARY
       Standard C library (libc, -lc)

SYNOPSIS
       #include <sys/wait.h>

       pid_t wait(int *_Nullable wstatus);
       pid_t waitpid(pid_t pid, int *_Nullable wstatus, int options);

       int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
                       /* This is the glibc and POSIX interface; see
                          NOTES for information on the raw system call. */

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       waitid():
           Since glibc 2.26:
               _XOPEN_SOURCE >= 500 || _POSIX_C_SOURCE >= 200809L
           glibc 2.25 and earlier:
               _XOPEN_SOURCE
                   || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L
                   || /* glibc <= 2.19: */ _BSD_SOURCE

DESCRIPTION
       All  of  these  system calls are used to wait for state changes in a child of the calling process, and obtain information about the child whose state has changed.  A state change is considered to
       be: the child terminated; the child was stopped by a signal; or the child was resumed by a signal.  In the case of a terminated child, performing a wait allows the system to release the resources
       associated with the child; if a wait is not performed, then the terminated child remains in a "zombie" state (see NOTES below).

       If  a child has already changed state, then these calls return immediately.  Otherwise, they block until either a child changes state or a signal handler interrupts the call (assuming that system
       calls are not automatically restarted using the SA_RESTART flag of sigaction(2)).  In the remainder of this page, a child whose state has changed and which has not yet been waited upon by one  of
       these system calls is termed waitable.

   wait() and waitpid()
       The wait() system call suspends execution of the calling thread until one of its children terminates.  The call wait(&wstatus) is equivalent to:

           waitpid(-1, &wstatus, 0);

       The  waitpid()  system call suspends execution of the calling thread until a child specified by pid argument has changed state.  By default, waitpid() waits only for terminated children, but this
       behavior is modifiable via the options argument, as described below.

       The value of pid can be:

       < -1   meaning wait for any child process whose process group ID is equal to the absolute value of pid.

       -1     meaning wait for any child process.

       0      meaning wait for any child process whose process group ID is equal to that of the calling process at the time of the call to waitpid().

       > 0    meaning wait for the child whose process ID is equal to the value of pid.

       The value of options is an OR of zero or more of the following constants:

       WNOHANG
              return immediately if no child has exited.

       WUNTRACED
              also return if a child has stopped (but not traced via ptrace(2)).  Status for traced children which have stopped is provided even if this option is not specified.

       WCONTINUED (since Linux 2.6.10)
              also return if a stopped child has been resumed by delivery of SIGCONT.

       (For Linux-only options, see below.)

       If wstatus is not NULL, wait() and waitpid() store status information in the int to which it points.  This integer can be inspected with the following macros (which take the integer itself as  an
       argument, not a pointer to it, as is done in wait() and waitpid()!):

       WIFEXITED(wstatus)
              returns true if the child terminated normally, that is, by calling exit(3) or _exit(2), or by returning from main().

       WEXITSTATUS(wstatus)
              returns the exit status of the child.  This consists of the least significant 8 bits of the status argument that the child specified in a call to exit(3) or _exit(2) or as the argument for
              a return statement in main().  This macro should be employed only if WIFEXITED returned true.

       WIFSIGNALED(wstatus)
              returns true if the child process was terminated by a signal.

       WTERMSIG(wstatus)
              returns the number of the signal that caused the child process to terminate.  This macro should be employed only if WIFSIGNALED returned true.

       WCOREDUMP(wstatus)
              returns true if the child produced a core dump (see core(5)).  This macro should be employed only if WIFSIGNALED returned true.

              This macro is not specified in POSIX.1-2001 and is not available on some UNIX implementations (e.g., AIX, SunOS).  Therefore, enclose its use inside #ifdef WCOREDUMP ... #endif.

       WIFSTOPPED(wstatus)
              returns true if the child process was stopped by delivery of a signal; this is possible only if the call was done using WUNTRACED or when the child is being traced (see ptrace(2)).

       WSTOPSIG(wstatus)
              returns the number of the signal which caused the child to stop.  This macro should be employed only if WIFSTOPPED returned true.

       WIFCONTINUED(wstatus)
              (since Linux 2.6.10) returns true if the child process was resumed by delivery of SIGCONT.

   waitid()
       The waitid() system call (available since Linux 2.6.9) provides more precise control over which child state changes to wait for.

       The idtype and id arguments select the child(ren) to wait for, as follows:

       idtype == P_PID
              Wait for the child whose process ID matches id.

       idtype == P_PIDFD (since Linux 5.4)
              Wait for the child referred to by the PID file descriptor specified in id.  (See pidfd_open(2) for further information on PID file descriptors.)

       idtype == P_PGID
              Wait for any child whose process group ID matches id.  Since Linux 5.4, if id is zero, then wait for any child that is in the same process group as the caller's process group at  the  time
              of the call.

       idtype == P_ALL
              Wait for any child; id is ignored.

       The child state changes to wait for are specified by ORing one or more of the following flags in options:

       WEXITED
              Wait for children that have terminated.

       WSTOPPED
              Wait for children that have been stopped by delivery of a signal.

       WCONTINUED
              Wait for (previously stopped) children that have been resumed by delivery of SIGCONT.

       The following flags may additionally be ORed in options:

       WNOHANG
              As for waitpid().

       WNOWAIT
              Leave the child in a waitable state; a later wait call can be used to again retrieve the child status information.

       Upon successful return, waitid() fills in the following fields of the siginfo_t structure pointed to by infop:

       si_pid The process ID of the child.

       si_uid The real user ID of the child.  (This field is not set on most other implementations.)

       si_signo
              Always set to SIGCHLD.

       si_status
              Either the exit status of the child, as given to _exit(2) (or exit(3)), or the signal that caused the child to terminate, stop, or continue.  The si_code field can be used to determine how
              to interpret this field.

       si_code
              Set to one of: CLD_EXITED (child called _exit(2)); CLD_KILLED (child killed by signal); CLD_DUMPED (child killed by signal,  and  dumped  core);  CLD_STOPPED  (child  stopped  by  signal);
              CLD_TRAPPED (traced child has trapped); or CLD_CONTINUED (child continued by SIGCONT).

       If WNOHANG was specified in options and there were no children in a waitable state, then waitid() returns 0 immediately and the state of the siginfo_t structure pointed to by infop depends on the
       implementation.  To (portably) distinguish this case from that where a child was in a waitable state, zero out the si_pid field before the call and check for a nonzero value in this  field  after
       the call returns.

       POSIX.1-2008 Technical Corrigendum 1 (2013) adds the requirement that when WNOHANG is specified in options and there were no children in a waitable state, then waitid() should zero out the si_pid
       and si_signo fields of the structure.  On Linux and other implementations that adhere to this requirement, it is not necessary to zero out the si_pid field before calling waitid().  However,  not
       all implementations follow the POSIX.1 specification on this point.

RETURN VALUE
       wait(): on success, returns the process ID of the terminated child; on failure, -1 is returned.

       waitpid():  on  success,  returns  the process ID of the child whose state has changed; if WNOHANG was specified and one or more child(ren) specified by pid exist, but have not yet changed state,
       then 0 is returned.  On failure, -1 is returned.

       waitid(): returns 0 on success or if WNOHANG was specified and no child(ren) specified by id has yet changed state; on failure, -1 is returned.

       On failure, each of these calls sets errno to indicate the error.

ERRORS
       EAGAIN The PID file descriptor specified in id is nonblocking and the process that it refers to has not terminated.

       ECHILD (for wait()) The calling process does not have any unwaited-for children.

       ECHILD (for waitpid() or waitid()) The process specified by pid (waitpid()) or idtype and id (waitid()) does not exist or is not a child of the calling process.  (This can happen  for  one's  own
              child if the action for SIGCHLD is set to SIG_IGN.  See also the Linux Notes section about threads.)

       EINTR  WNOHANG was not set and an unblocked signal or a SIGCHLD was caught; see signal(7).

       EINVAL The options argument was invalid.

       ESRCH  (for wait() or waitpid()) pid is equal to INT_MIN.

VERSIONS
   C library/kernel differences
       wait() is actually a library function that (in glibc) is implemented as a call to wait4(2).

       On some architectures, there is no waitpid() system call; instead, this interface is implemented via a C library wrapper function that calls wait4(2).

       The raw waitid() system call takes a fifth argument, of type struct rusage *.  If this argument is non-NULL, then it is used to return resource usage information about the child, in the same man‐
       ner as wait4(2).  See getrusage(2) for details.

STANDARDS
       POSIX.1-2008.

HISTORY
       SVr4, 4.3BSD, POSIX.1-2001.

NOTES
       A child that terminates, but has not been waited for becomes a "zombie".  The kernel maintains a minimal set of information about the zombie process (PID, termination status, resource  usage  in‐
       formation)  in  order  to allow the parent to later perform a wait to obtain information about the child.  As long as a zombie is not removed from the system via a wait, it will consume a slot in
       the kernel process table, and if this table fills, it will not be possible to create further processes.  If a parent process terminates, then  its  "zombie"  children  (if  any)  are  adopted  by
       init(1), (or by the nearest "subreaper" process as defined through the use of the prctl(2) PR_SET_CHILD_SUBREAPER operation); init(1) automatically performs a wait to remove the zombies.

       POSIX.1-2001  specifies that if the disposition of SIGCHLD is set to SIG_IGN or the SA_NOCLDWAIT flag is set for SIGCHLD (see sigaction(2)), then children that terminate do not become zombies and
       a call to wait() or waitpid() will block until all children have terminated, and then fail with errno set to ECHILD.  (The original POSIX standard left the behavior of setting SIGCHLD to  SIG_IGN
       unspecified.  Note that even though the default disposition of SIGCHLD is "ignore", explicitly setting the disposition to SIG_IGN results in different treatment of zombie process children.)

       Linux  2.6  conforms  to  the POSIX requirements.  However, Linux 2.4 (and earlier) does not: if a wait() or waitpid() call is made while SIGCHLD is being ignored, the call behaves just as though
       SIGCHLD were not being ignored, that is, the call blocks until the next child terminates and then returns the process ID and status of that child.

   Linux notes
       In the Linux kernel, a kernel-scheduled thread is not a distinct construct from a process.  Instead, a thread is simply a process that is created using  the  Linux-unique  clone(2)  system  call;
       other  routines such as the portable pthread_create(3) call are implemented using clone(2).  Before Linux 2.4, a thread was just a special case of a process, and as a consequence one thread could
       not wait on the children of another thread, even when the latter belongs to the same thread group.  However, POSIX prescribes such functionality, and since Linux 2.4 a thread can, and by  default
       will, wait on children of other threads in the same thread group.

       The following Linux-specific options are for use with children created using clone(2); they can also, since Linux 4.7, be used with waitid():

       __WCLONE
              Wait  for  "clone" children only.  If omitted, then wait for "non-clone" children only.  (A "clone" child is one which delivers no signal, or a signal other than SIGCHLD to its parent upon
              termination.)  This option is ignored if __WALL is also specified.

       __WALL (since Linux 2.4)
              Wait for all children, regardless of type ("clone" or "non-clone").

       __WNOTHREAD (since Linux 2.4)
              Do not wait for children of other threads in the same thread group.  This was the default before Linux 2.4.

       Since Linux 4.7, the __WALL flag is automatically implied if the child is being ptraced.

BUGS
       According to POSIX.1-2008, an application calling waitid() must ensure that infop points to a siginfo_t structure (i.e., that it is a non-null pointer).  On Linux, if infop is NULL, waitid() suc‐
       ceeds, and returns the process ID of the waited-for child.  Applications should avoid relying on this inconsistent, nonstandard, and unnecessary feature.

EXAMPLES
       The following program demonstrates the use of fork(2) and waitpid().  The program creates a child process.  If no command-line argument is supplied to the program, then the child suspends its ex‐
       ecution using pause(2), to allow the user to send signals to the child.  Otherwise, if a command-line argument is supplied, then the child exits immediately, using the  integer  supplied  on  the
       command line as the exit status.  The parent process executes a loop that monitors the child using waitpid(), and uses the W*() macros described above to analyze the wait status value.

       The following shell session demonstrates the use of the program:

           $ ./a.out &
           Child PID is 32360
           [1] 32359
           $ kill -STOP 32360
           stopped by signal 19
           $ kill -CONT 32360
           continued
           $ kill -TERM 32360
           killed by signal 15
           [1]+  Done                    ./a.out
           $

   Program source

       #include <stdint.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/wait.h>
       #include <unistd.h>

       int
       main(int argc, char *argv[])
       {
           int    wstatus;
           pid_t  cpid, w;

           cpid = fork();
           if (cpid == -1) {
               perror("fork");
               exit(EXIT_FAILURE);
           }

           if (cpid == 0) {            /* Code executed by child */
               printf("Child PID is %jd\n", (intmax_t) getpid());
               if (argc == 1)
                   pause();                    /* Wait for signals */
               _exit(atoi(argv[1]));

           } else {                    /* Code executed by parent */
               do {
                   w = waitpid(cpid, &wstatus, WUNTRACED | WCONTINUED);
                   if (w == -1) {
                       perror("waitpid");
                       exit(EXIT_FAILURE);
                   }

                   if (WIFEXITED(wstatus)) {
                       printf("exited, status=%d\n", WEXITSTATUS(wstatus));
                   } else if (WIFSIGNALED(wstatus)) {
                       printf("killed by signal %d\n", WTERMSIG(wstatus));
                   } else if (WIFSTOPPED(wstatus)) {
                       printf("stopped by signal %d\n", WSTOPSIG(wstatus));
                   } else if (WIFCONTINUED(wstatus)) {
                       printf("continued\n");
                   }
               } while (!WIFEXITED(wstatus) && !WIFSIGNALED(wstatus));
               exit(EXIT_SUCCESS);
           }
       }

SEE ALSO
       _exit(2), clone(2), fork(2), kill(2), ptrace(2), sigaction(2), signal(2), wait4(2), pthread_create(3), core(5), credentials(7), signal(7)

Linux man-pages 6.04                                                                            2023-03-30                                                                                         wait(2)
FORK(3am)                                                                                GNU Awk Extension Modules                                                                               FORK(3am)

NAME
       fork, wait, waitpid - basic process management

SYNOPSIS
       @load "fork"

       pid = fork()

       ret = waitpid(pid)

       ret = wait();

DESCRIPTION
       The fork extension adds three functions, as follows.

       fork() This  function  creates a new process. The return value is the zero in the child and the process-id number of the child in the parent, or -1 upon error. In the latter case, ERRNO indicates
              the problem.  In the child, PROCINFO["pid"] and PROCINFO["ppid"] are updated to reflect the correct values.

       waitpid()
              This function takes a numeric argument, which is the process-id to wait for. The return value is that of the waitpid(2) system call.

       wait() This function waits for the first child to die.  The return value is that of the wait(2) system call.

BUGS
       There is no corresponding exec() function.

       The interfaces could be enhanced to provide more facilities, including pulling out the various bits of the return status.

EXAMPLE
       @load "fork"
       ...
       if ((pid = fork()) == 0)
           print "hello from the child"
       else
           print "hello from the parent"

SEE ALSO
       GAWK: Effective AWK Programming, filefuncs(3am), fnmatch(3am), inplace(3am), ordchr(3am), readdir(3am), readfile(3am), revoutput(3am), rwarray(3am), time(3am).

       fork(2), wait(2), waitpid(2).

AUTHOR
       Arnold Robbins, arnold@skeeve.com.

COPYING PERMISSIONS
       Copyright © 2012, 2013, 2018, Free Software Foundation, Inc.

       Permission is granted to make and distribute verbatim copies of this manual page provided the copyright notice and this permission notice are preserved on all copies.

       Permission is granted to copy and distribute modified versions of this manual page under the conditions for verbatim copying, provided that the entire resulting derived work is distributed  under
       the terms of a permission notice identical to this one.

       Permission  is  granted  to copy and distribute translations of this manual page into another language, under the above conditions for modified versions, except that this permission notice may be
       stated in a translation approved by the Foundation.

Free Software Foundation                                                                        Feb 02 2018                                                                                      FORK(3am)
