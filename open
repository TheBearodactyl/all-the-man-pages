open(n)                                                                                    Tcl Built-In Commands                                                                                   open(n)

__________________________________________________________________________________________________________________________________________________________________________________________________________

NAME
       open - Open a file-based or command pipeline channel

SYNOPSIS
       open fileName
       open fileName access
       open fileName access permissions
__________________________________________________________________________________________________________________________________________________________________________________________________________

DESCRIPTION
       This command opens a file, serial port, or command pipeline and returns a channel identifier that may be used in future invocations of commands like read, puts, and close.  If the first character
       of fileName is not | then the command opens a file: fileName gives the name of the file to open, and it must conform to the conventions described in the filename manual entry.

       The access argument, if present, indicates the way in which the file (or command pipeline) is to be accessed.  In the first form access may have any of the following values:

       r              Open the file for reading only; the file must already exist. This is the default value if access is not specified.

       r+             Open the file for both reading and writing; the file must already exist.

       w              Open the file for writing only.  Truncate it if it exists.  If it does not exist, create a new file.

       w+             Open the file for reading and writing.  Truncate it if it exists.  If it does not exist, create a new file.

       a              Open the file for writing only.  If the file does not exist, create a new empty file.  Set the file pointer to the end of the file prior to each write.

       a+             Open the file for reading and writing.  If the file does not exist, create a new empty file.  Set the initial access position  to the end of the file.

       All of the legal access values above may have the character b added as the second or third character in the value to indicate that the opened channel should be configured as if with the  fconfig‐
       ure -translation binary option, making the channel suitable for reading or writing of binary data.

       In the second form, access consists of a list of any of the following flags, most of which have the standard POSIX meanings.  One of the flags must be either RDONLY, WRONLY or RDWR.

       RDONLY         Open the file for reading only.

       WRONLY         Open the file for writing only.

       RDWR           Open the file for both reading and writing.

       APPEND         Set the file pointer to the end of the file prior to each write.

       BINARY         Configure the opened channel with the -translation binary option.

       CREAT          Create the file if it does not already exist (without this flag it is an error for the file not to exist).

       EXCL           If CREAT is also specified, an error is returned if the file already exists.

       NOCTTY         If the file is a terminal device, this flag prevents the file from becoming the controlling terminal of the process.

       NONBLOCK       Prevents  the process from blocking while opening the file, and possibly in subsequent I/O operations.  The exact behavior of this flag is system- and device-dependent;  its use is
                      discouraged (it is better to use the fconfigure command to put a file in nonblocking mode).  For details refer to your system documentation on the  open  system  call's  O_NONBLOCK
                      flag.

       TRUNC          If the file exists it is truncated to zero length.

       If  a  new  file is created as part of opening it, permissions (an integer) is used to set the permissions for the new file in conjunction with the process's file mode creation mask.  Permissions
       defaults to 0666.

COMMAND PIPELINES
       If the first character of fileName is “|” then the remaining characters of fileName are treated as a list of arguments that describe a command pipeline to invoke, in the same style as  the  argu‐
       ments  for exec.  In this case, the channel identifier returned by open may be used to write to the command's input pipe or read from its output pipe, depending on the value of access.  If write-
       only access is used (e.g. access is “w”), then standard output for the pipeline is directed to the current standard output unless overridden by the command.  If read-only access is used (e.g. ac‐
       cess  is “r”), standard input for the pipeline is taken from the current standard input unless overridden by the command.  The id of the spawned process is accessible through the pid command, us‐
       ing the channel id returned by open as argument.

       If the command (or one of the commands) executed in the command pipeline returns an error (according to the definition in exec), a Tcl error is generated when close is called on the  channel  un‐
       less the pipeline is in non-blocking mode then no exit status is returned (a silent close with -blocking 0).

       It is often useful to use the fileevent command with pipelines so other processing may happen at the same time as running the command in the background.

SERIAL COMMUNICATIONS
       If  fileName refers to a serial port, then the specified serial port is opened and initialized in a platform-dependent manner.  Acceptable values for the fileName to use to open a serial port are
       described in the PORTABILITY ISSUES section.

       The fconfigure command can be used to query and set additional configuration options specific to serial ports (where supported):

       -mode baud,parity,data,stop
              This option is a set of 4 comma-separated values: the baud rate, parity, number of data bits, and number of stop bits for this serial port.  The baud rate is a simple integer  that  speci‐
              fies  the  connection  speed.   Parity is one of the following letters: n, o, e, m, s; respectively signifying the parity options of “none”, “odd”, “even”, “mark”, or “space”.  Data is the
              number of data bits and should be an integer from 5 to 8, while stop is the number of stop bits and should be the integer 1 or 2.

       -handshake type
              (Windows and Unix). This option is used to setup automatic handshake control. Note that not all handshake types maybe supported by your operating system. The type parameter  is  case-inde‐
              pendent.

              If  type  is  none  then  any handshake is switched off.  rtscts activates hardware handshake. Hardware handshake signals are described below.  For software handshake xonxoff the handshake
              characters can be redefined with -xchar.  An additional hardware handshake dtrdsr is available only under Windows.  There is no default handshake configuration, the initial  value  depends
              on your operating system settings.  The -handshake option cannot be queried.

       -queue (Windows and Unix). The -queue option can only be queried.  It returns a list of two integers representing the current number of bytes in the input and output queue respectively.

       -timeout msec
              (Windows  and  Unix).  This  option is used to set the timeout for blocking read operations. It specifies the maximum interval between the reception of two bytes in milliseconds.  For Unix
              systems the granularity is 100 milliseconds.  The -timeout option does not affect write operations or nonblocking reads.  This option cannot be queried.

       -ttycontrol {signal boolean signal boolean ...}
              (Windows and Unix). This option is used to setup the handshake output lines (see below) permanently or to send a BREAK over the serial line.  The signal names are case-independent.  {RTS 1
              DTR  0} sets the RTS output to high and the DTR output to low.  The BREAK condition (see below) is enabled and disabled with {BREAK 1} and {BREAK 0} respectively.  It is not a good idea to
              change the RTS (or DTR) signal with active hardware handshake rtscts (or dtrdsr).  The result is unpredictable.  The -ttycontrol option cannot be queried.

       -ttystatus
              (Windows and Unix). The -ttystatus option can only be queried.  It returns the current modem status and handshake input signals (see below).  The result is a  list  of  signal,value  pairs
              with a fixed order, e.g. {CTS 1 DSR 0 RING 1 DCD 0}.  The signal names are returned upper case.

       -xchar {xonChar xoffChar}
              (Windows  and  Unix).  This  option is used to query or change the software handshake characters. Normally the operating system default should be DC1 (0x11) and DC3 (0x13) representing the
              ASCII standard XON and XOFF characters.

       -pollinterval msec
              (Windows only). This option is used to set the maximum time between polling for fileevents.  This affects the time interval between checking for events throughout the Tcl interpreter  (the
              smallest value always wins).  Use this option only if you want to poll the serial port more or less often than 10 msec (the default).

       -sysbuffer inSize

       -sysbuffer {inSize outSize}
              (Windows  only). This option is used to change the size of Windows system buffers for a serial channel. Especially at higher communication rates the default input buffer size of 4096 bytes
              can overrun for latent systems. The first form specifies the input buffer size, in the second form both input and output buffers are defined.

       -lasterror
              (Windows only). This option is query only.  In case of a serial communication error, read or puts returns a general Tcl file I/O error.  fconfigure -lasterror can be called to get  a  list
              of error details.  See below for an explanation of the various error codes.

SERIAL PORT SIGNALS
       RS-232  is the most commonly used standard electrical interface for serial communications. A negative voltage (-3V..-12V) define a mark (on=1) bit and a positive voltage (+3..+12V) define a space
       (off=0) bit (RS-232C).  The following signals are specified for incoming and outgoing data, status lines and handshaking. Here we are using the terms workstation for your computer and  modem  for
       the external device, because some signal names (DCD, RI) come from modems. Of course your external device may use these signal lines for other purposes.

       TXD(output)
              Transmitted Data: Outgoing serial data.

       RXD(input)
              Received Data:Incoming serial data.

       RTS(output)
              Request  To  Send:  This hardware handshake line informs the modem that your workstation is ready to receive data. Your workstation may automatically reset this signal to indicate that the
              input buffer is full.

       CTS(input)
              Clear To Send: The complement to RTS. Indicates that the modem is ready to receive data.

       DTR(output)
              Data Terminal Ready: This signal tells the modem that the workstation is ready to establish a link. DTR is often enabled automatically whenever a serial port is opened.

       DSR(input)
              Data Set Ready: The complement to DTR. Tells the workstation that the modem is ready to establish a link.

       DCD(input)
              Data Carrier Detect: This line becomes active when a modem detects a “Carrier” signal.

       RI(input)
              Ring Indicator: Goes active when the modem detects an incoming call.

       BREAK  A BREAK condition is not a hardware signal line, but a logical zero on the TXD or RXD lines for a long period of time, usually 250 to 500 milliseconds.  Normally a receive or transmit data
              signal  stays  at the mark (on=1) voltage until the next character is transferred. A BREAK is sometimes used to reset the communications line or change the operating mode of communications
              hardware.

ERROR CODES (Windows only)
       A lot of different errors may occur during serial read operations or during event polling in background. The external device may have been switched off, the data lines may be noisy,  system  buf‐
       fers may overrun or your mode settings may be wrong.  That is why a reliable software should always catch serial read operations.  In cases of an error Tcl returns a general file I/O error.  Then
       fconfigure -lasterror may help to locate the problem.  The following error codes may be returned.

       RXOVER    Windows input buffer overrun. The data comes faster than your scripts reads it or your system is overloaded. Use fconfigure -sysbuffer to avoid a temporary bottleneck and/or  make  your
                 script faster.

       TXFULL    Windows output buffer overrun. Complement to RXOVER. This error should practically not happen, because Tcl cares about the output buffer status.

       OVERRUN   UART  buffer  overrun  (hardware)  with data lost.  The data comes faster than the system driver receives it.  Check your advanced serial port settings to enable the FIFO (16550) buffer
                 and/or setup a lower(1) interrupt threshold value.

       RXPARITY  A parity error has been detected by your UART.  Wrong parity settings with fconfigure -mode or a noisy data line (RXD) may cause this error.

       FRAME     A stop-bit error has been detected by your UART.  Wrong mode settings with fconfigure -mode or a noisy data line (RXD) may cause this error.

       BREAK     A BREAK condition has been detected by your UART (see above).

PORTABILITY ISSUES
       Windows
              Valid values for fileName to open a serial port are of the form comX, where X is a number, generally from 1 to 9.  A legacy form accepted as well is comX:. This notation only works for se‐
              rial  ports  from  1 to 9.  An attempt to open a serial port that does not exist or has a number greater than 9 will fail.  An alternate form of opening serial ports is to use the filename
              //./comX, where X is any number that corresponds to a serial port.

              When running Tcl interactively, there may be some strange interactions between the real console, if one is present, and a command pipeline that uses standard input or output.  If a command
              pipeline  is  opened for reading, some of the lines entered at the console will be sent to the command pipeline and some will be sent to the Tcl evaluator.  If a command pipeline is opened
              for writing, keystrokes entered into the console are not visible until the pipe is closed.  These problems only occur because both Tcl and the child application are competing for the  con‐
              sole at the same time.  If the command pipeline is started from a script, so that Tcl is not accessing the console, or if the command pipeline does not use standard input or output, but is
              redirected from or to a file, then the above problems do not occur.

              Files opened in the “a” mode or with the APPEND flag set are implemented by seeking immediately before each write, which is not an atomic operation and does  not  carry  the  guarantee  of
              strict appending that is present on POSIX platforms.

       Unix
              Valid  values  for  fileName to open a serial port are generally of the form /dev/ttyX, where X is a or b, but the name of any pseudo-file that maps to a serial port may be used.  Advanced
              configuration options are only supported for serial ports when Tcl is built to use the POSIX serial interface.

              When running Tcl interactively, there may be some strange interactions between the console, if one is present, and a command pipeline that uses standard input.  If a  command  pipeline  is
              opened for reading, some of the lines entered at the console will be sent to the command pipeline and some will be sent to the Tcl evaluator.  This problem only occurs because both Tcl and
              the child application are competing for the console at the same time.  If the command pipeline is started from a script, so that Tcl is not accessing the console, or if the  command  pipe‐
              line does not use standard input, but is redirected from a file, then the above problem does not occur.

       See the PORTABILITY ISSUES section of the exec command for additional information not specific to command pipelines about executing applications on the various platforms

EXAMPLES
       Open a file for writing, forcing it to be created and raising an error if it already exists.

              set myNewFile [open filename.txt {WRONLY CREAT EXCL}]

       Open a file for writing as a log file.

              set myLogFile [open filename.log "a"]
              fconfigure $myLogFile -buffering line

       Open a command pipeline and catch any errors:

              set fl [open "| ls this_file_does_not_exist"]
              set data [read $fl]
              if {[catch {close $fl} err]} {
                  puts "ls command failed: $err"
              }

       Open a command pipeline and read binary data from it. Note the unusual form with “|[list” that handles non-trivial edge cases with arguments that potentially have spaces in.

              set fl [open |[list create_image_data $input] "rb"]
              set binData [read $fl]
              close $fl

SEE ALSO
       file(n), close(n), filename(n), fconfigure(n), gets(n), read(n), puts(n), exec(n), pid(n), fopen(3)

KEYWORDS
       access mode, append, create, file, non-blocking, open, permissions, pipeline, process, serial

Tcl                                                                                                 8.3                                                                                            open(n)
open(3perl)                                                                          Perl Programmers Reference Guide                                                                          open(3perl)

NAME
       open - perl pragma to set default PerlIO layers for input and output

SYNOPSIS
           use open IN  => ':crlf', OUT => ':raw';
           open my $in, '<', 'foo.txt' or die "open failed: $!";
           my $line = <$in>; # CRLF translated
           close $in;
           open my $out, '>', 'bar.txt' or die "open failed: $!";
           print $out $line; # no translation of bytes
           close $out;

           use open OUT => ':encoding(UTF-8)';
           use open IN  => ':encoding(iso-8859-7)';

           use open IO  => ':locale';

           # IO implicit only for :utf8, :encoding, :locale
           use open ':encoding(UTF-8)';
           use open ':encoding(iso-8859-7)';
           use open ':locale';

           # with :std, also affect global standard handles
           use open ':std', ':encoding(UTF-8)';
           use open ':std', OUT => ':encoding(cp1252)';
           use open ':std', IO => ':raw :encoding(UTF-16LE)';

DESCRIPTION
       Full-fledged support for I/O layers is now implemented provided Perl is configured to use PerlIO as its IO system (which has been the default since 5.8, and the only supported configuration since
       5.16).

       The "open" pragma serves as one of the interfaces to declare default "layers" (previously known as "disciplines") for all I/O. Any open(), readpipe() (aka qx//) and similar operators found within
       the lexical scope of this pragma will use the declared defaults via the "${^OPEN}" variable.

       Layers are specified with a leading colon by convention. You can specify a stack of multiple layers as a space-separated string.  See PerlIO for more information on the available layers.

       With the "IN" subpragma you can declare the default layers of input streams, and with the "OUT" subpragma you can declare the default layers of output streams.  With the "IO" subpragma (may be
       omitted for ":utf8", ":locale", or ":encoding") you can control both input and output streams simultaneously.

       When open() is given an explicit list of layers (with the three-arg syntax), they override the list declared using this pragma.  open() can also be given a single colon (:) for a layer name, to
       override this pragma and use the default as detailed in "Defaults and how to override them" in PerlIO.

       To translate from and to an arbitrary text encoding, use the ":encoding" layer.  The matching of encoding names in ":encoding" is loose: case does not matter, and many encodings have several
       aliases.  See Encode::Supported for details and the list of supported locales.

       If you want to set your encoding layers based on your locale environment variables, you can use the ":locale" pseudo-layer.  For example:

           $ENV{LANG} = 'ru_RU.KOI8-R';
           # the :locale will probe the locale environment variables like LANG
           use open OUT => ':locale';
           open(my $out, '>', 'koi8') or die "open failed: $!";
           print $out chr(0x430); # CYRILLIC SMALL LETTER A = KOI8-R 0xc1
           close $out;
           open(my $in, '<', 'koi8') or die "open failed: $!";
           printf "%#x\n", ord(<$in>); # this should print 0xc1
           close $in;

       The logic of ":locale" is described in full in "The ":locale" sub-pragma" in encoding, but in short it is first trying nl_langinfo(CODESET) and then guessing from the LC_ALL and LANG locale
       environment variables.  ":locale" also implicitly turns on ":std".

       ":std" is not a layer but an additional subpragma.  When specified in the import list, it activates an additional functionality of pushing the layers selected for input/output handles to the
       standard filehandles (STDIN, STDOUT, STDERR).  If the new layers and existing layer stack both end with an ":encoding" layer, the existing ":encoding" layer will also be removed.

       For example, if both input and out are chosen to be ":encoding(UTF-8)", a ":std" will mean that STDIN, STDOUT, and STDERR will also have ":encoding(UTF-8)" set.  On the other hand, if only output
       is chosen to be in ":encoding(koi8r)", a ":std" will cause only the STDOUT and STDERR to be in "koi8r".

       The effect of ":std" is not lexical as it modifies the layer stack of the global handles.  If you wish to apply only this global effect and not the effect on handles that are opened in that
       scope, you can isolate the call to this pragma in its own lexical scope.

           { use open ':std', IO => ':encoding(UTF-8)' }

       Before Perl 5.34, ":std" would only apply the first layer provided that is either ":utf8" or has a layer argument, e.g. ":encoding(UTF-8)". Since Perl 5.34 it will apply the same layer stack it
       provides to "${^OPEN}".

IMPLEMENTATION DETAILS
       There is a class method in "PerlIO::Layer" "find" which is implemented as XS code.  It is called by "import" to validate the layers:

          PerlIO::Layer::->find("perlio")

       The return value (if defined) is a Perl object, of class "PerlIO::Layer" which is created by the C code in perlio.c.  As yet there is nothing useful you can do with the object at the perl level.

SEE ALSO
       "binmode" in perlfunc, "open" in perlfunc, perlunicode, PerlIO, encoding

perl v5.36.0                                                                                    2022-12-12                                                                                     open(3perl)
OPEN(3P)                                                                                 POSIX Programmer's Manual                                                                                OPEN(3P)

PROLOG
       This  manual  page is part of the POSIX Programmer's Manual.  The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or
       the interface may not be implemented on Linux.

NAME
       open, openat — open file

SYNOPSIS
       #include <sys/stat.h>
       #include <fcntl.h>

       int open(const char *path, int oflag, ...);
       int openat(int fd, const char *path, int oflag, ...);

DESCRIPTION
       The open() function shall establish the connection between a file and a file descriptor. It shall create an open file description that refers to a file and a file descriptor that refers  to  that
       open file description.  The file descriptor is used by other I/O functions to refer to that file. The path argument points to a pathname naming the file.

       The  open()  function  shall  return a file descriptor for the named file, allocated as described in Section 2.14, File Descriptor Allocation.  The open file description is new, and therefore the
       file descriptor shall not share it with any other process in the system. The FD_CLOEXEC file descriptor flag associated with the new file descriptor shall be cleared unless the O_CLOEXEC flag  is
       set in oflag.

       The file offset used to mark the current position within the file shall be set to the beginning of the file.

       The file status flags and file access modes of the open file description shall be set according to the value of oflag.

       Values  for  oflag  are constructed by a bitwise-inclusive OR of flags from the following list, defined in <fcntl.h>.  Applications shall specify exactly one of the first five values (file access
       modes) below in the value of oflag:

       O_EXEC        Open for execute only (non-directory files). The result is unspecified if this flag is applied to a directory.

       O_RDONLY      Open for reading only.

       O_RDWR        Open for reading and writing. The result is undefined if this flag is applied to a FIFO.

       O_SEARCH      Open directory for search only. The result is unspecified if this flag is applied to a non-directory file.

       O_WRONLY      Open for writing only.

       Any combination of the following may be used:

       O_APPEND      If set, the file offset shall be set to the end of the file prior to each write.

       O_CLOEXEC     If set, the FD_CLOEXEC flag for the new file descriptor shall be set.

       O_CREAT       If the file exists, this flag has no effect except as noted under O_EXCL below. Otherwise, if O_DIRECTORY is not set the file shall be created as a regular file; the user ID of  the
                     file  shall  be set to the effective user ID of the process; the group ID of the file shall be set to the group ID of the file's parent directory or to the effective group ID of the
                     process; and the access permission bits (see <sys/stat.h>) of the file mode shall be set to the value of the argument following the oflag argument taken as type mode_t  modified  as
                     follows: a bitwise AND is performed on the file-mode bits and the corresponding bits in the complement of the process' file mode creation mask. Thus, all bits in the file mode whose
                     corresponding bit in the file mode creation mask is set are cleared. When bits other than the file permission bits are set, the effect is unspecified.  The  argument  following  the
                     oflag  argument  does not affect whether the file is open for reading, writing, or for both. Implementations shall provide a way to initialize the file's group ID to the group ID of
                     the parent directory. Implementations may, but need not, provide an implementation-defined way to initialize the file's group ID to the effective group ID of the calling process.

       O_DIRECTORY   If path resolves to a non-directory file, fail and set errno to [ENOTDIR].

       O_DSYNC       Write I/O operations on the file descriptor shall complete as defined by synchronized I/O data integrity completion.

       O_EXCL        If O_CREAT and O_EXCL are set, open() shall fail if the file exists. The check for the existence of the file and the creation of the file if it does not exist shall be  atomic  with
                     respect  to other threads executing open() naming the same filename in the same directory with O_EXCL and O_CREAT set. If O_EXCL and O_CREAT are set, and path names a symbolic link,
                     open() shall fail and set errno to [EEXIST], regardless of the contents of the symbolic link. If O_EXCL is set and O_CREAT is not set, the result is undefined.

       O_NOCTTY      If set and path identifies a terminal device, open() shall not cause the terminal device to become the controlling terminal for the process. If path does not identify a terminal de‐
                     vice, O_NOCTTY shall be ignored.

       O_NOFOLLOW    If path names a symbolic link, fail and set errno to [ELOOP].

       O_NONBLOCK    When opening a FIFO with O_RDONLY or O_WRONLY set:

                      *  If O_NONBLOCK is set, an open() for reading-only shall return without delay. An open() for writing-only shall return an error if no process currently has the file open for read‐
                         ing.

                      *  If O_NONBLOCK is clear, an open() for reading-only shall block the calling thread until a thread opens the file for writing. An open() for writing-only shall block  the  calling
                         thread until a thread opens the file for reading.

                     When opening a block special or character special file that supports non-blocking opens:

                      *  If O_NONBLOCK is set, the open() function shall return without blocking for the device to be ready or available. Subsequent behavior of the device is device-specific.

                      *  If O_NONBLOCK is clear, the open() function shall block the calling thread until the device is ready or available before returning.

                     Otherwise, the O_NONBLOCK flag shall not cause an error, but it is unspecified whether the file status flags will include the O_NONBLOCK flag.

       O_RSYNC       Read  I/O operations on the file descriptor shall complete at the same level of integrity as specified by the O_DSYNC and O_SYNC flags. If both O_DSYNC and O_RSYNC are set in oflag,
                     all I/O operations on the file descriptor shall complete as defined by synchronized I/O data integrity completion. If both O_SYNC and O_RSYNC are set in flags, all I/O operations on
                     the file descriptor shall complete as defined by synchronized I/O file integrity completion.

       O_SYNC        Write I/O operations on the file descriptor shall complete as defined by synchronized I/O file integrity completion.

                     The O_SYNC flag shall be supported for regular files, even if the Synchronized Input and Output option is not supported.

       O_TRUNC       If  the  file exists and is a regular file, and the file is successfully opened O_RDWR or O_WRONLY, its length shall be truncated to 0, and the mode and owner shall be unchanged. It
                     shall have no effect on FIFO special files or terminal device files. Its effect on other file types is implementation-defined. The result of using O_TRUNC without either  O_RDWR  or
                     O_WRONLY is undefined.

       O_TTY_INIT    If  path  identifies a terminal device other than a pseudo-terminal, the device is not already open in any process, and either O_TTY_INIT is set in oflag or O_TTY_INIT has the value
                     zero, open() shall set any non-standard termios structure terminal parameters to a state that provides conforming behavior; see the Base Definitions volume of POSIX.1‐2017,  Section
                     11.2,  Parameters  that Can be Set.  It is unspecified whether O_TTY_INIT has any effect if the device is already open in any process. If path identifies the slave side of a pseudo-
                     terminal that is not already open in any process, open() shall set any non-standard termios structure terminal parameters to a state that provides conforming behavior, regardless of
                     whether O_TTY_INIT is set. If path does not identify a terminal device, O_TTY_INIT shall be ignored.

       If O_CREAT and O_DIRECTORY are set and the requested access mode is neither O_WRONLY nor O_RDWR, the result is unspecified.

       If  O_CREAT  is set and the file did not previously exist, upon successful completion, open() shall mark for update the last data access, last data modification, and last file status change time‐
       stamps of the file and the last data modification and last file status change timestamps of the parent directory.

       If O_TRUNC is set and the file did previously exist, upon successful completion, open() shall mark for update the last data modification and last file status change timestamps of the file.

       If both the O_SYNC and O_DSYNC flags are set, the effect is as if only the O_SYNC flag was set.

       If path refers to a STREAMS file, oflag may be constructed from O_NONBLOCK OR'ed with either O_RDONLY, O_WRONLY, or O_RDWR. Other flag values are not applicable to STREAMS devices and shall  have
       no  effect  on them. The value O_NONBLOCK affects the operation of STREAMS drivers and certain functions applied to file descriptors associated with STREAMS files. For STREAMS drivers, the imple‐
       mentation of O_NONBLOCK is device-specific.

       The application shall ensure that it specifies the O_TTY_INIT flag on the first open of a terminal device since system boot or since the device was closed by the process that last  had  it  open.
       The  application  need  not  specify the O_TTY_INIT flag when opening pseudo-terminals.  If path names the master side of a pseudo-terminal device, then it is unspecified whether open() locks the
       slave side so that it cannot be opened. Conforming applications shall call unlockpt() before opening the slave side.

       The largest value that can be represented correctly in an object of type off_t shall be established as the offset maximum in the open file description.

       The openat() function shall be equivalent to the open() function except in the case where path specifies a relative path. In this case the file to be opened is determined relative to  the  direc‐
       tory  associated  with  the  file  descriptor fd instead of the current working directory. If the access mode of the open file description associated with the file descriptor is not O_SEARCH, the
       function shall check whether directory searches are permitted using the current permissions of the directory underlying the file descriptor. If the access mode is O_SEARCH, the function shall not
       perform the check.

       The oflag parameter and the optional fourth parameter correspond exactly to the parameters of open().

       If openat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be used and the behavior shall be identical to a call to open().

RETURN VALUE
       Upon  successful  completion,  these functions shall open the file and return a non-negative integer representing the file descriptor.  Otherwise, these functions shall return -1 and set errno to
       indicate the error. If -1 is returned, no files shall be created or modified.

ERRORS
       These functions shall fail if:

       EACCES Search permission is denied on a component of the path prefix, or the file exists and the permissions specified by oflag are denied, or the file does not exist and write permission is  de‐
              nied for the parent directory of the file to be created, or O_TRUNC is specified and write permission is denied.

       EEXIST O_CREAT and O_EXCL are set, and the named file exists.

       EINTR  A signal was caught during open().

       EINVAL The implementation does not support synchronized I/O for this file.

       EIO    The path argument names a STREAMS file and a hangup or error occurred during the open().

       EISDIR The named file is a directory and oflag includes O_WRONLY or O_RDWR, or includes O_CREAT without O_DIRECTORY.

       ELOOP  A loop exists in symbolic links encountered during resolution of the path argument, or O_NOFOLLOW was specified and the path argument names a symbolic link.

       EMFILE All file descriptors available to the process are currently open.

       ENAMETOOLONG
              The length of a component of a pathname is longer than {NAME_MAX}.

       ENFILE The maximum allowable number of files is currently open in the system.

       ENOENT O_CREAT is not set and a component of path does not name an existing file, or O_CREAT is set and a component of the path prefix of path does not name an existing file, or path points to an
              empty string.

       ENOENT or ENOTDIR
              O_CREAT is set, and the path argument contains at least one non-<slash> character and ends with one or more trailing <slash> characters. If path without  the  trailing  <slash>  characters
              would name an existing file, an [ENOENT] error shall not occur.

       ENOSR  The path argument names a STREAMS-based file and the system is unable to allocate a STREAM.

       ENOSPC The directory or file system that would contain the new file cannot be expanded, the file does not exist, and O_CREAT is specified.

       ENOTDIR
              A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory; or O_CREAT and O_EXCL are not specified, the path argument contains at
              least one non-<slash> character and ends with one or more trailing <slash> characters, and the last pathname component names an existing file that is neither a  directory  nor  a  symbolic
              link to a directory; or O_DIRECTORY was specified and the path argument resolves to a non-directory file.

       ENXIO  O_NONBLOCK is set, the named file is a FIFO, O_WRONLY is set, and no process has the file open for reading.

       ENXIO  The named file is a character special or block special file, and the device associated with this special file does not exist.

       EOVERFLOW
              The named file is a regular file and the size of the file cannot be represented correctly in an object of type off_t.

       EROFS  The named file resides on a read-only file system and either O_WRONLY, O_RDWR, O_CREAT (if the file does not exist), or O_TRUNC is set in the oflag argument.

       The openat() function shall fail if:

       EACCES The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory underlying fd do not permit directory searches.

       EBADF  The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file descriptor open for reading or searching.

       ENOTDIR
              The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.

       These functions may fail if:

       EAGAIN The path argument names the slave side of a pseudo-terminal device that is locked.

       EINVAL The value of the oflag argument is not valid.

       ELOOP  More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.

       ENAMETOOLONG
              The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a length that exceeds {PATH_MAX}.

       ENOMEM The path argument names a STREAMS file and the system is unable to allocate resources.

       EOPNOTSUPP
              The path argument names a socket.

       ETXTBSY
              The file is a pure procedure (shared text) file that is being executed and oflag is O_WRONLY or O_RDWR.

       The following sections are informative.

EXAMPLES
   Opening a File for Writing by the Owner
       The  following example opens the file /tmp/file, either by creating it (if it does not already exist), or by truncating its length to 0 (if it does exist). In the former case, if the call creates
       a new file, the access permission bits in the file mode of the file are set to permit reading and writing by the owner, and to permit reading only by group members and others.

       If the call to open() is successful, the file is opened for writing.

           #include <fcntl.h>
           ...
           int fd;
           mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
           char *pathname = "/tmp/file";
           ...
           fd = open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);
           ...

   Opening a File Using an Existence Check
       The following example uses the open() function to try to create the LOCKFILE file and open it for writing. Since the open() function specifies the O_EXCL flag, the call fails if the file  already
       exists. In that case, the program assumes that someone else is updating the password file and exits.

           #include <fcntl.h>
           #include <stdio.h>
           #include <stdlib.h>

           #define LOCKFILE "/etc/ptmp"
           ...
           int pfd; /* Integer for file descriptor returned by open() call. */
           ...
           if ((pfd = open(LOCKFILE, O_WRONLY | O_CREAT | O_EXCL,
               S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
           {
               fprintf(stderr, "Cannot open /etc/ptmp. Try again later.\n");
               exit(1);
           }
           ...

   Opening a File for Writing
       The following example opens a file for writing, creating the file if it does not already exist. If the file does exist, the system truncates the file to zero bytes.

           #include <fcntl.h>
           #include <stdio.h>
           #include <stdlib.h>

           #define LOCKFILE "/etc/ptmp"
           ...
           int pfd;
           char pathname[PATH_MAX+1];
           ...
           if ((pfd = open(pathname, O_WRONLY | O_CREAT | O_TRUNC,
               S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
           {
               perror("Cannot open output file\n"); exit(1);
           }
           ...

APPLICATION USAGE
       POSIX.1‐2008  does  not require that terminal parameters be automatically set to any state on first open, nor that they be reset after the last close. It is possible for a non-conforming applica‐
       tion to leave a terminal device in a state where the next process to use that device finds it in a non-conforming state, but has no way of determining this. To ensure that the device is set to  a
       conforming  initial  state,  applications  which perform a first open of a terminal (other than a pseudo-terminal) should do so using the O_TTY_INIT flag to set the parameters associated with the
       terminal to a conforming state.

       Except as specified in this volume of POSIX.1‐2017, the flags allowed in oflag are not mutually-exclusive and any number of them may be used simultaneously. Not all  combinations  of  flags  make
       sense. For example, using O_SEARCH | O_CREAT will successfully open a pre-existing directory for searching, but if there is no existing file by that name, then it is unspecified whether a regular
       file will be created. Likewise, if a non-directory file descriptor is successfully returned, it is unspecified whether that descriptor will have execute permissions as if by O_EXEC (note that  it
       is unspecified whether O_EXEC and O_SEARCH have the same value).

RATIONALE
       Some  implementations  permit opening FIFOs with O_RDWR. Since FIFOs could be implemented in other ways, and since two file descriptors can be used to the same effect, this possibility is left as
       undefined.

       See getgroups() about the group of a newly created file.

       The use of open() to create a regular file is preferable to the use of creat(), because the latter is redundant and included only for historical reasons.

       The use of the O_TRUNC flag on FIFOs and directories (pipes cannot be open()-ed) must be permissible without unexpected side-effects (for example, creat() on a FIFO must not remove  data).  Since
       terminal  special files might have type-ahead data stored in the buffer, O_TRUNC should not affect their content, particularly if a program that normally opens a regular file should open the cur‐
       rent controlling terminal instead. Other file types, particularly implementation-defined ones, are left implementation-defined.

       POSIX.1‐2008 permits [EACCES] to be returned for conditions other than those explicitly listed.

       The O_NOCTTY flag was added to allow applications to avoid unintentionally acquiring a controlling terminal as a side-effect of opening a terminal file. This volume of POSIX.1‐2017 does not spec‐
       ify how a controlling terminal is acquired, but it allows an implementation to provide this on open() if the O_NOCTTY flag is not set and other conditions specified in the Base Definitions volume
       of POSIX.1‐2017, Chapter 11, General Terminal Interface are met.

       In historical implementations the value of O_RDONLY is zero. Because of that, it is not possible to detect the presence of O_RDONLY  and  another  option.  Future  implementations  should  encode
       O_RDONLY and O_WRONLY as bit flags so that:

           O_RDONLY | O_WRONLY == O_RDWR

       O_EXEC  and  O_SEARCH are specified as two of the five file access modes.  Since O_EXEC does not apply to directories, and O_SEARCH only applies to directories, their values need not be distinct.
       Since O_RDONLY has historically had the value zero, implementations are not able to distinguish between O_SEARCH and O_SEARCH | O_RDONLY, and similarly for O_EXEC.

       In general, the open() function follows the symbolic link if path names a symbolic link. However, the open() function, when called with O_CREAT and O_EXCL, is required to fail  with  [EEXIST]  if
       path  names  an existing symbolic link, even if the symbolic link refers to a nonexistent file. This behavior is required so that privileged applications can create a new file in a known location
       without the possibility that a symbolic link might cause the file to be created in a different location.

       For example, a privileged application that must create a file with a predictable name in a user-writable directory, such as the user's home directory, could be compromised if the user  creates  a
       symbolic link with that name that refers to a nonexistent file in a system directory. If the user can influence the contents of a file, the user could compromise the system by creating a new sys‐
       tem configuration or spool file that would then be interpreted by the system. The test for a symbolic link which refers to a nonexisting file must be atomic with the creation of a new file.

       In addition, the open() function refuses to open non-directories if the O_DIRECTORY flag is set. This avoids race conditions whereby a user might compromise the system by substituting a hard link
       to a sensitive file (e.g., a device or a FIFO) while a privileged application is running, where opening a file even for read access might have undesirable side-effects.

       In  addition,  the open() function does not follow symbolic links if the O_NOFOLLOW flag is set.  This avoids race conditions whereby a user might compromise the system by substituting a symbolic
       link to a sensitive file (e.g., a device) while a privileged application is running, where opening a file even for read access might have undesirable side-effects.

       The POSIX.1‐1990 standard required that the group ID of a newly created file be set to the group ID of its parent directory or to the effective group ID of the creating process.  FIPS  151‐2  re‐
       quired  that  implementations provide a way to have the group ID be set to the group ID of the containing directory, but did not prohibit implementations also supporting a way to set the group ID
       to the effective group ID of the creating process.  Conforming applications should not assume which group ID will be used. If it matters, an application can use chown() to set the group ID  after
       the file is created, or determine under what conditions the implementation will set the desired group ID.

       The  purpose  of the openat() function is to enable opening files in directories other than the current working directory without exposure to race conditions. Any part of the path of a file could
       be changed in parallel to a call to open(), resulting in unspecified behavior. By opening a file descriptor for the target directory and using the openat() function it can be guaranteed that  the
       opened file is located relative to the desired directory. Some implementations use the openat() function for other purposes as well. In some cases, if the oflag parameter has the O_XATTR bit set,
       the returned file descriptor provides access to extended attributes. This functionality is not standardized here.

FUTURE DIRECTIONS
       None.

SEE ALSO
       chmod(), close(), creat(), dirfd(), dup(), exec, fcntl(), fdopendir(), link(), lseek(), mkdtemp(), mknod(), read(), symlink(), umask(), unlockpt(), write()

       The Base Definitions volume of POSIX.1‐2017, Chapter 11, General Terminal Interface, <fcntl.h>, <sys_stat.h>, <sys_types.h>

COPYRIGHT
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group
       Base  Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any discrepancy between this ver‐
       sion and the original IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be  obtained  online  at  http://www.open‐
       group.org/unix/online.html .

       Any  typographical  or  formatting errors that appear in this page are most likely to have been introduced during the conversion of the source files to man page format. To report such errors, see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                                                                2017                                                                                           OPEN(3P)
open(2)                                                                                     System Calls Manual                                                                                    open(2)

NAME
       open, openat, creat - open and possibly create a file

LIBRARY
       Standard C library (libc, -lc)

SYNOPSIS
       #include <fcntl.h>

       int open(const char *pathname, int flags);
       int open(const char *pathname, int flags, mode_t mode);

       int creat(const char *pathname, mode_t mode);

       int openat(int dirfd, const char *pathname, int flags);
       int openat(int dirfd, const char *pathname, int flags, mode_t mode);

       /* Documented separately, in openat2(2): */
       int openat2(int dirfd, const char *pathname,
                   const struct open_how *how, size_t size);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       openat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       The open() system call opens the file specified by pathname.  If the specified file does not exist, it may optionally (if O_CREAT is specified in flags) be created by open().

       The  return value of open() is a file descriptor, a small, nonnegative integer that is an index to an entry in the process's table of open file descriptors.  The file descriptor is used in subse‐
       quent system calls (read(2), write(2), lseek(2), fcntl(2), etc.) to refer to the open file.  The file descriptor returned by a successful call will be the lowest-numbered file descriptor not cur‐
       rently open for the process.

       By  default,  the  new  file  descriptor is set to remain open across an execve(2) (i.e., the FD_CLOEXEC file descriptor flag described in fcntl(2) is initially disabled); the O_CLOEXEC flag, de‐
       scribed below, can be used to change this default.  The file offset is set to the beginning of the file (see lseek(2)).

       A call to open() creates a new open file description, an entry in the system-wide table of open files.  The open file description records the file offset and the file status flags (see below).  A
       file descriptor is a reference to an open file description; this reference is unaffected if pathname is subsequently removed or modified to refer to a different file.  For further details on open
       file descriptions, see NOTES.

       The argument flags must include one of the following access modes: O_RDONLY, O_WRONLY, or O_RDWR.  These request opening the file read-only, write-only, or read/write, respectively.

       In addition, zero or more file creation flags and file status flags can be bitwise-or'd in flags.  The file creation flags are  O_CLOEXEC,  O_CREAT,  O_DIRECTORY,  O_EXCL,  O_NOCTTY,  O_NOFOLLOW,
       O_TMPFILE, and O_TRUNC.  The file status flags are all of the remaining flags listed below.  The distinction between these two groups of flags is that the file creation flags affect the semantics
       of the open operation itself, while the file status flags affect the semantics of subsequent I/O operations.  The file status flags can be retrieved and (in some cases) modified; see fcntl(2) for
       details.

       The full list of file creation flags and file status flags is as follows:

       O_APPEND
              The  file is opened in append mode.  Before each write(2), the file offset is positioned at the end of the file, as if with lseek(2).  The modification of the file offset and the write op‐
              eration are performed as a single atomic step.

              O_APPEND may lead to corrupted files on NFS filesystems if more than one process appends data to a file at once.  This is because NFS does not support appending to a file,  so  the  client
              kernel has to simulate it, which can't be done without a race condition.

       O_ASYNC
              Enable  signal-driven I/O: generate a signal (SIGIO by default, but this can be changed via fcntl(2)) when input or output becomes possible on this file descriptor.  This feature is avail‐
              able only for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs.  See fcntl(2) for further details.  See also BUGS, below.

       O_CLOEXEC (since Linux 2.6.23)
              Enable the close-on-exec flag for the new file descriptor.  Specifying this flag permits a program to avoid additional fcntl(2) F_SETFD operations to set the FD_CLOEXEC flag.

              Note that the use of this flag is essential in some multithreaded programs, because using a separate fcntl(2) F_SETFD operation to set the FD_CLOEXEC flag does not suffice  to  avoid  race
              conditions  where  one thread opens a file descriptor and attempts to set its close-on-exec flag using fcntl(2) at the same time as another thread does a fork(2) plus execve(2).  Depending
              on the order of execution, the race may lead to the file descriptor returned by open() being unintentionally leaked to the program executed by the child process created by fork(2).   (This
              kind  of race is in principle possible for any system call that creates a file descriptor whose close-on-exec flag should be set, and various other Linux system calls provide an equivalent
              of the O_CLOEXEC flag to deal with this problem.)

       O_CREAT
              If pathname does not exist, create it as a regular file.

              The owner (user ID) of the new file is set to the effective user ID of the process.

              The group ownership (group ID) of the new file is set either to the effective group ID of the process (System V semantics) or to the group ID of the parent directory (BSD  semantics).   On
              Linux,  the  behavior  depends  on whether the set-group-ID mode bit is set on the parent directory: if that bit is set, then BSD semantics apply; otherwise, System V semantics apply.  For
              some filesystems, the behavior also depends on the bsdgroups and sysvgroups mount options described in mount(8).

              The mode argument specifies the file mode bits to be applied when a new file is created.  If neither O_CREAT nor O_TMPFILE is specified in flags, then mode is  ignored  (and  can  thus  be
              specified  as  0,  or simply omitted).  The mode argument must be supplied if O_CREAT or O_TMPFILE is specified in flags; if it is not supplied, some arbitrary bytes from the stack will be
              applied as the file mode.

              The effective mode is modified by the process's umask in the usual way: in the absence of a default ACL, the mode of the created file is (mode & ~umask).

              Note that mode applies only to future accesses of the newly created file; the open() call that creates a read-only file may well return a read/write file descriptor.

              The following symbolic constants are provided for mode:

              S_IRWXU  00700 user (file owner) has read, write, and execute permission

              S_IRUSR  00400 user has read permission

              S_IWUSR  00200 user has write permission

              S_IXUSR  00100 user has execute permission

              S_IRWXG  00070 group has read, write, and execute permission

              S_IRGRP  00040 group has read permission

              S_IWGRP  00020 group has write permission

              S_IXGRP  00010 group has execute permission

              S_IRWXO  00007 others have read, write, and execute permission

              S_IROTH  00004 others have read permission

              S_IWOTH  00002 others have write permission

              S_IXOTH  00001 others have execute permission

              According to POSIX, the effect when other bits are set in mode is unspecified.  On Linux, the following bits are also honored in mode:

              S_ISUID  0004000 set-user-ID bit

              S_ISGID  0002000 set-group-ID bit (see inode(7)).

              S_ISVTX  0001000 sticky bit (see inode(7)).

       O_DIRECT (since Linux 2.4.10)
              Try to minimize cache effects of the I/O to and from this file.  In general this will degrade performance, but it is useful in special situations, such as when applications  do  their  own
              caching.  File I/O is done directly to/from user-space buffers.  The O_DIRECT flag on its own makes an effort to transfer data synchronously, but does not give the guarantees of the O_SYNC
              flag that data and necessary metadata are transferred.  To guarantee synchronous I/O, O_SYNC must be used in addition to O_DIRECT.  See NOTES below for further discussion.

              A semantically similar (but deprecated) interface for block devices is described in raw(8).

       O_DIRECTORY
              If pathname is not a directory, cause the open to fail.  This flag was added in Linux 2.1.126, to avoid denial-of-service problems if opendir(3) is called on a FIFO or tape device.

       O_DSYNC
              Write operations on the file will complete according to the requirements of synchronized I/O data integrity completion.

              By the time write(2) (and similar) return, the output data has been transferred to the underlying hardware, along with any file metadata that would be required to retrieve that data (i.e.,
              as though each write(2) was followed by a call to fdatasync(2)).  See NOTES below.

       O_EXCL Ensure that this call creates the file: if this flag is specified in conjunction with O_CREAT, and pathname already exists, then open() fails with the error EEXIST.

              When these two flags are specified, symbolic links are not followed: if pathname is a symbolic link, then open() fails regardless of where the symbolic link points.

              In  general,  the behavior of O_EXCL is undefined if it is used without O_CREAT.  There is one exception: on Linux 2.6 and later, O_EXCL can be used without O_CREAT if pathname refers to a
              block device.  If the block device is in use by the system (e.g., mounted), open() fails with the error EBUSY.

              On NFS, O_EXCL is supported only when using NFSv3 or later on kernel 2.6 or later.  In NFS environments where O_EXCL support is not provided, programs that rely on it for performing  lock‐
              ing  tasks  will  contain a race condition.  Portable programs that want to perform atomic file locking using a lockfile, and need to avoid reliance on NFS support for O_EXCL, can create a
              unique file on the same filesystem (e.g., incorporating hostname and PID), and use link(2) to make a link to the lockfile.  If link(2) returns 0, the lock is  successful.   Otherwise,  use
              stat(2) on the unique file to check if its link count has increased to 2, in which case the lock is also successful.

       O_LARGEFILE
              (LFS)  Allow  files  whose sizes cannot be represented in an off_t (but can be represented in an off64_t) to be opened.  The _LARGEFILE64_SOURCE macro must be defined (before including any
              header files) in order to obtain this definition.  Setting the _FILE_OFFSET_BITS feature test macro to 64 (rather than using O_LARGEFILE) is the preferred method of accessing  large  files
              on 32-bit systems (see feature_test_macros(7)).

       O_NOATIME (since Linux 2.6.8)
              Do not update the file last access time (st_atime in the inode) when the file is read(2).

              This flag can be employed only if one of the following conditions is true:

              •  The effective UID of the process matches the owner UID of the file.

              •  The calling process has the CAP_FOWNER capability in its user namespace and the owner UID of the file has a mapping in the namespace.

              This  flag  is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity.  This flag may not be effective on all filesystems.  One
              example is NFS, where the server maintains the access time.

       O_NOCTTY
              If pathname refers to a terminal device—see tty(4)—it will not become the process's controlling terminal even if the process does not have one.

       O_NOFOLLOW
              If the trailing component (i.e., basename) of pathname is a symbolic link, then the open fails, with the error ELOOP.  Symbolic links in earlier components of the pathname  will  still  be
              followed.   (Note  that  the  ELOOP error that can occur in this case is indistinguishable from the case where an open fails because there are too many symbolic links found while resolving
              components in the prefix part of the pathname.)

              This flag is a FreeBSD extension, which was added in Linux 2.1.126, and has subsequently been standardized in POSIX.1-2008.

              See also O_PATH below.

       O_NONBLOCK or O_NDELAY
              When possible, the file is opened in nonblocking mode.  Neither the open() nor any subsequent I/O operations on the file descriptor which is returned will  cause  the  calling  process  to
              wait.

              Note  that  the  setting  of this flag has no effect on the operation of poll(2), select(2), epoll(7), and similar, since those interfaces merely inform the caller about whether a file de‐
              scriptor is "ready", meaning that an I/O operation performed on the file descriptor with the O_NONBLOCK flag clear would not block.

              Note that this flag has no effect for regular files and block devices; that is, I/O operations will (briefly) block when device activity is required, regardless of  whether  O_NONBLOCK  is
              set.  Since O_NONBLOCK semantics might eventually be implemented, applications should not depend upon blocking behavior when specifying this flag for regular files and block devices.

              For the handling of FIFOs (named pipes), see also fifo(7).  For a discussion of the effect of O_NONBLOCK in conjunction with mandatory file locks and with file leases, see fcntl(2).

       O_PATH (since Linux 2.6.39)
              Obtain  a file descriptor that can be used for two purposes: to indicate a location in the filesystem tree and to perform operations that act purely at the file descriptor level.  The file
              itself is not opened, and other file operations (e.g., read(2), write(2), fchmod(2), fchown(2), fgetxattr(2), ioctl(2), mmap(2)) fail with the error EBADF.

              The following operations can be performed on the resulting file descriptor:

              •  close(2).

              •  fchdir(2), if the file descriptor refers to a directory (since Linux 3.5).

              •  fstat(2) (since Linux 3.6).

              •  fstatfs(2) (since Linux 3.12).

              •  Duplicating the file descriptor (dup(2), fcntl(2) F_DUPFD, etc.).

              •  Getting and setting file descriptor flags (fcntl(2) F_GETFD and F_SETFD).

              •  Retrieving open file status flags using the fcntl(2) F_GETFL operation: the returned flags will include the bit O_PATH.

              •  Passing the file descriptor as the dirfd argument of openat() and the other "*at()" system calls.  This includes linkat(2) with AT_EMPTY_PATH (or  via  procfs  using  AT_SYMLINK_FOLLOW)
                 even if the file is not a directory.

              •  Passing the file descriptor to another process via a UNIX domain socket (see SCM_RIGHTS in unix(7)).

              When O_PATH is specified in flags, flag bits other than O_CLOEXEC, O_DIRECTORY, and O_NOFOLLOW are ignored.

              Opening a file or directory with the O_PATH flag requires no permissions on the object itself (but does require execute permission on the directories in the path prefix).  Depending on the
              subsequent operation, a check for suitable file permissions may be performed (e.g., fchdir(2) requires execute permission on the directory referred to by its file descriptor argument).  By
              contrast,  obtaining a reference to a filesystem object by opening it with the O_RDONLY flag requires that the caller have read permission on the object, even when the subsequent operation
              (e.g., fchdir(2), fstat(2)) does not require read permission on the object.

              If pathname is a symbolic link and the O_NOFOLLOW flag is also specified, then the call returns a file descriptor referring to the symbolic link.  This file descriptor can be used  as  the
              dirfd argument in calls to fchownat(2), fstatat(2), linkat(2), and readlinkat(2) with an empty pathname to have the calls operate on the symbolic link.

              If pathname refers to an automount point that has not yet been triggered, so no other filesystem is mounted on it, then the call returns a file descriptor referring to the automount direc‐
              tory without triggering a mount.  fstatfs(2) can then be used to determine if it is, in fact, an untriggered automount point (.f_type == AUTOFS_SUPER_MAGIC).

              One use of O_PATH for regular files is to provide the equivalent of POSIX.1's O_EXEC functionality.  This permits us to open a file for which we have execute permission but not  read  per‐
              mission, and then execute that file, with steps something like the following:

                  char buf[PATH_MAX];
                  fd = open("some_prog", O_PATH);
                  snprintf(buf, PATH_MAX, "/proc/self/fd/%d", fd);
                  execl(buf, "some_prog", (char *) NULL);

              An O_PATH file descriptor can also be passed as the argument of fexecve(3).

       O_SYNC Write operations on the file will complete according to the requirements of synchronized I/O file integrity completion (by contrast with the synchronized I/O data integrity completion pro‐
              vided by O_DSYNC.)

              By the time write(2) (or similar) returns, the output data and associated file metadata have been transferred to the underlying hardware (i.e., as though each write(2) was  followed  by  a
              call to fsync(2)).  See NOTES below.

       O_TMPFILE (since Linux 3.11)
              Create  an unnamed temporary regular file.  The pathname argument specifies a directory; an unnamed inode will be created in that directory's filesystem.  Anything written to the resulting
              file will be lost when the last file descriptor is closed, unless the file is given a name.

              O_TMPFILE must be specified with one of O_RDWR or O_WRONLY and, optionally, O_EXCL.  If O_EXCL is not specified, then linkat(2) can be used to link the temporary file into the  filesystem,
              making it permanent, using code like the following:

                  char path[PATH_MAX];
                  fd = open("/path/to/dir", O_TMPFILE | O_RDWR,
                                          S_IRUSR | S_IWUSR);

                  /* File I/O on 'fd'... */

                  linkat(fd, "", AT_FDCWD, "/path/for/file", AT_EMPTY_PATH);

                  /* If the caller doesn't have the CAP_DAC_READ_SEARCH
                     capability (needed to use AT_EMPTY_PATH with linkat(2)),
                     and there is a proc(5) filesystem mounted, then the
                     linkat(2) call above can be replaced with:

                  snprintf(path, PATH_MAX,  "/proc/self/fd/%d", fd);
                  linkat(AT_FDCWD, path, AT_FDCWD, "/path/for/file",
                                          AT_SYMLINK_FOLLOW);
                  */

              In this case, the open() mode argument determines the file permission mode, as with O_CREAT.

              Specifying  O_EXCL in conjunction with O_TMPFILE prevents a temporary file from being linked into the filesystem in the above manner.  (Note that the meaning of O_EXCL in this case is dif‐
              ferent from the meaning of O_EXCL otherwise.)

              There are two main use cases for O_TMPFILE:

              •  Improved tmpfile(3) functionality: race-free creation of temporary files that (1) are automatically deleted when closed; (2) can never be reached via any pathname; (3) are  not  subject
                 to symlink attacks; and (4) do not require the caller to devise unique names.

              •  Creating  a file that is initially invisible, which is then populated with data and adjusted to have appropriate filesystem attributes (fchown(2), fchmod(2), fsetxattr(2), etc.)  before
                 being atomically linked into the filesystem in a fully formed state (using linkat(2) as described above).

              O_TMPFILE requires support by the underlying filesystem; only a subset of Linux filesystems provide that support.  In the initial implementation, support was provided in  the  ext2,  ext3,
              ext4,  UDF,  Minix,  and tmpfs filesystems.  Support for other filesystems has subsequently been added as follows: XFS (Linux 3.15); Btrfs (Linux 3.16); F2FS (Linux 3.16); and ubifs (Linux
              4.9)

       O_TRUNC
              If the file already exists and is a regular file and the access mode allows writing (i.e., is O_RDWR or O_WRONLY) it will be truncated to length 0.  If the file is a FIFO or  terminal  de‐
              vice file, the O_TRUNC flag is ignored.  Otherwise, the effect of O_TRUNC is unspecified.

   creat()
       A call to creat() is equivalent to calling open() with flags equal to O_CREAT|O_WRONLY|O_TRUNC.

   openat()
       The openat() system call operates in exactly the same way as open(), except for the differences described here.

       The dirfd argument is used in conjunction with the pathname argument as follows:

       •  If the pathname given in pathname is absolute, then dirfd is ignored.

       •  If  the  pathname  given  in  pathname  is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the current working directory of the calling process (like
          open()).

       •  If the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the file descriptor dirfd (rather than relative to the current working  directory
          of the calling process, as is done by open() for a relative pathname).  In this case, dirfd must be a directory that was opened for reading (O_RDONLY) or using the O_PATH flag.

       If  the  pathname given in pathname is relative, and dirfd is not a valid file descriptor, an error (EBADF) results.  (Specifying an invalid file descriptor number in dirfd can be used as a means
       to ensure that pathname is absolute.)

   openat2(2)
       The openat2(2) system call is an extension of openat(), and provides a superset of the features of openat().  It is documented separately, in openat2(2).

RETURN VALUE
       On success, open(), openat(), and creat() return the new file descriptor (a nonnegative integer).  On error, -1 is returned and errno is set to indicate the error.

ERRORS
       open(), openat(), and creat() can fail with the following errors:

       EACCES The requested access to the file is not allowed, or search permission is denied for one of the directories in the path prefix of pathname, or the file did not exist yet and write access to
              the parent directory is not allowed.  (See also path_resolution(7).)

       EACCES Where  O_CREAT is specified, the protected_fifos or protected_regular sysctl is enabled, the file already exists and is a FIFO or regular file, the owner of the file is neither the current
              user nor the owner of the containing directory, and the containing directory is both world- or group-writable and sticky.  For details, see the descriptions of /proc/sys/fs/protected_fifos
              and /proc/sys/fs/protected_regular in proc(5).

       EBADF  (openat()) pathname is relative but dirfd is neither AT_FDCWD nor a valid file descriptor.

       EBUSY  O_EXCL was specified in flags and pathname refers to a block device that is in use by the system (e.g., it is mounted).

       EDQUOT Where O_CREAT is specified, the file does not exist, and the user's quota of disk blocks or inodes on the filesystem has been exhausted.

       EEXIST pathname already exists and O_CREAT and O_EXCL were used.

       EFAULT pathname points outside your accessible address space.

       EFBIG  See EOVERFLOW.

       EINTR  While blocked waiting to complete an open of a slow device (e.g., a FIFO; see fifo(7)), the call was interrupted by a signal handler; see signal(7).

       EINVAL The filesystem does not support the O_DIRECT flag.  See NOTES for more information.

       EINVAL Invalid value in flags.

       EINVAL O_TMPFILE was specified in flags, but neither O_WRONLY nor O_RDWR was specified.

       EINVAL O_CREAT was specified in flags and the final component ("basename") of the new file's pathname is invalid (e.g., it contains characters not permitted by the underlying filesystem).

       EINVAL The final component ("basename") of pathname is invalid (e.g., it contains characters not permitted by the underlying filesystem).

       EISDIR pathname refers to a directory and the access requested involved writing (that is, O_WRONLY or O_RDWR is set).

       EISDIR pathname refers to an existing directory, O_TMPFILE and one of O_WRONLY or O_RDWR were specified in flags, but this kernel version does not provide the O_TMPFILE functionality.

       ELOOP  Too many symbolic links were encountered in resolving pathname.

       ELOOP  pathname was a symbolic link, and flags specified O_NOFOLLOW but not O_PATH.

       EMFILE The per-process limit on the number of open file descriptors has been reached (see the description of RLIMIT_NOFILE in getrlimit(2)).

       ENAMETOOLONG
              pathname was too long.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENODEV pathname refers to a device special file and no corresponding device exists.  (This is a Linux kernel bug; in this situation ENXIO must be returned.)

       ENOENT O_CREAT is not set and the named file does not exist.

       ENOENT A directory component in pathname does not exist or is a dangling symbolic link.

       ENOENT pathname refers to a nonexistent directory, O_TMPFILE and one of O_WRONLY or O_RDWR were specified in flags, but this kernel version does not provide the O_TMPFILE functionality.

       ENOMEM The  named  file  is  a FIFO, but memory for the FIFO buffer can't be allocated because the per-user hard limit on memory allocation for pipes has been reached and the caller is not privi‐
              leged; see pipe(7).

       ENOMEM Insufficient kernel memory was available.

       ENOSPC pathname was to be created but the device containing pathname has no room for the new file.

       ENOTDIR
              A component used as a directory in pathname is not, in fact, a directory, or O_DIRECTORY was specified and pathname was not a directory.

       ENOTDIR
              (openat()) pathname is a relative pathname and dirfd is a file descriptor referring to a file other than a directory.

       ENXIO  O_NONBLOCK | O_WRONLY is set, the named file is a FIFO, and no process has the FIFO open for reading.

       ENXIO  The file is a device special file and no corresponding device exists.

       ENXIO  The file is a UNIX domain socket.

       EOPNOTSUPP
              The filesystem containing pathname does not support O_TMPFILE.

       EOVERFLOW
              pathname refers to a regular file that is too large to be opened.  The usual scenario here is that an application compiled on a 32-bit platform without -D_FILE_OFFSET_BITS=64 tried to open
              a file whose size exceeds (1<<31)-1 bytes; see also O_LARGEFILE above.  This is the error specified by POSIX.1; before Linux 2.6.24, Linux gave the error EFBIG for this case.

       EPERM  The O_NOATIME flag was specified, but the effective user ID of the caller did not match the owner of the file and the caller was not privileged.

       EPERM  The operation was prevented by a file seal; see fcntl(2).

       EROFS  pathname refers to a file on a read-only filesystem and write access was requested.

       ETXTBSY
              pathname refers to an executable image which is currently being executed and write access was requested.

       ETXTBSY
              pathname refers to a file that is currently in use as a swap file, and the O_TRUNC flag was specified.

       ETXTBSY
              pathname refers to a file that is currently being read by the kernel (e.g., for module/firmware loading), and write access was requested.

       EWOULDBLOCK
              The O_NONBLOCK flag was specified, and an incompatible lease was held on the file (see fcntl(2)).

VERSIONS
       The (undefined) effect of O_RDONLY | O_TRUNC varies among implementations.  On many systems the file is actually truncated.

   Synchronized I/O
       The  POSIX.1-2008 "synchronized I/O" option specifies different variants of synchronized I/O, and specifies the open() flags O_SYNC, O_DSYNC, and O_RSYNC for controlling the behavior.  Regardless
       of whether an implementation supports this option, it must at least support the use of O_SYNC for regular files.

       Linux implements O_SYNC and O_DSYNC, but not O_RSYNC.  Somewhat incorrectly, glibc defines O_RSYNC to have the same value as O_SYNC.  (O_RSYNC is defined in the Linux header file <asm/fcntl.h> on
       HP PA-RISC, but it is not used.)

       O_SYNC  provides  synchronized  I/O  file integrity completion, meaning write operations will flush data and all associated metadata to the underlying hardware.  O_DSYNC provides synchronized I/O
       data integrity completion, meaning write operations will flush data to the underlying hardware, but will only flush metadata updates that are required to allow a subsequent read operation to com‐
       plete successfully.  Data integrity completion can reduce the number of disk operations that are required for applications that don't need the guarantees of file integrity completion.

       To  understand the difference between the two types of completion, consider two pieces of file metadata: the file last modification timestamp (st_mtime) and the file length.  All write operations
       will update the last file modification timestamp, but only writes that add data to the end of the file will change the file length.  The last modification timestamp is not needed to ensure that a
       read completes successfully, but the file length is.  Thus, O_DSYNC would only guarantee to flush updates to the file length metadata (whereas O_SYNC would also always flush the last modification
       timestamp metadata).

       Before Linux 2.6.33, Linux implemented only the O_SYNC flag for open().  However, when that flag was specified, most filesystems actually provided the equivalent of synchronized I/O  data  integ‐
       rity completion (i.e., O_SYNC was actually implemented as the equivalent of O_DSYNC).

       Since  Linux 2.6.33, proper O_SYNC support is provided.  However, to ensure backward binary compatibility, O_DSYNC was defined with the same value as the historical O_SYNC, and O_SYNC was defined
       as a new (two-bit) flag value that includes the O_DSYNC flag value.  This ensures that applications compiled against new headers get at least O_DSYNC semantics before Linux 2.6.33.

   C library/kernel differences
       Since glibc 2.26, the glibc wrapper function for open() employs the openat() system call, rather than the kernel's open() system call.  For certain architectures, this is also true  before  glibc
       2.26.

STANDARDS
       open()
       creat()
       openat()
              POSIX.1-2008.

       openat2(2) Linux.

       The O_DIRECT, O_NOATIME, O_PATH, and O_TMPFILE flags are Linux-specific.  One must define _GNU_SOURCE to obtain their definitions.

       The  O_CLOEXEC,  O_DIRECTORY,  and  O_NOFOLLOW  flags  are not specified in POSIX.1-2001, but are specified in POSIX.1-2008.  Since glibc 2.12, one can obtain their definitions by defining either
       _POSIX_C_SOURCE with a value greater than or equal to 200809L or _XOPEN_SOURCE with a value greater than or equal to 700.  In glibc 2.11 and earlier,  one  obtains  the  definitions  by  defining
       _GNU_SOURCE.

HISTORY
       open()
       creat()
              SVr4, 4.3BSD, POSIX.1-2001.

       openat()
              POSIX.1-2008.  Linux 2.6.16, glibc 2.4.

NOTES
       Under  Linux,  the O_NONBLOCK flag is sometimes used in cases where one wants to open but does not necessarily have the intention to read or write.  For example, this may be used to open a device
       in order to get a file descriptor for use with ioctl(2).

       Note that open() can open device special files, but creat() cannot create them; use mknod(2) instead.

       If the file is newly created, its st_atime, st_ctime, st_mtime fields (respectively, time of last access, time of last status change, and time of last modification; see stat(2)) are  set  to  the
       current time, and so are the st_ctime and st_mtime fields of the parent directory.  Otherwise, if the file is modified because of the O_TRUNC flag, its st_ctime and st_mtime fields are set to the
       current time.

       The files in the /proc/pid/fd directory show the open file descriptors of the process with the PID pid.  The files in the /proc/pid/fdinfo directory show even more information  about  these  file
       descriptors.  See proc(5) for further details of both of these directories.

       The Linux header file <asm/fcntl.h> doesn't define O_ASYNC; the (BSD-derived) FASYNC synonym is defined instead.

   Open file descriptions
       The  term open file description is the one used by POSIX to refer to the entries in the system-wide table of open files.  In other contexts, this object is variously also called an "open file ob‐
       ject", a "file handle", an "open file table entry", or—in kernel-developer parlance—a struct file.

       When a file descriptor is duplicated (using dup(2) or similar), the duplicate refers to the same open file description as the original file descriptor, and the two file  descriptors  consequently
       share  the  file  offset and file status flags.  Such sharing can also occur between processes: a child process created via fork(2) inherits duplicates of its parent's file descriptors, and those
       duplicates refer to the same open file descriptions.

       Each open() of a file creates a new open file description; thus, there may be multiple open file descriptions corresponding to a file inode.

       On Linux, one can use the kcmp(2) KCMP_FILE operation to test whether two file descriptors (in the same process or in two different processes) refer to the same open file description.

   NFS
       There are many infelicities in the protocol underlying NFS, affecting amongst others O_SYNC and O_NDELAY.

       On NFS filesystems with UID mapping enabled, open() may return a file descriptor but, for example, read(2) requests are denied with EACCES.  This is because the client performs open() by checking
       the permissions, but UID mapping is performed by the server upon read and write requests.

   FIFOs
       Opening the read or write end of a FIFO blocks until the other end is also opened (by another process or thread).  See fifo(7) for further details.

   File access mode
       Unlike the other values that can be specified in flags, the access mode values O_RDONLY, O_WRONLY, and O_RDWR do not specify individual bits.  Rather, they define the low order two bits of flags,
       and are defined respectively as 0, 1, and 2.  In other words, the combination O_RDONLY | O_WRONLY is a logical error, and certainly does not have the same meaning as O_RDWR.

       Linux reserves the special, nonstandard access mode 3 (binary 11) in flags to mean: check for read and write permission on the file and return a file descriptor that can't be used for reading  or
       writing.  This nonstandard access mode is used by some Linux drivers to return a file descriptor that is to be used only for device-specific ioctl(2) operations.

   Rationale for openat() and other directory file descriptor APIs
       openat()  and  the other system calls and library functions that take a directory file descriptor argument (i.e., execveat(2), faccessat(2), fanotify_mark(2), fchmodat(2), fchownat(2), fspick(2),
       fstatat(2), futimesat(2), linkat(2), mkdirat(2), mknodat(2), mount_setattr(2), move_mount(2), name_to_handle_at(2), open_tree(2), openat2(2), readlinkat(2), renameat(2),  renameat2(2),  statx(2),
       symlinkat(2), unlinkat(2), utimensat(2), mkfifoat(3), and scandirat(3)) address two problems with the older interfaces that preceded them.  Here, the explanation is in terms of the openat() call,
       but the rationale is analogous for the other interfaces.

       First, openat() allows an application to avoid race conditions that could occur when using open() to open files in directories other than the current working directory.  These race conditions re‐
       sult  from  the  fact  that  some  component  of  the directory prefix given to open() could be changed in parallel with the call to open().  Suppose, for example, that we wish to create the file
       dir1/dir2/xxx.dep if the file dir1/dir2/xxx exists.  The problem is that between the existence check and the file-creation step, dir1 or dir2 (which might be symbolic links) could be modified  to
       point to a different location.  Such races can be avoided by opening a file descriptor for the target directory, and then specifying that file descriptor as the dirfd argument of (say) fstatat(2)
       and openat().  The use of the dirfd file descriptor also has other benefits:

       •  the file descriptor is a stable reference to the directory, even if the directory is renamed; and

       •  the open file descriptor prevents the underlying filesystem from being dismounted, just as when a process has a current working directory on a filesystem.

       Second, openat() allows the implementation of a per-thread "current working directory", via file descriptor(s) maintained by the application.  (This functionality can also be obtained  by  tricks
       based on the use of /proc/self/fd/dirfd, but less efficiently.)

       The  dirfd argument for these APIs can be obtained by using open() or openat() to open a directory (with either the O_RDONLY or the O_PATH flag).  Alternatively, such a file descriptor can be ob‐
       tained by applying dirfd(3) to a directory stream created using opendir(3).

       When these APIs are given a dirfd argument of AT_FDCWD or the specified pathname is absolute, then they handle their pathname argument in the same way  as  the  corresponding  conventional  APIs.
       However, in this case, several of the APIs have a flags argument that provides access to functionality that is not available with the corresponding conventional APIs.

   O_DIRECT
       The  O_DIRECT  flag  may  impose alignment restrictions on the length and address of user-space buffers and the file offset of I/Os.  In Linux alignment restrictions vary by filesystem and kernel
       version and might be absent entirely.  The handling of misaligned O_DIRECT I/Os also varies; they can either fail with EINVAL or fall back to buffered I/O.

       Since Linux 6.1, O_DIRECT support and alignment restrictions for a file can be queried using statx(2), using the STATX_DIOALIGN  flag.   Support  for  STATX_DIOALIGN  varies  by  filesystem;  see
       statx(2).

       Some  filesystems provide their own interfaces for querying O_DIRECT alignment restrictions, for example the XFS_IOC_DIOINFO operation in xfsctl(3).  STATX_DIOALIGN should be used instead when it
       is available.

       If none of the above is available, then direct I/O support and alignment restrictions can only be assumed from known characteristics of the filesystem, the individual file, the underlying storage
       device(s),  and  the  kernel version.  In Linux 2.4, most filesystems based on block devices require that the file offset and the length and memory address of all I/O segments be multiples of the
       filesystem block size (typically 4096 bytes).  In Linux 2.6.0, this was relaxed to the logical block size of the block device (typically 512 bytes).  A block device's logical block  size  can  be
       determined using the ioctl(2) BLKSSZGET operation or from the shell using the command:

           blockdev --getss

       O_DIRECT  I/Os should never be run concurrently with the fork(2) system call, if the memory buffer is a private mapping (i.e., any mapping created with the mmap(2) MAP_PRIVATE flag; this includes
       memory allocated on the heap and statically allocated buffers).  Any such I/Os, whether submitted via an asynchronous I/O interface or from another thread in the process, should be completed  be‐
       fore fork(2) is called.  Failure to do so can result in data corruption and undefined behavior in parent and child processes.  This restriction does not apply when the memory buffer for the O_DI‐
       RECT I/Os was created using shmat(2) or mmap(2) with the MAP_SHARED flag.  Nor does this restriction apply when the memory buffer has been advised as MADV_DONTFORK with madvise(2), ensuring  that
       it will not be available to the child after fork(2).

       The  O_DIRECT flag was introduced in SGI IRIX, where it has alignment restrictions similar to those of Linux 2.4.  IRIX has also a fcntl(2) call to query appropriate alignments, and sizes.  Free‐
       BSD 4.x introduced a flag of the same name, but without alignment restrictions.

       O_DIRECT support was added in Linux 2.4.10.  Older Linux kernels simply ignore this flag.  Some filesystems may not implement the flag, in which case open() fails with the error EINVAL if  it  is
       used.

       Applications  should  avoid mixing O_DIRECT and normal I/O to the same file, and especially to overlapping byte regions in the same file.  Even when the filesystem correctly handles the coherency
       issues in this situation, overall I/O throughput is likely to be slower than using either mode alone.  Likewise, applications should avoid mixing mmap(2) of files with  direct  I/O  to  the  same
       files.

       The  behavior  of O_DIRECT with NFS will differ from local filesystems.  Older kernels, or kernels configured in certain ways, may not support this combination.  The NFS protocol does not support
       passing the flag to the server, so O_DIRECT I/O will bypass the page cache only on the client; the server may still cache the I/O.  The client asks the server to make the I/O synchronous to  pre‐
       serve  the  synchronous  semantics  of  O_DIRECT.   Some servers will perform poorly under these circumstances, especially if the I/O size is small.  Some servers may also be configured to lie to
       clients about the I/O having reached stable storage; this will avoid the performance penalty at some risk to data integrity in the event of server power failure.  The Linux NFS client  places  no
       alignment restrictions on O_DIRECT I/O.

       In  summary,  O_DIRECT is a potentially powerful tool that should be used with caution.  It is recommended that applications treat use of O_DIRECT as a performance option which is disabled by de‐
       fault.

BUGS
       Currently, it is not possible to enable signal-driven I/O by specifying O_ASYNC when calling open(); use fcntl(2) to enable this flag.

       One must check for two different error codes, EISDIR and ENOENT, when trying to determine whether the kernel supports O_TMPFILE functionality.

       When both O_CREAT and O_DIRECTORY are specified in flags and the file specified by pathname does not exist, open() will create a regular file (i.e., O_DIRECTORY is ignored).

SEE ALSO
       chmod(2), chown(2), close(2), dup(2), fcntl(2), link(2), lseek(2), mknod(2), mmap(2), mount(2), open_by_handle_at(2), openat2(2),  read(2),  socket(2),  stat(2),  umask(2),  unlink(2),  write(2),
       fopen(3), acl(5), fifo(7), inode(7), path_resolution(7), symlink(7)

Linux man-pages 6.04                                                                            2023-04-03                                                                                         open(2)
