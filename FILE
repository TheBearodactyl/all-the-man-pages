FILE(3type)                                                                                                                                                                                    FILE(3type)

NAME
       FILE - input/output stream

LIBRARY
       Standard C library (libc)

SYNOPSIS
       #include <stdio.h>

       typedef /* ... */  FILE;

DESCRIPTION
       An object type used for streams.

STANDARDS
       C11, POSIX.1-2008.

HISTORY
       C89, POSIX.1-2001.

NOTES
       The following header also provides this type: <wchar.h>.

SEE ALSO
       fclose(3), flockfile(3), fopen(3), fprintf(3), fread(3), fscanf(3), stdin(3), stdio(3)

Linux man-pages 6.04                                                                            2023-03-30                                                                                     FILE(3type)
FILE(1)                                                                                 BSD General Commands Manual                                                                                FILE(1)

NAME
     file — determine file type

SYNOPSIS
     file [-bcdEhiklLNnprsSvzZ0] [--apple] [--exclude-quiet] [--extension] [--mime-encoding] [--mime-type] [-e testname] [-F separator] [-f namefile] [-m magicfiles] [-P name=value] file ...
     file -C [-m magicfiles]
     file [--help]

DESCRIPTION
     This manual page documents version 5.44 of the file command.

     file tests each argument in an attempt to classify it.  There are three sets of tests, performed in this order: filesystem tests, magic tests, and language tests.  The first test that succeeds
     causes the file type to be printed.

     The type printed will usually contain one of the words text (the file contains only printing characters and a few common control characters and is probably safe to read on an ASCII terminal),
     executable (the file contains the result of compiling a program in a form understandable to some UNIX kernel or another), or data meaning anything else (data is usually “binary” or non-printable).
     Exceptions are well-known file formats (core files, tar archives) that are known to contain binary data.  When modifying magic files or the program itself, make sure to preserve these keywords.
     Users depend on knowing that all the readable files in a directory have the word “text” printed.  Don't do as Berkeley did and change “shell commands text” to “shell script”.

     The filesystem tests are based on examining the return from a stat(2) system call.  The program checks to see if the file is empty, or if it's some sort of special file.  Any known file types ap‐
     propriate to the system you are running on (sockets, symbolic links, or named pipes (FIFOs) on those systems that implement them) are intuited if they are defined in the system header file
     <sys/stat.h>.

     The magic tests are used to check for files with data in particular fixed formats.  The canonical example of this is a binary executable (compiled program) a.out file, whose format is defined in
     <elf.h>, <a.out.h> and possibly <exec.h> in the standard include directory.  These files have a “magic number” stored in a particular place near the beginning of the file that tells the UNIX oper‐
     ating system that the file is a binary executable, and which of several types thereof.  The concept of a “magic number” has been applied by extension to data files.  Any file with some invariant
     identifier at a small fixed offset into the file can usually be described in this way.  The information identifying these files is read from the compiled magic file /usr/share/file/misc/magic.mgc,
     or the files in the directory /usr/share/file/misc/magic if the compiled file does not exist.  In addition, if $HOME/.magic.mgc or $HOME/.magic exists, it will be used in preference to the system
     magic files.

     If a file does not match any of the entries in the magic file, it is examined to see if it seems to be a text file.  ASCII, ISO-8859-x, non-ISO 8-bit extended-ASCII character sets (such as those
     used on Macintosh and IBM PC systems), UTF-8-encoded Unicode, UTF-16-encoded Unicode, and EBCDIC character sets can be distinguished by the different ranges and sequences of bytes that constitute
     printable text in each set.  If a file passes any of these tests, its character set is reported.  ASCII, ISO-8859-x, UTF-8, and extended-ASCII files are identified as “text” because they will be
     mostly readable on nearly any terminal; UTF-16 and EBCDIC are only “character data” because, while they contain text, it is text that will require translation before it can be read.  In addition,
     file will attempt to determine other characteristics of text-type files.  If the lines of a file are terminated by CR, CRLF, or NEL, instead of the Unix-standard LF, this will be reported.  Files
     that contain embedded escape sequences or overstriking will also be identified.

     Once file has determined the character set used in a text-type file, it will attempt to determine in what language the file is written.  The language tests look for particular strings (cf.
     <names.h>) that can appear anywhere in the first few blocks of a file.  For example, the keyword .br indicates that the file is most likely a troff(1) input file, just as the keyword struct indi‐
     cates a C program.  These tests are less reliable than the previous two groups, so they are performed last.  The language test routines also test for some miscellany (such as tar(1) archives, JSON
     files).

     Any file that cannot be identified as having been written in any of the character sets listed above is simply said to be “data”.

OPTIONS
     --apple
             Causes the file command to output the file type and creator code as used by older MacOS versions.  The code consists of eight letters, the first describing the file type, the latter the
             creator.  This option works properly only for file formats that have the apple-style output defined.

     -b, --brief
             Do not prepend filenames to output lines (brief mode).

     -C, --compile
             Write a magic.mgc output file that contains a pre-parsed version of the magic file or directory.

     -c, --checking-printout
             Cause a checking printout of the parsed form of the magic file.  This is usually used in conjunction with the -m option to debug a new magic file before installing it.

     -d      Prints internal debugging information to stderr.

     -E      On filesystem errors (file not found etc), instead of handling the error as regular output as POSIX mandates and keep going, issue an error message and exit.

     -e, --exclude testname
             Exclude the test named in testname from the list of tests made to determine the file type.  Valid test names are:

             apptype   EMX application type (only on EMX).

             ascii     Various types of text files (this test will try to guess the text encoding, irrespective of the setting of the ‘encoding’ option).

             encoding  Different text encodings for soft magic tests.

             tokens    Ignored for backwards compatibility.

             cdf       Prints details of Compound Document Files.

             compress  Checks for, and looks inside, compressed files.

             csv       Checks Comma Separated Value files.

             elf       Prints ELF file details, provided soft magic tests are enabled and the elf magic is found.

             json      Examines JSON (RFC-7159) files by parsing them for compliance.

             soft      Consults magic files.

             tar       Examines tar files by verifying the checksum of the 512 byte tar header.  Excluding this test can provide more detailed content description by using the soft magic method.

             text      A synonym for ‘ascii’.

     --exclude-quiet
             Like --exclude but ignore tests that file does not know about.  This is intended for compatibility with older versions of file.

     --extension
             Print a slash-separated list of valid extensions for the file type found.

     -F, --separator separator
             Use the specified string as the separator between the filename and the file result returned.  Defaults to ‘:’.

     -f, --files-from namefile
             Read the names of the files to be examined from namefile (one per line) before the argument list.  Either namefile or at least one filename argument must be present; to test the standard
             input, use ‘-’ as a filename argument.  Please note that namefile is unwrapped and the enclosed filenames are processed when this option is encountered and before any further options pro‐
             cessing is done.  This allows one to process multiple lists of files with different command line arguments on the same file invocation.  Thus if you want to set the delimiter, you need to
             do it before you specify the list of files, like: “-F @ -f namefile”, instead of: “-f namefile -F @”.

     -h, --no-dereference
             This option causes symlinks not to be followed (on systems that support symbolic links).  This is the default if the environment variable POSIXLY_CORRECT is not defined.

     -i, --mime
             Causes the file command to output mime type strings rather than the more traditional human readable ones.  Thus it may say ‘text/plain; charset=us-ascii’ rather than “ASCII text”.

     --mime-type, --mime-encoding
             Like -i, but print only the specified element(s).

     -k, --keep-going
             Don't stop at the first match, keep going.  Subsequent matches will be have the string ‘\012- ’ prepended.  (If you want a newline, see the -r option.)  The magic pattern with the highest
             strength (see the -l option) comes first.

     -l, --list
             Shows a list of patterns and their strength sorted descending by magic(5) strength which is used for the matching (see also the -k option).

     -L, --dereference
             This option causes symlinks to be followed, as the like-named option in ls(1) (on systems that support symbolic links).  This is the default if the environment variable POSIXLY_CORRECT is
             defined.

     -m, --magic-file magicfiles
             Specify an alternate list of files and directories containing magic.  This can be a single item, or a colon-separated list.  If a compiled magic file is found alongside a file or directory,
             it will be used instead.

     -N, --no-pad
             Don't pad filenames so that they align in the output.

     -n, --no-buffer
             Force stdout to be flushed after checking each file.  This is only useful if checking a list of files.  It is intended to be used by programs that want filetype output from a pipe.

     -p, --preserve-date
             On systems that support utime(3) or utimes(2), attempt to preserve the access time of files analyzed, to pretend that file never read them.

     -P, --parameter name=value
             Set various parameter limits.

                   Name         Default    Explanation
                   bytes        1048576    max number of bytes to read from file
                   elf_notes    256        max ELF notes processed
                   elf_phnum    2048       max ELF program sections processed
                   elf_shnum    32768      max ELF sections processed
                   encoding     65536      max number of bytes to scan for encoding evaluation
                   indir        50         recursion limit for indirect magic
                   name         50         use count limit for name/use magic
                   regex        8192       length limit for regex searches

     -r, --raw
             Don't translate unprintable characters to \ooo.  Normally file translates unprintable characters to their octal representation.

     -s, --special-files
             Normally, file only attempts to read and determine the type of argument files which stat(2) reports are ordinary files.  This prevents problems, because reading special files may have pecu‐
             liar consequences.  Specifying the -s option causes file to also read argument files which are block or character special files.  This is useful for determining the filesystem types of the
             data in raw disk partitions, which are block special files.  This option also causes file to disregard the file size as reported by stat(2) since on some systems it reports a zero size for
             raw disk partitions.

     -S, --no-sandbox
             On systems where libseccomp (https://github.com/seccomp/libseccomp) is available, the -S option disables sandboxing which is enabled by default.  This option is needed for file to execute
             external decompressing programs, i.e. when the -z option is specified and the built-in decompressors are not available.  On systems where sandboxing is not available, this option has no ef‐
             fect.

     -v, --version
             Print the version of the program and exit.

     -z, --uncompress
             Try to look inside compressed files.

     -Z, --uncompress-noreport
             Try to look inside compressed files, but report information about the contents only not the compression.

     -0, --print0
             Output a null character ‘\0’ after the end of the filename.  Nice to cut(1) the output.  This does not affect the separator, which is still printed.

             If this option is repeated more than once, then file prints just the filename followed by a NUL followed by the description (or ERROR: text) followed by a second NUL for each entry.

     --help  Print a help message and exit.

ENVIRONMENT
     The environment variable MAGIC can be used to set the default magic file name.  If that variable is set, then file will not attempt to open $HOME/.magic.  file adds “.mgc” to the value of this
     variable as appropriate.  The environment variable POSIXLY_CORRECT controls (on systems that support symbolic links), whether file will attempt to follow symlinks or not.  If set, then file follows
     symlink, otherwise it does not.  This is also controlled by the -L and -h options.

FILES
     /usr/share/file/misc/magic.mgc  Default compiled list of magic.
     /usr/share/file/misc/magic      Directory containing default magic files.

EXIT STATUS
     file will exit with 0 if the operation was successful or >0 if an error was encountered.  The following errors cause diagnostic messages, but don't affect the program exit code (as POSIX requires),
     unless -E is specified:
           •   A file cannot be found
           •   There is no permission to read a file
           •   The file type cannot be determined

EXAMPLES
           $ file file.c file /dev/{wd0a,hda}
           file.c:   C program text
           file:     ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV),
                     dynamically linked (uses shared libs), stripped
           /dev/wd0a: block special (0/0)
           /dev/hda: block special (3/0)

           $ file -s /dev/wd0{b,d}
           /dev/wd0b: data
           /dev/wd0d: x86 boot sector

           $ file -s /dev/hda{,1,2,3,4,5,6,7,8,9,10}
           /dev/hda:   x86 boot sector
           /dev/hda1:  Linux/i386 ext2 filesystem
           /dev/hda2:  x86 boot sector
           /dev/hda3:  x86 boot sector, extended partition table
           /dev/hda4:  Linux/i386 ext2 filesystem
           /dev/hda5:  Linux/i386 swap file
           /dev/hda6:  Linux/i386 swap file
           /dev/hda7:  Linux/i386 swap file
           /dev/hda8:  Linux/i386 swap file
           /dev/hda9:  empty
           /dev/hda10: empty

           $ file -i file.c file /dev/{wd0a,hda}
           file.c:      text/x-c
           file:        application/x-executable
           /dev/hda:    application/x-not-regular-file
           /dev/wd0a:   application/x-not-regular-file

SEE ALSO
     hexdump(1), od(1), strings(1), magic(5)

STANDARDS CONFORMANCE
     This program is believed to exceed the System V Interface Definition of FILE(CMD), as near as one can determine from the vague language contained therein.  Its behavior is mostly compatible with
     the System V program of the same name.  This version knows more magic, however, so it will produce different (albeit more accurate) output in many cases.

     The one significant difference between this version and System V is that this version treats any white space as a delimiter, so that spaces in pattern strings must be escaped.  For example,

           >10     string  language impress        (imPRESS data)

     in an existing magic file would have to be changed to

           >10     string  language\ impress       (imPRESS data)

     In addition, in this version, if a pattern string contains a backslash, it must be escaped.  For example

           0       string          \begindata      Andrew Toolkit document

     in an existing magic file would have to be changed to

           0       string          \\begindata     Andrew Toolkit document

     SunOS releases 3.2 and later from Sun Microsystems include a file command derived from the System V one, but with some extensions.  This version differs from Sun's only in minor ways.  It includes
     the extension of the ‘&’ operator, used as, for example,

           >16     long&0x7fffffff >0              not stripped

SECURITY
     On systems where libseccomp (https://github.com/seccomp/libseccomp) is available, file is enforces limiting system calls to only the ones necessary for the operation of the program.  This enforce‐
     ment does not provide any security benefit when file is asked to decompress input files running external programs with the -z option.  To enable execution of external decompressors, one needs to
     disable sandboxing using the -S option.

MAGIC DIRECTORY
     The magic file entries have been collected from various sources, mainly USENET, and contributed by various authors.  Christos Zoulas (address below) will collect additional or corrected magic file
     entries.  A consolidation of magic file entries will be distributed periodically.

     The order of entries in the magic file is significant.  Depending on what system you are using, the order that they are put together may be incorrect.  If your old file command uses a magic file,
     keep the old magic file around for comparison purposes (rename it to /usr/share/file/misc/magic.orig).

HISTORY
     There has been a file command in every UNIX since at least Research Version 4 (man page dated November, 1973).  The System V version introduced one significant major change: the external list of
     magic types.  This slowed the program down slightly but made it a lot more flexible.

     This program, based on the System V version, was written by Ian Darwin ⟨ian@darwinsys.com⟩ without looking at anybody else's source code.

     John Gilmore revised the code extensively, making it better than the first version.  Geoff Collyer found several inadequacies and provided some magic file entries.  Contributions of the ‘&’ opera‐
     tor by Rob McMahon, ⟨cudcv@warwick.ac.uk⟩, 1989.

     Guy Harris, ⟨guy@netapp.com⟩, made many changes from 1993 to the present.

     Primary development and maintenance from 1990 to the present by Christos Zoulas ⟨christos@astron.com⟩.

     Altered by Chris Lowth ⟨chris@lowth.com⟩, 2000: handle the -i option to output mime type strings, using an alternative magic file and internal logic.

     Altered by Eric Fischer ⟨enf@pobox.com⟩, July, 2000, to identify character codes and attempt to identify the languages of non-ASCII files.

     Altered by Reuben Thomas ⟨rrt@sc3d.org⟩, 2007-2011, to improve MIME support, merge MIME and non-MIME magic, support directories as well as files of magic, apply many bug fixes, update and fix a lot
     of magic, improve the build system, improve the documentation, and rewrite the Python bindings in pure Python.

     The list of contributors to the ‘magic’ directory (magic files) is too long to include here.  You know who you are; thank you.  Many contributors are listed in the source files.

LEGAL NOTICE
     Copyright (c) Ian F. Darwin, Toronto, Canada, 1986-1999.  Covered by the standard Berkeley Software Distribution copyright; see the file COPYING in the source distribution.

     The files tar.h and is_tar.c were written by John Gilmore from his public-domain tar(1) program, and are not covered by the above license.

BUGS
     Please report bugs and send patches to the bug tracker at https://bugs.astron.com/ or the mailing list at ⟨file@astron.com⟩ (visit https://mailman.astron.com/mailman/listinfo/file first to sub‐
     scribe).

TODO
     Fix output so that tests for MIME and APPLE flags are not needed all over the place, and actual output is only done in one place.  This needs a design.  Suggestion: push possible outputs on to a
     list, then pick the last-pushed (most specific, one hopes) value at the end, or use a default if the list is empty.  This should not slow down evaluation.

     The handling of MAGIC_CONTINUE and printing \012- between entries is clumsy and complicated; refactor and centralize.

     Some of the encoding logic is hard-coded in encoding.c and can be moved to the magic files if we had a !:charset annotation.

     Continue to squash all magic bugs.  See Debian BTS for a good source.

     Store arbitrarily long strings, for example for %s patterns, so that they can be printed out.  Fixes Debian bug #271672.  This can be done by allocating strings in a string pool, storing the string
     pool at the end of the magic file and converting all the string pointers to relative offsets from the string pool.

     Add syntax for relative offsets after current level (Debian bug #466037).

     Make file -ki work, i.e. give multiple MIME types.

     Add a zip library so we can peek inside Office2007 documents to print more details about their contents.

     Add an option to print URLs for the sources of the file descriptions.

     Combine script searches and add a way to map executable names to MIME types (e.g. have a magic value for !:mime which causes the resulting string to be looked up in a table).  This would avoid
     adding the same magic repeatedly for each new hash-bang interpreter.

     When a file descriptor is available, we can skip and adjust the buffer instead of the hacky buffer management we do now.

     Fix “name” and “use” to check for consistency at compile time (duplicate “name”, “use” pointing to undefined “name” ).  Make “name” / “use” more efficient by keeping a sorted list of names.  Spe‐
     cial-case ^ to flip endianness in the parser so that it does not have to be escaped, and document it.

     If the offsets specified internally in the file exceed the buffer size ( HOWMANY variable in file.h), then we don't seek to that offset, but we give up.  It would be better if buffer managements
     was done when the file descriptor is available so we can seek around the file.  One must be careful though because this has performance and thus security considerations, because one can slow down
     things by repeatedly seeking.

     There is support now for keeping separate buffers and having offsets from the end of the file, but the internal buffer management still needs an overhaul.

AVAILABILITY
     You can obtain the original author's latest version by anonymous FTP on ftp.astron.com in the directory /pub/file/file-X.YZ.tar.gz.

BSD                                                                                          October 26, 2022                                                                                          BSD
FILE(1P)                                                                                 POSIX Programmer's Manual                                                                                FILE(1P)

PROLOG
       This  manual  page is part of the POSIX Programmer's Manual.  The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or
       the interface may not be implemented on Linux.

NAME
       file — determine file type

SYNOPSIS
       file [-dh] [-M file] [-m file] file...

       file -i [-h] file...

DESCRIPTION
       The file utility shall perform a series of tests in sequence on each specified file in an attempt to classify it:

        1. If file does not exist, cannot be read, or its file status could not be determined, the output shall indicate that the file was processed, but that its type could not be determined.

        2. If the file is not a regular file, its file type shall be identified.  The file types directory, FIFO, socket, block special, and character special shall be identified as such.  Other  imple‐
           mentation-defined  file  types  may also be identified. If file is a symbolic link, by default the link shall be resolved and file shall test the type of file referenced by the symbolic link.
           (See the -h and -i options below.)

        3. If the length of file is zero, it shall be identified as an empty file.

        4. The file utility shall examine an initial segment of file and shall make a guess at identifying its contents based on position-sensitive tests. (The answer is not guaranteed  to  be  correct;
           see the -d, -M, and -m options below.)

        5. The file utility shall examine file and make a guess at identifying its contents based on context-sensitive default system tests. (The answer is not guaranteed to be correct.)

        6. The file shall be identified as a data file.

       If file does not exist, cannot be read, or its file status could not be determined, the output shall indicate that the file was processed, but that its type could not be determined.

       If file is a symbolic link, by default the link shall be resolved and file shall test the type of file referenced by the symbolic link.

OPTIONS
       The file utility shall conform to the Base Definitions volume of POSIX.1‐2017, Section 12.2, Utility Syntax Guidelines, except that the order of the -m, -d, and -M options shall be significant.

       The following options shall be supported by the implementation:

       -d        Apply any position-sensitive default system tests and context-sensitive default system tests to the file. This is the default if no -M or -m option is specified.

       -h        When  a symbolic link is encountered, identify the file as a symbolic link. If -h is not specified and file is a symbolic link that refers to a nonexistent file, file shall identify the
                 file as a symbolic link, as if -h had been specified.

       -i        If a file is a regular file, do not attempt to classify the type of the file further, but identify the file as specified in the STDOUT section.

       -M file   Specify the name of a file containing position-sensitive tests that shall be applied to a file in order to classify it (see the EXTENDED DESCRIPTION). No position-sensitive default sys‐
                 tem tests nor context-sensitive default system tests shall be applied unless the -d option is also specified.

       -m file   Specify the name of a file containing position-sensitive tests that shall be applied to a file in order to classify it (see the EXTENDED DESCRIPTION).

       If  the  -m  option is specified without specifying the -d option or the -M option, position-sensitive default system tests shall be applied after the position-sensitive tests specified by the -m
       option. If the -M option is specified with the -d option, the -m option, or both, or the -m option is specified with the -d option, the concatenation of the position-sensitive tests specified  by
       these options shall be applied in the order specified by the appearance of these options. If a -M or -m file option-argument is -, the results are unspecified.

OPERANDS
       The following operand shall be supported:

       file      A pathname of a file to be tested.

STDIN
       The standard input shall be used if a file operand is '-' and the implementation treats the '-' as meaning standard input.  Otherwise, the standard input shall not be used.

INPUT FILES
       The file can be any file type.

ENVIRONMENT VARIABLES
       The following environment variables shall affect the execution of file:

       LANG      Provide  a default value for the internationalization variables that are unset or null. (See the Base Definitions volume of POSIX.1‐2017, Section 8.2, Internationalization Variables for
                 the precedence of internationalization variables used to determine the values of locale categories.)

       LC_ALL    If set to a non-empty string value, override the values of all the other internationalization variables.

       LC_CTYPE  Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as opposed to multi-byte characters in arguments and input files).

       LC_MESSAGES
                 Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error and informative messages written to standard output.

       NLSPATH   Determine the location of message catalogs for the processing of LC_MESSAGES.

ASYNCHRONOUS EVENTS
       Default.

STDOUT
       In the POSIX locale, the following format shall be used to identify each operand, file specified:

           "%s: %s\n", <file>, <type>

       The values for <type> are unspecified, except that in the POSIX locale, if file is identified as one of the types listed in the following table, <type> shall contain (but is not limited  to)  the
       corresponding string, unless the file is identified by a position-sensitive test specified by a -M or -m option. Each <space> shown in the strings shall be exactly one <space>.

                                                                                     Table 4-9: File Utility Output Strings

       │                                             │      ────────────────────────────┬───────┬─────────────────────────────────────────────────────
       │                                             │                       If file is:│       │           <type> shall contain the string:   Notes
       │                                             │      ────────────────────────────┼───────┼─────────────────────────────────────────────────────
       │                                             │       Nonexistent                │       │           cannot open
       │                                             │                                  │       │
       │Block special                                │ block special                    │ 1     │
       │Character special                            │ character special                │ 1     │
       │Directory                                    │ directory                        │ 1     │
       │FIFO                                         │ fifo                             │ 1     │
       │Socket                                       │ socket                           │ 1     │
       │Symbolic link                                │ symbolic link to                 │ 1     │
       │Regular file                                 │ regular file                     │ 1,2   │
       │Empty regular file                           │ empty                            │ 3     │
       │Regular file that cannot be read             │ cannot open                      │ 3     │
       │                                             │                                  │       │
       │Executable binary                            │ executable                       │ 3,4,6 │
       │ar archive library (see ar)                  │ archive                          │ 3,4,6 │
       │Extended cpio format (see pax)               │ cpio archive                     │ 3,4,6 │
       │Extended tar format (see ustar in pax)       │ tar archive                      │ 3,4,6 │
       │                                             │                                  │       │
       │Shell script                                 │ commands text                    │ 3,5,6 │
       │C-language source                            │ c program text                   │ 3,5,6 │
       │FORTRAN source                               │ fortran program text             │ 3,5,6 │
       │                                             │                                  │       │
       │Regular file whose type cannot be determined │ data                             │ 3     │
       └─────────────────────────────────────────────┴──────────────────────────────────┴───────┘
       Notes:

                  1. This is a file type test.

                  2. This test is applied only if the -i option is specified.

                  3. This test is applied only if the -i option is not specified.

                  4. This is a position-sensitive default system test.

                  5. This is a context-sensitive default system test.

                  6. Position-sensitive default system tests and context-sensitive default system tests are not applied if the -M option is specified unless the -d option is also specified.

       In the POSIX locale, if file is identified as a symbolic link (see the -h option), the following alternative output format shall be used:

           "%s: %s %s\n", <file>, <type>, <contents of link>"

       If  the  file  named by the file operand does not exist, cannot be read, or the type of the file named by the file operand cannot be determined, this shall not be considered an error that affects
       the exit status.

STDERR
       The standard error shall be used only for diagnostic messages.

OUTPUT FILES
       None.

EXTENDED DESCRIPTION
       A file specified as an option-argument to the -m or -M options shall contain one position-sensitive test per line, which shall be applied to the file. If the test succeeds, the message  field  of
       the line shall be printed and no further tests shall be applied, with the exception that tests on immediately following lines beginning with a single '>' character shall be applied.

       Each  line  shall  be  composed of the following four <tab>-separated fields. (Implementations may allow any combination of one or more white-space characters other than <newline> to act as field
       separators.)

       offset    An unsigned number (optionally preceded by a single '>' character) specifying the offset, in bytes, of the value in the file that is to be compared against the value field of the  line.
                 If the file is shorter than the specified offset, the test shall fail.

                 If  the  offset begins with the character '>', the test contained in the line shall not be applied to the file unless the test on the last line for which the offset did not begin with a
                 '>' was successful. By default, the offset shall be interpreted as an unsigned decimal number. With a leading 0x or 0X, the offset shall be interpreted as a hexadecimal  number;  other‐
                 wise, with a leading 0, the offset shall be interpreted as an octal number.

       type      The type of the value in the file to be tested. The type shall consist of the type specification characters d, s, and u, specifying signed decimal, string, and unsigned decimal, respec‐
                 tively.

                 The type string shall be interpreted as the bytes from the file starting at the specified offset and including the same number of bytes specified by the  value  field.  If  insufficient
                 bytes remain in the file past the offset to match the value field, the test shall fail.

                 The  type  specification  characters  d  and u can be followed by an optional unsigned decimal integer that specifies the number of bytes represented by the type. The type specification
                 characters d and u can be followed by an optional C, S, I, or L, indicating that the value is of type char, short, int, or long, respectively.

                 The default number of bytes represented by the type specifiers d, f, and u shall correspond to their respective C-language types as follows. If the system claims conformance to  the  C-
                 Language Development Utilities option, those specifiers shall correspond to the default sizes used in the c99 utility. Otherwise, the default sizes shall be implementation-defined.

                 For  the  type  specifier characters d and u, the default number of bytes shall correspond to the size of a basic integer type of the implementation. For these specifier characters, the
                 implementation shall support values of the optional number of bytes to be converted corresponding to the number of bytes in the C-language types char, short, int, or long.   These  num‐
                 bers  can  also  be specified by an application as the characters C, S, I, and L, respectively. The byte order used when interpreting numeric values is implementation-defined, but shall
                 correspond to the order in which a constant of the corresponding type is stored in memory on the system.

                 All type specifiers, except for s, can be followed by a mask specifier of the form &number. The mask value shall be AND'ed with the value of the input file before  the  comparison  with
                 the value field of the line is made. By default, the mask shall be interpreted as an unsigned decimal number. With a leading 0x or 0X, the mask shall be interpreted as an unsigned hexa‐
                 decimal number; otherwise, with a leading 0, the mask shall be interpreted as an unsigned octal number.

                 The strings byte, short, long, and string shall also be supported as type fields, being interpreted as dC, dS, dL, and s, respectively.

       value     The value to be compared with the value from the file.

                 If the specifier from the type field is s or string, then interpret the value as a string. Otherwise, interpret it as a number. If the value is a string, then  the  test  shall  succeed
                 only when a string value exactly matches the bytes from the file.

                 If the value is a string, it can contain the following sequences:

                 \character  The  <backslash>-escape  sequences  as  specified in the Base Definitions volume of POSIX.1‐2017, Table 5-1, Escape Sequences and Associated Actions ('\\', '\a', '\b', '\f',
                             '\n', '\r', '\t', '\v').  In addition, the escape sequence '\ ' (the <backslash> character followed by a <space> character) shall be recognized to represent a <space>  char‐
                             acter. The results of using any other character, other than an octal digit, following the <backslash> are unspecified.

                 \octal      Octal  sequences  that  can  be used to represent characters with specific coded values. An octal sequence shall consist of a <backslash> followed by the longest sequence of
                             one, two, or three octal-digit characters (01234567).

                 By default, any value that is not a string shall be interpreted as a signed decimal number. Any such value, with a leading 0x or 0X, shall be interpreted as an unsigned hexadecimal num‐
                 ber; otherwise, with a leading zero, the value shall be interpreted as an unsigned octal number.

                 If the value is not a string, it can be preceded by a character indicating the comparison to be performed. Permissible characters and the comparisons they specify are as follows:

                 =     The test shall succeed if the value from the file equals the value field.

                 <     The test shall succeed if the value from the file is less than the value field.

                 >     The test shall succeed if the value from the file is greater than the value field.

                 &     The test shall succeed if all of the set bits in the value field are set in the value from the file.

                 ^     The test shall succeed if at least one of the set bits in the value field is not set in the value from the file.

                 x     The test shall succeed if the file is large enough to contain a value of the type specified starting at the offset specified.

       message   The  message  to  be  printed  if  the  test succeeds. The message shall be interpreted using the notation for the printf formatting specification; see printf.  If the value field was a
                 string, then the value from the file shall be the argument for the printf formatting specification; otherwise, the value from the file shall be the argument.

EXIT STATUS
       The following exit values shall be returned:

        0    Successful completion.

       >0    An error occurred.

CONSEQUENCES OF ERRORS
       Default.

       The following sections are informative.

APPLICATION USAGE
       The file utility can only be required to guess at many of the file types because only exhaustive testing can determine some types with certainty. For example, binary data on some  implementations
       might match the initial segment of an executable or a tar archive.

       Note  that  the  table  indicates that the output contains the stated string. Systems may add text before or after the string. For executables, as an example, the machine architecture and various
       facts about how the file was link-edited may be included. Note also that on systems that recognize shell script files starting with "#!" as executable files, these may be identified as executable
       binary files rather than as shell scripts.

EXAMPLES
       Determine whether an argument is a binary executable file:

           file -- "$1" | grep -q ':.*executable' &&
               printf "%s is executable.\n$1"

RATIONALE
       The -f option was omitted because the same effect can (and should) be obtained using the xargs utility.

       Historical  versions  of the file utility attempt to identify the following types of files: symbolic link, directory, character special, block special, socket, tar archive, cpio archive, SCCS ar‐
       chive, archive library, empty, compress output, pack output, binary data, C source, FORTRAN source, assembler source, nroff/troff/eqn/tbl source troff output, shell script, C shell  script,  Eng‐
       lish  text,  ASCII  text, various executables, APL workspace, compiled terminfo entries, and CURSES screen images. Only those types that are reasonably well specified in POSIX or are directly re‐
       lated to POSIX utilities are listed in the table.

       Historical systems have used a ``magic file'' named /etc/magic to help identify file types. Because it is generally useful for users and scripts to be able to identify special file types, the  -m
       flag  and a portable format for user-created magic files has been specified. No requirement is made that an implementation of file use this method of identifying files, only that users be permit‐
       ted to add their own classifying tests.

       In addition, three options have been added to historical practice. The -d flag has been added to permit users to cause their tests to follow any default system tests. The -i flag has  been  added
       to permit users to test portably for regular files in shell scripts. The -M flag has been added to permit users to ignore any default system tests.

       The  POSIX.1‐2008  description  of  default system tests and the interaction between the -d, -M, and -m options did not clearly indicate that there were two types of ``default system tests''. The
       ``position-sensitive tests'' determine file types by looking for certain string or binary values at specific offsets in the file being examined. These position-sensitive tests were implemented in
       historical  systems using the magic file described above.  Some of these tests are now built into the file utility itself on some implementations so the output can provide more detail than can be
       provided by magic files. For example, a magic file can easily identify a core file on most implementations, but cannot name the program file that dropped the core. A magic file could produce out‐
       put such as:

           /home/dwc/core: ELF 32-bit MSB core file SPARC Version 1

       but by building the test into the file utility, you could get output such as:

           /home/dwc/core: ELF 32-bit MSB core file SPARC Version 1, from 'testprog'

       These extended built-in tests are still to be treated as position-sensitive default system tests even if they are not listed in /etc/magic or any other magic file.

       The  context-sensitive  default  system  tests  were always built into the file utility. These tests looked for language constructs in text files trying to identify shell scripts, C, FORTRAN, and
       other computer language source files, and even plain text files. With the addition of the -m and -M options the distinction between position-sensitive and context-sensitive default  system  tests
       became  important because the order of testing is important. The context-sensitive system default tests should never be applied before any position-sensitive tests even if the -d option is speci‐
       fied before a -m option or -M option due to the high probability that the context-sensitive system default tests will incorrectly identify arbitrary text files as text files before  position-sen‐
       sitive tests specified by the -m or -M option would be applied to give a more accurate identification.

       Leaving  the  meaning  of  -M  - and -m - unspecified allows an existing prototype of these options to continue to work in a backwards-compatible manner. (In that implementation, -M - was roughly
       equivalent to -d in POSIX.1‐2008.)

       The historical -c option was omitted as not particularly useful to users or portable shell scripts. In addition, a reasonable implementation of the file utility would report any errors found each
       time the magic file is read.

       The  historical  format of the magic file was the same as that specified by the Rationale in the ISO POSIX‐2:1993 standard for the offset, value, and message fields; however, it used less precise
       type fields than the format specified by the current normative text. The new type field values are a superset of the historical ones.

       The following is an example magic file:

           0  short     070707              cpio archive
           0  short     0143561             Byte-swapped cpio archive
           0  string    070707              ASCII cpio archive
           0  long      0177555             Very old archive
           0  short     0177545             Old archive
           0  short     017437              Old packed data
           0  string    \037\036            Packed data
           0  string    \377\037            Compacted data
           0  string    \037\235            Compressed data
           >2 byte&0x80 >0                  Block compressed
           >2 byte&0x1f x                   %d bits
           0  string    \032\001            Compiled Terminfo Entry
           0  short     0433                Curses screen image
           0  short     0434                Curses screen image
           0  string    <ar>                System V Release 1 archive
           0  string    !<arch>\n__.SYMDEF  Archive random library
           0  string    !<arch>             Archive
           0  string    ARF_BEGARF          PHIGS clear text archive
           0  long      0x137A2950          Scalable OpenFont binary
           0  long      0x137A2951          Encrypted scalable OpenFont binary

       The use of a basic integer data type is intended to allow the implementation to choose a word size commonly used by applications on that architecture.

       Earlier versions of this standard allowed for implementations with bytes other than eight bits, but this has been modified in this version.

FUTURE DIRECTIONS
       None.

SEE ALSO
       ar, ls, pax, printf

       The Base Definitions volume of POSIX.1‐2017, Table 5-1, Escape Sequences and Associated Actions, Chapter 8, Environment Variables, Section 12.2, Utility Syntax Guidelines

COPYRIGHT
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group
       Base  Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any discrepancy between this ver‐
       sion and the original IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be  obtained  online  at  http://www.open‐
       group.org/unix/online.html .

       Any  typographical  or  formatting errors that appear in this page are most likely to have been introduced during the conversion of the source files to man page format. To report such errors, see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                                                                2017                                                                                           FILE(1P)
file(n)                                                                                    Tcl Built-In Commands                                                                                   file(n)

__________________________________________________________________________________________________________________________________________________________________________________________________________

NAME
       file - Manipulate file names and attributes

SYNOPSIS
       file option name ?arg arg ...?
__________________________________________________________________________________________________________________________________________________________________________________________________________

DESCRIPTION
       This  command provides several operations on a file's name or attributes.  Name is the name of a file; if it starts with a tilde, then tilde substitution is done before executing the command (see
       the manual entry for filename for details).  Option indicates what to do with the file name.  Any unique abbreviation for option is acceptable.  The valid options are:

       file atime name ?time?
              Returns a decimal string giving the time at which file name was last accessed.  If time is specified, it is an access time to set for the file.  The time is measured in the standard  POSIX
              fashion  as seconds from a fixed starting time (often January 1, 1970).  If the file does not exist or its access time cannot be queried or set then an error is generated.  On Windows, FAT
              file systems do not support access time.

       file attributes name

       file attributes name ?option?

       file attributes name ?option value option value...?
              This subcommand returns or sets platform-specific values associated with a file. The first form returns a list of the platform-specific options and their values. The  second  form  returns
              the value for the given option. The third form sets one or more of the values. The values are as follows:

              On  Unix, -group gets or sets the group name for the file. A group id can be given to the command, but it returns a group name.  -owner gets or sets the user name of the owner of the file.
              The command returns the owner name, but the numerical id can be passed when setting the owner. -permissions retrieves or sets a file's access permissions, using octal notation by  default.
              This option also provides limited support for setting permissions using the symbolic notation accepted by the chmod command, following the form [ugo]?[[+-=][rwxst],[...]]. Multiple permis‐
              sion specifications may be given, separated by commas. E.g., u+s,go-rw would set the setuid bit for a file's owner as well as remove read and write permission  for  the  file's  group  and
              other  users.  An  ls-style  string of the form rwxrwxrwx is also accepted but must always be 9 characters long. E.g., rwxr-xr-t is equivalent to 01755. On versions of Unix supporting file
              flags, -readonly returns the value of, or sets, or clears the readonly attribute of a file, i.e., the user immutable flag (uchg) to the chflags command.

              On Windows, -archive gives the value or sets or clears the archive attribute of the file. -hidden gives the value or sets or clears the hidden attribute of the file. -longname will  expand
              each  path  element to its long version. This attribute cannot be set. -readonly gives the value or sets or clears the readonly attribute of the file. -shortname gives a string where every
              path element is replaced with its short (8.3) version of the name. This attribute cannot be set. -system gives or sets or clears the value of the system attribute of the file.

              On Mac OS X and Darwin, -creator gives or sets the Finder creator type of the file. -hidden gives or sets or clears the hidden attribute of the file. -readonly gives or sets or clears  the
              readonly  attribute  of  the  file.  -rsrclength  gives the length of the resource fork of the file, this attribute can only be set to the value 0, which results in the resource fork being
              stripped off the file.

       file channels ?pattern?
              If pattern is not specified, returns a list of names of all registered open channels in this interpreter.  If pattern is specified, only those names matching pattern are returned.   Match‐
              ing is determined using the same rules as for string match.

       file copy ?-force? ?--? source target

       file copy ?-force? ?--? source ?source ...? targetDir
              The  first  form makes a copy of the file or directory source under the pathname target. If target is an existing directory, then the second form is used.  The second form makes a copy in‐
              side targetDir of each source file listed.  If a directory is specified as a source, then the contents of the directory will be recursively copied into targetDir. Existing files  will  not
              be  overwritten  unless the -force option is specified (when Tcl will also attempt to adjust permissions on the destination file or directory if that is necessary to allow the copy to pro‐
              ceed).  When copying within a single filesystem, file copy will copy soft links (i.e.  the links themselves are copied, not the things they point to).  Trying to overwrite a non-empty  di‐
              rectory,  overwrite  a  directory with a file, or overwrite a file with a directory will all result in errors even if -force was specified.  Arguments are processed in the order specified,
              halting at the first error, if any.  A -- marks the end of switches; the argument following the -- will be treated as a source even if it starts with a -.

       file delete ?-force? ?--? ?pathname ... ?
              Removes the file or directory specified by each pathname argument.  Non-empty directories will be removed only if the -force option is specified.  When operating  on  symbolic  links,  the
              links themselves will be deleted, not the objects they point to.  Trying to delete a non-existent file is not considered an error.  Trying to delete a read-only file will cause the file to
              be deleted, even if the -force flags is not specified.  If the -force option is specified on a directory, Tcl will attempt both to change permissions and move the current  directory  “pwd”
              out  of  the  given  path if that is necessary to allow the deletion to proceed.  Arguments are processed in the order specified, halting at the first error, if any.  A -- marks the end of
              switches; the argument following the -- will be treated as a pathname even if it starts with a -.

       file dirname name
              Returns a name comprised of all of the path components in name excluding the last element.  If name is a relative file name and only contains one path element, then returns “.”.   If  name
              refers to a root directory, then the root directory is returned.  For example,

                     file dirname c:/

              returns c:/.

              Note that tilde substitution will only be performed if it is necessary to complete the command. For example,

                     file dirname ~/src/foo.c

              returns ~/src, whereas

                     file dirname ~

              returns /home (or something similar).

       file executable name
              Returns 1 if file name is executable by the current user, 0 otherwise. On Windows, which does not have an executable attribute, the command treats all directories and any files with exten‐
              sions exe, com, cmd or bat as executable.

       file exists name
              Returns 1 if file name exists and the current user has search privileges for the directories leading to it, 0 otherwise.

       file extension name
              Returns all of the characters in name after and including the last dot in the last element of name.  If there is no dot in the last element of name then returns the empty string.

       file isdirectory name
              Returns 1 if file name is a directory, 0 otherwise.

       file isfile name
              Returns 1 if file name is a regular file, 0 otherwise.

       file join name ?name ...?
              Takes one or more file names and combines them, using the correct path separator for the current platform.  If a particular name is relative, then it will be joined to  the  previous  file
              name argument.  Otherwise, any earlier arguments will be discarded, and joining will proceed from the current argument.  For example,

                     file join a b /foo bar

              returns /foo/bar.

              Note that any of the names can contain separators, and that the result is always canonical for the current platform: / for Unix and Windows.

       file link ?-linktype? linkName ?target?
              If  only  one  argument  is  given,  that argument is assumed to be linkName, and this command returns the value of the link given by linkName (i.e. the name of the file it points to).  If
              linkName is not a link or its value cannot be read (as, for example, seems to be the case with hard links, which look just like ordinary files), then an error is returned.

              If 2 arguments are given, then these are assumed to be linkName and target. If linkName already exists, or if target does not exist, an error will be returned.  Otherwise,  Tcl  creates  a
              new  link  called  linkName which points to the existing filesystem object at target (which is also the returned value), where the type of the link is platform-specific (on Unix a symbolic
              link will be the default).  This is useful for the case where the user wishes to create a link in a cross-platform way, and does not care what type of link is created.

              If the user wishes to make a link of a specific type only, (and signal an error if for some reason that is not possible), then the optional -linktype argument should  be  given.   Accepted
              values for -linktype are “-symbolic” and “-hard”.

              On  Unix, symbolic links can be made to relative paths, and those paths must be relative to the actual linkName's location (not to the cwd), but on all other platforms where relative links
              are not supported, target paths will always be converted to absolute, normalized form before the link is created (and therefore relative paths are interpreted  as  relative  to  the  cwd).
              Furthermore, “~user” paths are always expanded to absolute form.  When creating links on filesystems that either do not support any links, or do not support the specific type requested, an
              error message will be returned.  Most Unix platforms support both symbolic and hard links (the latter for files only). Windows supports symbolic directory links and hard file links on NTFS
              drives.

       file lstat name varName
              Same  as  stat  option (see below) except uses the lstat kernel call instead of stat.  This means that if name refers to a symbolic link the information returned in varName is for the link
              rather than the file it refers to.  On systems that do not support symbolic links this option behaves exactly the same as the stat option.

       file mkdir ?dir ...?
              Creates each directory specified.  For each pathname dir specified, this command will create all non-existing parent directories as well as dir itself.  If an existing directory is  speci‐
              fied,  then  no  action  is taken and no error is returned.  Trying to overwrite an existing file with a directory will result in an error.  Arguments are processed in the order specified,
              halting at the first error, if any.

       file mtime name ?time?
              Returns a decimal string giving the time at which file name was last modified.  If time is specified, it is a modification time to set for the file (equivalent to Unix touch).  The time is
              measured  in the standard POSIX fashion as seconds from a fixed starting time (often January 1, 1970).  If the file does not exist or its modified time cannot be queried or set then an er‐
              ror is generated.

       file nativename name
              Returns the platform-specific name of the file. This is useful if the filename is needed to pass to a platform-specific call, such as to a subprocess via exec under Windows  (see  EXAMPLES
              below).

       file normalize name
              Returns a unique normalized path representation for the file-system object (file, directory, link, etc), whose string value can be used as a unique identifier for it.  A normalized path is
              an absolute path which has all “../” and “./” removed.  Also it is one which is in the “standard” format for the native platform.  On Unix, this means the segments leading up to  the  path
              must be free of symbolic links/aliases (but the very last path component may be a symbolic link), and on Windows it also means we want the long form with that form's case-dependence (which
              gives us a unique, case-dependent path).  The one exception concerning the last link in the path is necessary, because Tcl or the user may wish to operate on the actual symbolic  link  it‐
              self (for example file delete, file rename, file copy are defined to operate on symbolic links, not on the things that they point to).

       file owned name
              Returns 1 if file name is owned by the current user, 0 otherwise.

       file pathtype name
              Returns  one of absolute, relative, volumerelative. If name refers to a specific file on a specific volume, the path type will be absolute. If name refers to a file relative to the current
              working directory, then the path type will be relative. If name refers to a file relative to the current working directory on a specified volume, or to a specific file on the current work‐
              ing volume, then the path type is volumerelative.

       file readable name
              Returns 1 if file name is readable by the current user, 0 otherwise.

       file readlink name
              Returns  the  value of the symbolic link given by name (i.e. the name of the file it points to).  If name is not a symbolic link or its value cannot be read, then an error is returned.  On
              systems that do not support symbolic links this option is undefined.

       file rename ?-force? ?--? source target

       file rename ?-force? ?--? source ?source ...? targetDir
              The first form takes the file or directory specified by pathname source and renames it to target, moving the file if the pathname target specifies a name in a different directory.  If tar‐
              get is an existing directory, then the second form is used.  The second form moves each source file or directory into the directory targetDir. Existing files will not be overwritten unless
              the -force option is specified.  When operating inside a single filesystem, Tcl will rename symbolic links rather than the things that they point to.  Trying to overwrite a  non-empty  di‐
              rectory, overwrite a directory with a file, or a file with a directory will all result in errors.  Arguments are processed in the order specified, halting at the first error, if any.  A --
              marks the end of switches; the argument following the -- will be treated as a source even if it starts with a -.

       file rootname name
              Returns all of the characters in name up to but not including the last “.”  character in the last component of name.  If the last component of name does not contain  a  dot,  then  returns
              name.

       file separator ?name?
              If  no  argument is given, returns the character which is used to separate path segments for native files on this platform.  If a path is given, the filesystem responsible for that path is
              asked to return its separator character.  If no file system accepts name, an error is generated.

       file size name
              Returns a decimal string giving the size of file name in bytes.  If the file does not exist or its size cannot be queried then an error is generated.

       file split name
              Returns a list whose elements are the path components in name.  The first element of the list will have the same path type as name.  All other elements will be relative.   Path  separators
              will be discarded unless they are needed to ensure that an element is unambiguously relative.  For example, under Unix

                     file split /foo/~bar/baz

              returns “/  foo  ./~bar  baz” to ensure that later commands that use the third component do not attempt to perform tilde substitution.

       file stat  name varName
              Invokes  the stat kernel call on name, and uses the variable given by varName to hold information returned from the kernel call.  VarName is treated as an array variable, and the following
              elements of that variable are set: atime, ctime, dev, gid, ino, mode, mtime, nlink, size, type, uid.  Each element except type is a decimal string with the value of the corresponding field
              from  the stat return structure; see the manual entry for stat for details on the meanings of the values.  The type element gives the type of the file in the same form returned by the com‐
              mand file type.  This command returns an empty string.

       file system name
              Returns a list of one or two elements, the first of which is the name of the filesystem to use for the file, and the second, if given, an arbitrary string representing the  filesystem-spe‐
              cific  nature  or type of the location within that filesystem.  If a filesystem only supports one type of file, the second element may not be supplied.  For example the native files have a
              first element “native”, and a second element which when given is a platform-specific type name for the file's system (e.g.  “NTFS”, “FAT”, on Windows).  A generic virtual file system might
              return the list “vfs ftp” to represent a file on a remote ftp site mounted as a virtual filesystem through an extension called “vfs”.  If the file does not belong to any filesystem, an er‐
              ror is generated.

       file tail name
              Returns all of the characters in the last filesystem component of name.  Any trailing directory separator in name is ignored.  If name contains no separators then returns name.   So,  file
              tail a/b, file tail a/b/ and file tail b all return b.

       file tempfile ?nameVar? ?template?
              Creates  a  temporary file and returns a read-write channel opened on that file.  If the nameVar is given, it specifies a variable that the name of the temporary file will be written into; │
              if absent, Tcl will attempt to arrange for the temporary file to be deleted once it is no longer required. If the template is present, it specifies parts of the template of the filename to │
              use when creating it (such as the directory, base-name or extension) though some platforms may ignore some or all of these parts and use a built-in default instead.                         │

              Note that temporary files are only ever created on the native filesystem. As such, they can be relied upon to be used with operating-system native APIs and external programs that require a │
              filename.                                                                                                                                                                                    │

       file type name
              Returns a string giving the type of file name, which will be one of file, directory, characterSpecial, blockSpecial, fifo, link, or socket.

       file volumes
              Returns the absolute paths to the volumes mounted on the system, as a proper Tcl list.  Without any virtual filesystems mounted as root volumes, on UNIX, the  command  will  always  return
              “/”,  since  all filesystems are locally mounted.  On Windows, it will return a list of the available local drives (e.g.  “a:/ c:/”).  If any virtual filesystem has mounted additional vol‐
              umes, they will be in the returned list.

       file writable name
              Returns 1 if file name is writable by the current user, 0 otherwise.

PORTABILITY ISSUES
       Unix
              These commands always operate using the real user and group identifiers, not the effective ones.

       Windows
              The file owned subcommand uses the user identifier (SID) of the process token, not the thread token which may be impersonating some other user.

EXAMPLES
       This procedure shows how to search for C files in a given directory that have a correspondingly-named object file in the current directory:

              proc findMatchingCFiles {dir} {
                  set files {}
                  switch $::tcl_platform(platform) {
                      windows {
                          set ext .obj
                      }
                      unix {
                         set ext .o
                      }
                  }
                  foreach file [glob -nocomplain -directory $dir *.c] {
                      set objectFile [file tail [file rootname $file]]$ext
                      if {[file exists $objectFile]} {
                          lappend files $file
                      }
                  }
                  return $files
              }

       Rename a file and leave a symbolic link pointing from the old location to the new place:

              set oldName foobar.txt
              set newName foo/bar.txt
              # Make sure that where we're going to move to exists...
              if {![file isdirectory [file dirname $newName]]} {
                  file mkdir [file dirname $newName]
              }
              file rename $oldName $newName
              file link -symbolic $oldName $newName

       On Windows, a file can be “started” easily enough (equivalent to double-clicking on it in the Explorer interface) but the name passed to the operating system must be in native format:

              exec {*}[auto_execok start] {} [file nativename ~/example.txt]

SEE ALSO
       filename(n), open(n), close(n), eof(n), gets(n), tell(n), seek(n), fblocked(n), flush(n)

KEYWORDS
       attributes, copy files, delete files, directory, file, move files, name, rename files, stat, user

Tcl                                                                                                 8.3                                                                                            file(n)
