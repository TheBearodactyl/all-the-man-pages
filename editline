EDITLINE(3)                                                                            BSD Library Functions Manual                                                                            EDITLINE(3)

NAME
     editline, el_init, el_init_fd, el_end, el_reset, el_gets, el_wgets, el_getc, el_wgetc, el_push, el_wpush, el_parse, el_wparse, el_set, el_wset, el_get, el_wget, el_source, el_resize, el_cursor,
     el_line, el_wline, el_insertstr, el_winsertstr, el_deletestr, el_wdeletestr, history_init, history_winit, history_end, history_wend, history, history_w, tok_init, tok_winit, tok_end, tok_wend,
     tok_reset, tok_wreset, tok_line, tok_wline, tok_str, tok_wstr — line editor, history and tokenization functions

LIBRARY
     Command Line Editor Library (libedit, -ledit)

SYNOPSIS
     #include <histedit.h>

     EditLine *
     el_init(const char *prog, FILE *fin, FILE *fout, FILE *ferr);

     EditLine *
     el_init_fd(const char *prog, FILE *fin, FILE *fout, FILE *ferr, int fdin, int fdout, int fderr);

     void
     el_end(EditLine *e);

     void
     el_reset(EditLine *e);

     const char *
     el_gets(EditLine *e, int *count);

     const wchar_t *
     el_wgets(EditLine *e, int *count);

     int
     el_getc(EditLine *e, char *ch);

     int
     el_wgetc(EditLine *e, wchar_t *wc);

     void
     el_push(EditLine *e, const char *mbs);

     void
     el_wpush(EditLine *e, const wchar_t *wcs);

     int
     el_parse(EditLine *e, int argc, const char *argv[]);

     int
     el_wparse(EditLine *e, int argc, const wchar_t *argv[]);

     int
     el_set(EditLine *e, int op, ...);

     int
     el_wset(EditLine *e, int op, ...);

     int
     el_get(EditLine *e, int op, ...);

     int
     el_wget(EditLine *e, int op, ...);

     int
     el_source(EditLine *e, const char *file);

     void
     el_resize(EditLine *e);

     int
     el_cursor(EditLine *e, int count);

     const LineInfo *
     el_line(EditLine *e);

     const LineInfoW *
     el_wline(EditLine *e);

     int
     el_insertstr(EditLine *e, const char *str);

     int
     el_winsertstr(EditLine *e, const wchar_t *str);

     void
     el_deletestr(EditLine *e, int count);

     void
     el_wdeletestr(EditLine *e, int count);

     History *
     history_init(void);

     HistoryW *
     history_winit(void);

     void
     history_end(History *h);

     void
     history_wend(HistoryW *h);

     int
     history(History *h, HistEvent *ev, int op, ...);

     int
     history_w(HistoryW *h, HistEventW *ev, int op, ...);

     Tokenizer *
     tok_init(const char *IFS);

     TokenizerW *
     tok_winit(const wchar_t *IFS);

     void
     tok_end(Tokenizer *t);

     void
     tok_wend(TokenizerW *t);

     void
     tok_reset(Tokenizer *t);

     void
     tok_wreset(TokenizerW *t);

     int
     tok_line(Tokenizer *t, const LineInfo *li, int *argc, const char **argv[], int *cursorc, int *cursoro);

     int
     tok_wline(TokenizerW *t, const LineInfoW *li, int *argc, const wchar_t **argv[], int *cursorc, int *cursoro);

     int
     tok_str(Tokenizer *t, const char *str, int *argc, const char **argv[]);

     int
     tok_wstr(TokenizerW *t, const wchar_t *str, int *argc, const wchar_t **argv[]);

DESCRIPTION
     The editline library provides generic line editing, history and tokenization functions, similar to those found in sh(1).

     These functions are available in the libedit library (which needs the libtermcap library).  Programs should be linked with -ledit -ltermcap.

     The editline library respects the LC_CTYPE locale set by the application program and never uses setlocale(3) to change the locale.

LINE EDITING FUNCTIONS
     The line editing functions use a common data structure, EditLine, which is created by el_init() or el_init_fd() and freed by el_end().

     The wide-character functions behave the same way as their narrow counterparts.

     The following functions are available:

     el_init()
           Initialize the line editor, and return a data structure to be used by all other line editing functions, or NULL on failure.  prog is the name of the invoking program, used when reading the
           editrc(5) file to determine which settings to use.  fin, fout and ferr are the input, output, and error streams (respectively) to use.  In this documentation, references to “the tty” are ac‐
           tually to this input/output stream combination.

     el_init_fd()
           Like el_init() but allows specifying file descriptors for the stdio(3) corresponding streams, in case those were created with funopen(3).

     el_end()
           Clean up and finish with e, assumed to have been created with el_init() or el_init_fd().

     el_reset()
           Reset the tty and the parser.  This should be called after an error which may have upset the tty's state.

     el_gets()
           Read a line from the tty.  count is modified to contain the number of characters read.  Returns the line read if successful, or NULL if no characters were read or if an error occurred.  If an
           error occurred, count is set to -1 and errno contains the error code that caused it.  The return value may not remain valid across calls to el_gets() and must be copied if the data is to be
           retained.

     el_wgetc()
           Read a wide character from the tty, respecting the current locale, or from the input queue described in editline(7) if that is not empty, and store it in wc.  If an invalid or incomplete
           character is found, it is discarded, errno is set to EILSEQ, and the next character is read and stored in wc.  Returns 1 if a valid character was read, 0 on end of file, or -1 on read(2)
           failure.  In the latter case, errno is set to indicate the error.

     el_getc()
           Read a wide character as described for el_wgetc() and return 0 on end of file or -1 on failure.  If the wide character can be represented as a single-byte character, convert it with wctob(3),
           store the result in ch, and return 1; otherwise, set errno to ERANGE and return -1.  In the C or POSIX locale, this simply reads a byte, but for any other locale, including UTF-8, this is
           rarely useful.

     el_wpush()
           Push the wide character string wcs back onto the input queue described in editline(7).  If the queue overflows, for example due to a recursive macro, or if an error occurs, for example be‐
           cause wcs is NULL or memory allocation fails, the function beeps at the user, but does not report the problem to the caller.

     el_push()
           Use the current locale to convert the multibyte string mbs to a wide character string, and pass the result to el_wpush().

     el_parse()
           Parses the argv array (which is argc elements in size) to execute builtin editline commands.  If the command is prefixed with “prog”: then el_parse() will only execute the command if “prog”
           matches the prog argument supplied to el_init().  The return value is -1 if the command is unknown, 0 if there was no error or “prog” didn't match, or 1 if the command returned an error.  Re‐
           fer to editrc(5) for more information.

     el_set()
           Set editline parameters.  op determines which parameter to set, and each operation has its own parameter list.  Returns 0 on success, -1 on failure.

           The following values for op are supported, along with the required argument list:

           EL_PROMPT, char *(*f)(EditLine *)
                 Define prompt printing function as f, which is to return a string that contains the prompt.

           EL_PROMPT_ESC, char *(*f)(EditLine *), char c
                 Same as EL_PROMPT, but the c argument indicates the start/stop literal prompt character.

                 If a start/stop literal character is found in the prompt, the character itself is not printed, but characters after it are printed directly to the terminal without affecting the state
                 of the current line.  A subsequent second start/stop literal character ends this behavior.  This is typically used to embed literal escape sequences that change the color/style of the
                 terminal in the prompt.  Note that the literal escape character cannot be the last character in the prompt, as the escape sequence is attached to the next character in the prompt.  0
                 unsets it.

           EL_REFRESH
                 Re-display the current line on the next terminal line.

           EL_RPROMPT, char *(*f)(EditLine *)
                 Define right side prompt printing function as f, which is to return a string that contains the prompt.

           EL_RPROMPT_ESC, char *(*f)(EditLine *), char c
                 Define the right prompt printing function but with a literal escape character.

           EL_TERMINAL, const char *type
                 Define terminal type of the tty to be type, or to TERM if type is NULL.

           EL_EDITOR, const char *mode
                 Set editing mode to mode, which must be one of “emacs” or “vi”.

           EL_SIGNAL, int flag
                 If flag is non-zero, editline will install its own signal handler for the following signals when reading command input: SIGCONT, SIGHUP, SIGINT, SIGQUIT, SIGSTOP, SIGTERM, SIGTSTP, and
                 SIGWINCH.  Otherwise, the current signal handlers will be used.

           EL_BIND, const char *, ..., NULL
                 Perform the bind builtin command.  Refer to editrc(5) for more information.

           EL_ECHOTC, const char *, ..., NULL
                 Perform the echotc builtin command.  Refer to editrc(5) for more information.

           EL_SETTC, const char *, ..., NULL
                 Perform the settc builtin command.  Refer to editrc(5) for more information.

           EL_SETTY, const char *, ..., NULL
                 Perform the setty builtin command.  Refer to editrc(5) for more information.

           EL_TELLTC, const char *, ..., NULL
                 Perform the telltc builtin command.  Refer to editrc(5) for more information.

           EL_ADDFN, const char *name, const char *help, unsigned char (*func)(EditLine *e, int ch)
                 Add a user defined function, func(), referred to as name which is invoked when a key which is bound to name is entered.  help is a description of name.  At invocation time, ch is the
                 key which caused the invocation.  The return value of func() should be one of:

                 CC_NORM       Add a normal character.

                 CC_NEWLINE    End of line was entered.

                 CC_EOF        EOF was entered.

                 CC_ARGHACK    Expecting further command input as arguments, do nothing visually.

                 CC_REFRESH    Refresh display.

                 CC_REFRESH_BEEP
                               Refresh display, and beep.

                 CC_CURSOR     Cursor moved, so update and perform CC_REFRESH.

                 CC_REDISPLAY  Redisplay entire input line.  This is useful if a key binding outputs extra information.

                 CC_ERROR      An error occurred.  Beep, and flush tty.

                 CC_FATAL      Fatal error, reset tty to known state.

           EL_HIST, History *(*func)(History *, int op, ...), const char *ptr
                 Defines which history function to use, which is usually history().  ptr should be the value returned by history_init().

           EL_EDITMODE, int flag
                 If flag is non-zero, editing is enabled (the default).  Note that this is only an indication, and does not affect the operation of editline.  At this time, it is the caller's responsi‐
                 bility to check this (using el_get()) to determine if editing should be enabled or not.

           EL_UNBUFFERED, int flag
                 If flag is zero, unbuffered mode is disabled (the default).  In unbuffered mode, el_gets() will return immediately after processing a single character.

           EL_SAFEREAD, int flag
                 If the flag argument is non-zero, then editline attempts to recover from read errors, ignoring the first interrrupted error, and trying to reset the input file descriptor to reset non-
                 blocking I/O.  This is disabled by default, and desirable only when editline is used in shell-like applications.

           EL_GETCFN, el_rfunc_t f
                 Whenever reading a character, use the function
                       int f(EditLine *e, wchar_t *wc)
                 which stores the character in wc and returns 1 on success, 0 on end of file, or -1 on I/O or encoding errors.  Functions internally using it include el_wgets(), el_wgetc(), el_gets(),
                 and el_getc().  Initially, a builtin function is installed, and replacing it is discouraged because writing such a function is very error prone.  The builtin function can be restored at
                 any time by passing the special value EL_BUILTIN_GETCFN instead of a function pointer.

           EL_CLIENTDATA, void *data
                 Register data to be associated with this EditLine structure.  It can be retrieved with the corresponding el_get() call.

           EL_SETFP, int fd, FILE *fp
                 Set the current editline file pointer for “input” fd = 0, “output” fd = 1, or “error” fd = 2 from fp.

     el_get()
           Get editline parameters.  op determines which parameter to retrieve into result.  Returns 0 if successful, -1 otherwise.

           The following values for op are supported, along with actual type of result:

           EL_PROMPT, char *(*f)(EditLine *), char *c
                 Set f to a pointer to the function that displays the prompt.  If c is not NULL, set it to the start/stop literal prompt character.

           EL_RPROMPT, char *(*f)(EditLine *), char *c
                 Set f to a pointer to the function that displays the prompt.  If c is not NULL, set it to the start/stop literal prompt character.

           EL_EDITOR, const char **n
                 Set the name of the editor in n, which will be one of “emacs” or “vi”.

           EL_GETTC, const char *name, void *value
                 If name is a valid termcap(5) capability set value to the current value of that capability.

           EL_SIGNAL, int *s
                 Set s to non-zero if editline has installed private signal handlers (see el_get() above).

           EL_EDITMODE, int *c
                 Set c to non-zero if editing is enabled.

           EL_GETCFN, el_rfunc_t *f
                 Set f to a pointer to the function that reads characters, or to EL_BUILTIN_GETCFN if the builtin function is in use.

           EL_CLIENTDATA, void **data
                 Set data to the previously registered client data set by an el_set() call.

           EL_UNBUFFERED, int *c
                 Set c to non-zero if unbuffered mode is enabled.

           EL_SAFEREAD, int *c
                 Set c to non-zero if safe read is set.

           EL_GETFP, int fd, FILE **fp
                 Set fp to the current editline file pointer for “input” fd = 0, “output” fd = 1, or “error” fd = 2.

     el_source()
           Initialize editline by reading the contents of file.  el_parse() is called for each line in file.  If file is NULL, try $EDITRC and if that is not set $HOME/.editrc.  Refer to editrc(5) for
           details on the format of file.  el_source() returns 0 on success and -1 on error.

     el_resize()
           Must be called if the terminal size changes.  If EL_SIGNAL has been set with el_set(), then this is done automatically.  Otherwise, it's the responsibility of the application to call
           el_resize() on the appropriate occasions.

     el_cursor()
           Move the cursor to the right (if positive) or to the left (if negative) count characters.  Returns the resulting offset of the cursor from the beginning of the line.

     el_line()
           Return the editing information for the current line in a LineInfo structure, which is defined as follows:

           typedef struct lineinfo {
               const char *buffer;    /* address of buffer */
               const char *cursor;    /* address of cursor */
               const char *lastchar;  /* address of last character */
           } LineInfo;

           buffer is not NUL terminated.  This function may be called after el_gets() to obtain the LineInfo structure pertaining to line returned by that function, and from within user defined func‐
           tions added with EL_ADDFN.

     el_insertstr()
           Insert str into the line at the cursor.  Returns -1 if str is empty or won't fit, and 0 otherwise.

     el_deletestr()
           Delete count characters before the cursor.

HISTORY LIST FUNCTIONS
     The history functions use a common data structure, History, which is created by history_init() and freed by history_end().

     The following functions are available:

     history_init()
           Initialize the history list, and return a data structure to be used by all other history list functions, or NULL on failure.

     history_end()
           Clean up and finish with h, assumed to have been created with history_init().

     history()
           Perform operation op on the history list, with optional arguments as needed by the operation.  ev is changed accordingly to operation.  The following values for op are supported, along with
           the required argument list:

           H_SETSIZE, int size
                 Set size of history to size elements.

           H_GETSIZE
                 Get number of events currently in history.

           H_END
                 Cleans up and finishes with h, assumed to be created with history_init().

           H_CLEAR
                 Clear the history.

           H_FUNC, void *ptr, history_gfun_t first, history_gfun_t next, history_gfun_t last, history_gfun_t prev, history_gfun_t curr, history_sfun_t set, history_vfun_t clear, history_efun_t enter,
                 history_efun_t add
                 Define functions to perform various history operations.  ptr is the argument given to a function when it's invoked.

           H_FIRST
                 Return the first element in the history.

           H_LAST
                 Return the last element in the history.

           H_PREV
                 Return the previous element in the history.  It is newer than the current one.

           H_NEXT
                 Return the next element in the history.  It is older than the current one.

           H_CURR
                 Return the current element in the history.

           H_SET, int position
                 Set the cursor to point to the requested element.

           H_ADD, const char *str
                 Append str to the current element of the history, or perform the H_ENTER operation with argument str if there is no current element.

           H_APPEND, const char *str
                 Append str to the last new element of the history.

           H_ENTER, const char *str
                 Add str as a new element to the history and, if necessary, removing the oldest entry to keep the list to the created size.  If H_SETUNIQUE has been called with a non-zero argument, the
                 element will not be entered into the history if its contents match the ones of the current history element.  If the element is entered history() returns 1; if it is ignored as a dupli‐
                 cate returns 0.  Finally history() returns -1 if an error occurred.

           H_PREV_STR, const char *str
                 Return the closest previous event that starts with str.

           H_NEXT_STR, const char *str
                 Return the closest next event that starts with str.

           H_PREV_EVENT, int e
                 Return the previous event numbered e.

           H_NEXT_EVENT, int e
                 Return the next event numbered e.

           H_LOAD, const char *file
                 Load the history list stored in file.

           H_SAVE, const char *file
                 Save the history list to file.

           H_SAVE_FP, FILE *fp
                 Save the history list to the opened FILE pointer fp.

           H_NSAVE_FP, size_t n, FILE *fp
                 Save the last n history entries to the opened FILE pointer fp.

           H_SETUNIQUE, int unique
                 Set flag that adjacent identical event strings should not be entered into the history.

           H_GETUNIQUE
                 Retrieve the current setting if adjacent identical elements should be entered into the history.

           H_DEL, int e
                 Delete the event numbered e.  This function is only provided for readline compatibility.  The caller is responsible for free'ing the string in the returned HistEvent.

           history() returns >= 0 if the operation op succeeds.  Otherwise, -1 is returned and ev is updated to contain more details about the error.

TOKENIZATION FUNCTIONS
     The tokenization functions use a common data structure, Tokenizer, which is created by tok_init() and freed by tok_end().

     The following functions are available:

     tok_init()
           Initialize the tokenizer, and return a data structure to be used by all other tokenizer functions.  IFS contains the Input Field Separators, which defaults to ⟨space⟩, ⟨tab⟩, and ⟨newline⟩ if
           NULL.

     tok_end()
           Clean up and finish with t, assumed to have been created with tok_init().

     tok_reset()
           Reset the tokenizer state.  Use after a line has been successfully tokenized by tok_line() or tok_str() and before a new line is to be tokenized.

     tok_line()
           Tokenize li, If successful, modify: argv to contain the words, argc to contain the number of words, cursorc (if not NULL) to contain the index of the word containing the cursor, and cursoro
           (if not NULL) to contain the offset within argv[cursorc] of the cursor.

           Returns 0 if successful, -1 for an internal error, 1 for an unmatched single quote, 2 for an unmatched double quote, and 3 for a backslash quoted ⟨newline⟩.  A positive exit code indicates
           that another line should be read and tokenization attempted again.

     tok_str()
           A simpler form of tok_line(); str is a NUL terminated string to tokenize.

SEE ALSO
     sh(1), signal(3), termcap(3), editrc(5), termcap(5), editline(7)

HISTORY
     The editline library first appeared in 4.4BSD.  CC_REDISPLAY appeared in NetBSD 1.3.  CC_REFRESH_BEEP, EL_EDITMODE and the readline emulation appeared in NetBSD 1.4.  EL_RPROMPT appeared in
     NetBSD 1.5.

AUTHORS
     The editline library was written by Christos Zoulas.  Luke Mewburn wrote this manual and implemented CC_REDISPLAY, CC_REFRESH_BEEP, EL_EDITMODE, and EL_RPROMPT.  Jaromir Dolecek implemented the
     readline emulation.  Johny Mattsson implemented wide-character support.

BUGS
     At this time, it is the responsibility of the caller to check the result of the EL_EDITMODE operation of el_get() (after an el_source() or el_parse()) to determine if editline should be used for
     further input.  I.e., EL_EDITMODE is purely an indication of the result of the most recent editrc(5) edit command.

BSD                                                                                           August 15, 2021                                                                                          BSD
EDITLINE(7)                                                                        BSD Miscellaneous Information Manual                                                                        EDITLINE(7)

NAME
     editline — line editing user interface

DESCRIPTION
     When a program using the editline(3) library prompts for an input string using the function el_wgets(3), it reads characters from the terminal.  Invalid input bytes that do not form characters are
     silently discarded.  For each character read, one editor command is executed.  The mapping of input characters to editor commands depends on the editing mode.  There are three editing modes: vi in‐
     sert mode, vi command mode, and emacs mode.  The default is vi insert mode.  The program can switch the default to emacs mode by using the el_set(3) or el_parse(3) functions, and the user can
     switch to emacs mode either in the editrc(5) configuration file or interactively with the ed-command editor command, in all three cases executing the bind -e builtin command.

     If trying to read from the terminal results in end of file or an error, the library signals end of file to the program and does not return a string.

   Input character bindings
     All default bindings described below can be overridden by individual programs and can be changed with the editrc(5) bind builtin command.

     In the following tables, ‘Ctrl-’ indicates a character with the bit 0x40 flipped, and ‘Meta-’ indicates a character with the bit 0x80 set.  In vi insert mode and in emacs mode, all Meta-characters
     considered printable by the current locale(1) are bound to ed-insert instead of to the editor command listed below.  Consequently, in UTF-8 mode, most of the Meta-characters are not directly acces‐
     sible because their code points are occupied by printable Unicode characters, and Meta-characters are usually input using the em-meta-next editor command.  For example, to enter ‘Meta-B’ in order
     to call the ed-prev-word editor command in emacs mode, call em-meta-next by pressing and releasing the escape key (or equivalently, Ctrl-[), then press and release the ‘B’ key.  If you have config‐
     ured a Meta-key on your keyboard, for example with ‘setxkbmap -option altwin:left_meta_win’, the Ctrl-Meta-characters are directly accessible.  For example, to enter ‘Ctrl-Meta-H’ in order to call
     the ed-delete-prev-word editor command in emacs mode, hold down the keys ‘Ctrl’, ‘Meta’, and ‘H’ at the same time.  Alternatively, press and release the escape key, then press and release ‘Ctrl-H’.

     In vi input mode, input characters are bound to the following editor commands by default:

           Ctrl-D, EOF     vi-list-or-eof
           Ctrl-H, BS      vi-delete-prev-char
           Ctrl-J, LF      ed-newline
           Ctrl-M, CR      ed-newline
           Ctrl-Q          ed-tty-start-output
           Ctrl-S          ed-tty-stop-output
           Ctrl-U          vi-kill-line-prev
           Ctrl-V          ed-quoted-insert
           Ctrl-W          ed-delete-prev-word
           Ctrl-[, ESC     vi-command-mode
           Ctrl-\, QUIT    ed-tty-sigquit
           Ctrl-?, DEL     vi-delete-prev-char

     All other input characters except the NUL character (Ctrl-@) are bound to ed-insert.

     In vi command mode, input characters are bound to the following editor commands by default:

           Ctrl-A          ed-move-to-beg
           Ctrl-C, INT     ed-tty-sigint
           Ctrl-E          ed-move-to-end
           Ctrl-H, BS      ed-delete-prev-char
           Ctrl-J, LF      ed-newline
           Ctrl-K          ed-kill-line
           Ctrl-L, FF      ed-clear-screen
           Ctrl-M, CR      ed-newline
           Ctrl-N          ed-next-history
           Ctrl-O          ed-tty-flush-output
           Ctrl-P          ed-prev-history
           Ctrl-Q          ed-tty-start-output
           Ctrl-R          ed-redisplay
           Ctrl-S          ed-tty-stop-output
           Ctrl-U          vi-kill-line-prev
           Ctrl-W          ed-delete-prev-word
           Ctrl-[, ESC     em-meta-next
           Ctrl-\, QUIT    ed-tty-sigquit
           Space           ed-next-char
           #               vi-comment-out
           $               ed-move-to-end
           %               vi-match
           +               ed-next-history
           ,               vi-repeat-prev-char
           -               ed-prev-history
           .               vi-redo
           /               vi-search-prev
           0               vi-zero
           1 to 9          ed-argument-digit
           :               ed-command
           ;               vi-repeat-next-char
           ?               vi-search-next
           @               vi-alias
           A               vi-add-at-eol
           B               vi-prev-big-word
           C               vi-change-to-eol
           D               ed-kill-line
           E               vi-end-big-word
           F               vi-prev-char
           G               vi-to-history-line
           I               vi-insert-at-bol
           J               ed-search-next-history
           K               ed-search-prev-history
           N               vi-repeat-search-prev
           O               ed-sequence-lead-in
           P               vi-paste-prev
           R               vi-replace-mode
           S               vi-substitute-line
           T               vi-to-prev-char
           U               vi-undo-line
           W               vi-next-big-word
           X               ed-delete-prev-char
           Y               vi-yank-end
           [               ed-sequence-lead-in
           ^               ed-move-to-beg
           _               vi-history-word
           a               vi-add
           b               vi-prev-word
           c               vi-change-meta
           d               vi-delete-meta
           e               vi-end-word
           f               vi-next-char
           h               ed-prev-char
           i               vi-insert
           j               ed-next-history
           k               ed-prev-history
           l               ed-next-char
           n               vi-repeat-search-next
           p               vi-paste-next
           r               vi-replace-char
           s               vi-substitute-char
           t               vi-to-next-char
           u               vi-undo
           v               vi-histedit
           w               vi-next-word
           x               ed-delete-next-char
           y               vi-yank
           |               vi-to-column
           ~               vi-change-case
           Ctrl-?, DEL     ed-delete-prev-char
           Meta-O          ed-sequence-lead-in
           Meta-[          ed-sequence-lead-in

     In emacs mode, input characters are bound to the following editor commands by default:

           0 to 9          ed-digit
           Ctrl-@, NUL     em-set-mark
           Ctrl-A          ed-move-to-beg
           Ctrl-B          ed-prev-char
           Ctrl-C, INT     ed-tty-sigint
           Ctrl-D, EOF     em-delete-or-list
           Ctrl-E          ed-move-to-end
           Ctrl-F          ed-next-char
           Ctrl-H, BS      em-delete-prev-char
           Ctrl-J, LF      ed-newline
           Ctrl-K          ed-kill-line
           Ctrl-L, FF      ed-clear-screen
           Ctrl-M, CR      ed-newline
           Ctrl-N          ed-next-history
           Ctrl-O          ed-tty-flush-output
           Ctrl-P          ed-prev-history
           Ctrl-Q          ed-tty-start-output
           Ctrl-R          ed-redisplay
           Ctrl-S          ed-tty-stop-output
           Ctrl-T          ed-transpose-chars
           Ctrl-U          ed-kill-line
           Ctrl-V          ed-quoted-insert
           Ctrl-W          em-kill-region
           Ctrl-X          ed-sequence-lead-in
           Ctrl-Y          em-yank
           Ctrl-Z, TSTP    ed-tty-sigtstp
           Ctrl-[, ESC     em-meta-next
           Ctrl-\, QUIT    ed-tty-sigquit
           Ctrl-]          ed-tty-dsusp
           Ctrl-?, DEL     em-delete-prev-char
           Ctrl-Meta-H     ed-delete-prev-word
           Ctrl-Meta-L     ed-clear-screen
           Ctrl-Meta-_     em-copy-prev-word
           Meta-0 to 9     ed-argument-digit
           Meta-B          ed-prev-word
           Meta-C          em-capitol-case
           Meta-D          em-delete-next-word
           Meta-F          em-next-word
           Meta-L          em-lower-case
           Meta-N          ed-search-next-history
           Meta-O          ed-sequence-lead-in
           Meta-P          ed-search-prev-history
           Meta-U          em-upper-case
           Meta-W          em-copy-region
           Meta-X          ed-command
           Meta-[          ed-sequence-lead-in
           Meta-b          ed-prev-word
           Meta-c          em-capitol-case
           Meta-d          em-delete-next-word
           Meta-f          em-next-word
           Meta-l          em-lower-case
           Meta-n          ed-search-next-history
           Meta-p          ed-search-prev-history
           Meta-u          em-upper-case
           Meta-w          em-copy-region
           Meta-x          ed-command
           Ctrl-Meta-?     ed-delete-prev-word

     The remaining ascii(7) characters in the range 0x20 to 0x7e are bound to ed-insert.

     If standard output is not connected to a terminal device or el_set(3) was used to set EL_EDITMODE to 0, all input character bindings are disabled and all characters typed are appended to the edit
     buffer.  In that case, the edit buffer is returned to the program after a newline or carriage return character is typed, or after the first character typed if el_set(3) was used to set
     EL_UNBUFFERED to non-zero.

   Editor commands
     Most editor commands accept an optional argument.  The argument is entered by prefixing the editor command with one or more of the editor commands ed-argument-digit, ed-digit,
     em-universal-argument, or vi-zero.  When an argument is not provided, it defaults to 1.  For most editor commands, the effect of an argument is to repeatedly execute the command that number of
     times.

     When talking about a character string from a left character to a right character, the left character is included in the string, while the right character is not included.

     If an editor command causes an error, the input character is discarded, no action occurs, and the terminal bell is rung.  In case of a non-fatal error, the terminal bell is also rung, but the edi‐
     tor command takes effect anyway.

     In the following list, the default key bindings are listed after each editor command.

     ed-argument-digit (vi command: 1 to 9; emacs: Meta-0 to Meta-9)
           If in argument input mode, append the input digit to the argument being read.  Otherwise, switch to argument input mode and use the input digit as the most significant digit of the argument.
           It is an error if the input character is not a digit or if the existing argument is already greater than a million.

     ed-clear-screen (vi command: Ctrl-L; emacs: Ctrl-L, Ctrl-Meta-L)
           Clear the screen and display the edit buffer at the top.  Ignore any argument.

     ed-command (vi command: ‘:’; emacs: Meta-X, Meta-x)
           Read a line from the terminal bypassing the normal line editing functionality and execute that line as an editrc(5) builtin command.  If in vi command mode, also switch back to vi insert
           mode.  Ignore any argument.

     ed-delete-next-char (vi command: x)
           Delete the character at the cursor position.  With an argument, delete that number of characters.  In emacs mode, it is an error if the cursor is at the end of the edit buffer.  In vi mode,
           the last character in the edit buffer is deleted in that case, and it is an error if the buffer is empty.

     ed-delete-prev-char (vi command: X, Ctrl-H, BS, Ctrl-?, DEL)
           Delete the character to the left of the cursor position.  With an argument, delete that number of characters.  It is an error if the cursor is at the beginning of the edit buffer.

     ed-delete-prev-word (vi: Ctrl-W; emacs: Ctrl-Meta-H, Ctrl-Meta-?)
           Move to the left to the closest beginning of a word, delete the string from that position to the cursor, and save it to the cut buffer.  With an argument, delete that number of words.  It is
           an error if the cursor is at the beginning of the edit buffer.

     ed-digit (emacs: 0 to 9)
           If in argument input mode, append the input digit to the argument being read.  Otherwise, call ed-insert.  It is an error if the input character is not a digit or if the existing argument is
           already greater than a million.

     ed-end-of-file (not bound by default)
           Discard the edit buffer and indicate end of file to the program.  Ignore any argument.

     ed-ignore (various)
           Discard the input character and do nothing.

     ed-insert (vi input: almost all; emacs: printable characters)
           In insert mode, insert the input character left of the cursor position.  In replace mode, overwrite the character at the cursor and move the cursor to the right by one character position.
           Accept an argument to do this repeatedly.  It is an error if the input character is the NUL character (Ctrl-@).  Failure to enlarge the edit buffer also results in an error.

     ed-kill-line (vi command: D, Ctrl-K; emacs: Ctrl-K, Ctrl-U)
           Delete the string from the cursor position to the end of the line and save it to the cut buffer.  Ignore any argument.

     ed-move-to-beg (vi command: ^, Ctrl-A; emacs: Ctrl-A)
           In vi mode, move the cursor to the first non-space character in the edit buffer.  In emacs mode, move the cursor to the beginning of the edit buffer.  Ignore any argument.  Can be used as a
           movement command after vi_change_meta, vi_delete_meta, or vi_yank.

     ed-move-to-end (vi command: $, Ctrl-E; emacs: Ctrl-E)
           Move the cursor to the end of the edit buffer.  Ignore any argument.  Can be used as a movement command after vi_change_meta, vi_delete_meta, or vi_yank.

     ed-newline (all modes: Ctrl-J, LF, Ctrl-M, CR)
           Append a newline character to the edit buffer and return the edit buffer to the program.  Ignore any argument.

     ed-next-char (vi command: Space, l; emacs: Ctrl-F)
           Move the cursor one character position to the right.  With an argument, move by that number of characters.  Can be used as a movement command after vi_change_meta, vi_delete_meta, or vi_yank.
           It is an error if the cursor is already at the end of the edit buffer.

     ed-next-history (vi command: j, +, Ctrl-N; emacs: Ctrl-N)
           Replace the edit buffer with the next history line.  That line is older than the current line.  With an argument, go forward by that number of history lines.  It is a non-fatal error to ad‐
           vance by more lines than are available.

     ed-next-line (not bound by default)
           Move the cursor down one line.  With an argument, move down by that number of lines.  It is an error if the edit buffer does not contain enough newline characters to the right of the cursor
           position.

     ed-prev-char (vi command: h; emacs: Ctrl-B)
           Move the cursor one character position to the left.  With an argument, move by that number of characters.  Can be used as a movement command after vi_change_meta, vi_delete_meta, or vi_yank.
           It is an error if the cursor is already at the beginning of the edit buffer.

     ed-prev-history (vi command: k, -, Ctrl-P; emacs: Ctrl-P)
           Replace the edit buffer with the previous history line.  That line is newer than the current line.  With an argument, go back by that number of lines.  It is a non-fatal error to back up by
           more lines than are available.

     ed-prev-line (not bound by default)
           Move the cursor up one line.  With an argument, move up by that number of lines.  It is an error if the edit buffer does not contain enough newline characters to the left of the cursor posi‐
           tion.

     ed-prev-word (emacs: Meta-B, Meta-b)
           Move the cursor to the left to the closest beginning of a word.  With an argument, repeat that number of times.  Can be used as a movement command after vi_change_meta, vi_delete_meta, or
           vi_yank.  It is an error if the cursor is already at the beginning of the edit buffer.

     ed-quoted-insert (vi insert, emacs: Ctrl-V)
           Read one character from the terminal bypassing the normal line editing functionality and call ed-insert on it.  If trying to read the character returns end of file or an error, call
           ed-end-of-file instead.

     ed-redisplay (vi command, emacs: Ctrl-R)
           Redisplay everything.  Ignore any argument.

     ed-search-next-history (vi command: J; emacs: Meta-N, Meta-n)
           Replace the edit buffer with the next matching history entry.

     ed-search-prev-history (vi command: K; emacs: Meta-P, Meta-p)
           Replace the edit buffer with the previous matching history entry.

     ed-sequence-lead-in (vi cmd: O, [; emacs: Ctrl-X; both: Meta-O, Meta-[)
           Call a macro.  See the section about Macros below for details.

     ed-start-over (not bound by default)
           Discard the contents of the edit buffer and start from scratch.  Ignore any argument.

     ed-transpose-chars (emacs: Ctrl-T)
           Exchange the character at the cursor position with the one to the left of it and move the cursor to the character to the right of the two exchanged characters.  Ignore any argument.  It is an
           error if the cursor is at the beginning of the edit buffer or if the edit buffer contains less than two characters.

     ed-unassigned (all characters not listed)
           This editor command always results in an error.

     em-capitol-case (emacs: Meta-C, Meta-c)
           Capitalize the string from the cursor to the end of the current word.  That is, if it contains at least one alphabetic character, convert the first alphabetic character to upper case, and
           convert all characters to the right of it to lower case.  In any case, move the cursor to the next character after the end of the current word.

     em-copy-prev-word (emacs: Ctrl-Meta-_)
           Copy the string from the beginning of the current word to the cursor and insert it to the left of the cursor.  Move the cursor to the character after the inserted string.  It is an error if
           the cursor is at the beginning of the edit buffer.

     em-copy-region (emacs: Meta-W, Meta-w)
           Copy the string from the cursor to the mark to the cut buffer.  It is an error if the mark is not set.

     em-delete-next-word (emacs: Meta-D, Meta-d)
           Delete the string from the cursor to the end of the current word and save it to the cut buffer.  It is an error if the cursor is at the end of the edit buffer.

     em-delete-or-list (emacs: Ctrl-D, EOF)
           If the cursor is not at the end of the line, delete the character at the cursor.  If the edit buffer is empty, indicate end of file to the program.  It is an error if the cursor is at the end
           of the edit buffer and the edit buffer is not empty.

     em-delete-prev-char (emacs: Ctrl-H, BS, Ctrl-?, DEL)
           Delete the character to the left of the cursor.  It is an error if the cursor is at the beginning of the edit buffer.

     em-exchange-mark (not bound by default)
           Exchange the cursor and the mark.

     em-gosmacs-transpose (not bound by default)
           Exchange the two characters to the left of the cursor.  It is an error if the cursor is on the first or second character of the edit buffer.

     em-inc-search-next (not bound by default)
           Emacs incremental next search.

     em-inc-search-prev (not bound by default)
           Emacs incremental reverse search.

     em-kill-line (not bound by default)
           Delete the entire contents of the edit buffer and save it to the cut buffer.

     em-kill-region (emacs: Ctrl-W)
           Delete the string from the cursor to the mark and save it to the cut buffer.  It is an error if the mark is not set.

     em-lower-case (emacs: Meta-L, Meta-l)
           Convert the characters from the cursor to the end of the current word to lower case.

     em-meta-next (vi command, emacs: Ctrl-[, ESC)
           Set the bit 0x80 on the next character typed.  Unless the resulting code point is printable, holding down the ‘Meta-’ key while typing that character is a simpler way to achieve the same ef‐
           fect.

     em-next-word (Meta-F, Meta-f)
           Move the cursor to the end of the current word.  Can be used as a movement command after vi_change_meta, vi_delete_meta, or vi_yank.  It is an error if the cursor is already at the end of the
           edit buffer.

     em-set-mark (emacs: Ctrl-Q, NUL)
           Set the mark at the current cursor position.

     em-toggle-overwrite (not bound by default)
           Switch from insert to overwrite mode or vice versa.

     em-universal-argument (not bound by default)
           If in argument input mode, multiply the argument by 4.  Otherwise, switch to argument input mode and set the argument to 4.  It is an error if the existing argument is already greater than a
           million.

     em-upper-case (emacs: Meta-U, Meta-u)
           Convert the characters from the cursor to the end of the current word to upper case.

     em-yank (emacs: Ctrl-Y)
           Paste the cut buffer to the left of the cursor.

     vi-add (vi command: a)
           Switch to vi insert mode.  Unless the cursor is already at the end of the edit buffer, move it one character position to the right.

     vi-add-at-eol (vi command: A)
           Switch to vi insert mode and move the cursor to the end of the edit buffer.

     vi-alias (vi command: @)
           If an alias function was defined by calling the el_set(3) or el_wset(3) function with the argument EL_ALIAS_TEXT, read one character from the terminal bypassing the normal line editing func‐
           tionality, call the alias function passing the argument that was specified with EL_ALIAS_TEXT as the first argument and the character read, with an underscore prepended, as the second argu‐
           ment, and pass the string returned from the alias function to el_wpush(3).  It is an error if no alias function is defined or if trying to read the character results in end of file or an er‐
           ror.

     vi-change-case (vi command: ~)
           Change the case of the character at the cursor and move the cursor one character position to the right.  It is an error if the cursor is already at the end of the edit buffer.

     vi-change-meta (vi command: c)
           Delete the string from the cursor to the position specified by the following movement command and save a copy of it to the cut buffer.  When given twice in a row, instead delete the whole
           contents of the edit buffer and save a copy of it to the cut buffer.  In either case, switch to vi insert mode after that.

     vi-change-to-eol (vi command: C)
           Delete the string from the cursor position to the end of the line and save it to the cut buffer, then switch to vi insert mode.

     vi-command-mode (vi insert: Ctrl-[, ESC)
           Discard pending actions and arguments and switch to vi command mode.  Unless the cursor is already at the beginning of the edit buffer, move it to the left by one character position.

     vi-comment-out (vi command: #)
           Insert a ‘#’ character at the beginning of the edit buffer and return the edit buffer to the program.

     vi-delete-meta (vi command: d)
           Delete the string from the cursor to the position specified by the following movement command and save a copy of it to the cut buffer.  When given twice in a row, instead delete the whole
           contents of the edit buffer and save a copy of it to the cut buffer.

     vi-delete-prev-char (vi insert: Ctrl-H, BS, Ctrl-?, DEL)
           Delete the character to the left of the cursor.  It is an error if the cursor is already at the beginning of the edit buffer.

     vi-end-big-word (vi command: E)
           Move the cursor to the end of the current space delimited word.  Can be used as a movement command after vi_change_meta, vi_delete_meta, or vi_yank.  It is an error if the cursor is already
           at the end of the edit buffer.

     vi-end-word (vi command: e)
           Move the cursor to the end of the current word.  Can be used as a movement command after vi_change_meta, vi_delete_meta, or vi_yank.  It is an error if the cursor is already at the end of the
           edit buffer.

     vi-history-word (vi command: _)
           Insert the first word from the most recent history entry after the cursor, move the cursor after to the character after the inserted word, and switch to vi insert mode.  It is an error if
           there is no history entry or the most recent history entry is empty.

     vi-insert (vi command: i)
           Enter insert mode.

     vi-insert-at-bol (vi command: I)
           Move the cursor to the beginning of the edit buffer and switch to vi insert mode.

     vi-kill-line-prev (vi: Ctrl-U)
           Delete the string from the beginning of the edit buffer to the cursor and save it to the cut buffer.

     vi-list-or-eof (vi insert: Ctrl-D, EOF)
           If the edit buffer is empty, indicate end of file to the program.  It is an error if the edit buffer is not empty.

     vi-match (vi command: %)
           Consider opening and closing parentheses, braces, and brackets as delimiters.  If the cursor is not at a delimiter, move it to the right until it gets to one, then move it to the matching de‐
           limiter.  Can be used as a movement command after vi_change_meta, vi_delete_meta, or vi_yank.  It is an error if there is no delimiter at the cursor or in the string to the right of the cur‐
           sor, or if the first such delimiter has no matching delimiter.

     vi-next-big-word (vi command: W)
           Move the cursor to the right to the beginning of the next space delimited word.  Can be used as a movement command after vi_change_meta, vi_delete_meta, or vi_yank.  It is an error if the
           cursor is already at the end of the edit buffer or on its last character.

     vi-next-char (vi command: f)
           Read one character from the terminal bypassing the normal line editing functionality and move the cursor to the right to the next instance of that character in the edit buffer.  Can be used
           as a movement command after vi_change_meta, vi_delete_meta, or vi_yank.  If trying to read the character results in end of file or an error, call ed-end-of-file instead.  It is an error if
           the character is not found searching to the right in the edit buffer.

     vi-next-word (vi command: w)
           Move the cursor to the right to the beginning of the next word.  Can be used as a movement command after vi_change_meta, vi_delete_meta, or vi_yank.  It is an error if the cursor is already
           at the end of the edit buffer or on its last character.

     vi-paste-next (vi command: p)
           Insert a copy of the cut buffer to the right of the cursor.  It is an error if the cut buffer is empty.

     vi-paste-prev (vi command: P)
           Insert a copy of the cut buffer to the left of the cursor.  It is an error if the cut buffer is empty.

     vi-prev-big-word (vi command: B)
           Move the cursor to the left to the next beginning of a space delimited word.  Can be used as a movement command after vi_change_meta, vi_delete_meta, or vi_yank.  It is an error if the cursor
           is already at the beginning of the edit buffer.

     vi-prev-char (vi command: F)
           Read one character from the terminal bypassing the normal line editing functionality and move the cursor to the left to the next instance of that character in the edit buffer.  Can be used as
           a movement command after vi_change_meta, vi_delete_meta, or vi_yank.  If trying to read the character results in end of file or an error, call ed-end-of-file instead.  It is an error if the
           character is not found searching to the left in the edit buffer.

     vi-prev-word (vi command: b)
           Move the cursor to the left to the next beginning of a word.  Can be used as a movement command after vi_change_meta, vi_delete_meta, or vi_yank.  It is an error if the cursor is already at
           the beginning of the edit buffer.

     vi-redo (vi command: ‘.’)
           Redo the last non-motion command.

     vi-repeat-next-char (vi command: ‘;’)
           Repeat the most recent character search in the same search direction.  Can be used as a movement command after vi_change_meta, vi_delete_meta, or vi_yank.

     vi-repeat-prev-char (vi command: ‘,’)
           Repeat the most recent character search in the opposite search direction.  Can be used as a movement command after vi_change_meta, vi_delete_meta, or vi_yank.

     vi-repeat-search-next (vi command: n)
           Repeat the most recent history search in the same search direction.

     vi-repeat-search-prev (vi command: N)
           Repeat the most recent history search in the opposite search direction.

     vi-replace-char (vi command: r)
           Switch to vi replace mode, and automatically switch back to vi command mode after the next character typed.  See ed-insert for a description of replace mode.  It is an error if the cursor is
           at the end of the edit buffer.

     vi-replace-mode (vi command: R)
           Switch to vi replace mode.  This is a variant of vi insert mode; see ed-insert for the difference.

     vi-search-next (vi command: ?)
           Replace the edit buffer with the next matching history entry.

     vi-search-prev (vi command: /)
           Replace the edit buffer with the previous matching history entry.

     vi-substitute-char (vi command: s)
           Delete the character at the cursor and switch to vi insert mode.

     vi-substitute-line (vi command: S)
           Delete the entire contents of the edit buffer, save a copy of it in the cut buffer, and enter vi insert mode.

     vi-to-column (vi command: |)
           Move the cursor to the column specified as the argument.  Can be used as a movement command after vi_change_meta, vi_delete_meta, or vi_yank.

     vi-to-history-line (vi command: G)
           Replace the edit buffer with the specified history entry.

     vi-to-next-char (vi command: t)
           Read one character from the terminal bypassing the normal line editing functionality and move the cursor to the right to the character before the next instance of that character in the edit
           buffer.  Can be used as a movement command after vi_change_meta, vi_delete_meta, or vi_yank.  If trying to read the character results in end of file or an error, call ed-end-of-file instead.
           It is an error if the character is not found searching to the right in the edit buffer.

     vi-to-prev-char (vi command: T)
           Read one character from the terminal bypassing the normal line editing functionality and move the cursor to the left to the character after the next instance of that character in the edit
           buffer.  Can be used as a movement command after vi_change_meta, vi_delete_meta, or vi_yank.  If trying to read the character results in end of file or an error, call ed-end-of-file instead.
           It is an error if the character is not found searching to the left in the edit buffer.

     vi-undo (vi command: u)
           Undo the last change.

     vi-undo-line (vi command: U)
           Undo all changes to the edit buffer.

     vi-yank (vi command: y)
           Copy the string from the cursor to the position specified by the following movement command to the cut buffer.  When given twice in a row, instead copy the whole contents of the edit buffer
           to the cut buffer.

     vi-yank-end (vi command: Y)
           Copy the string from the cursor to the end of the edit buffer to the cut buffer.

     vi-zero (vi command: 0)
           If in argument input mode, multiply the argument by ten.  Otherwise, move the cursor to the beginning of the edit buffer.  Can be used as a movement command after vi_change_meta,
           vi_delete_meta, or vi_yank.

   Macros
     If an input character is bound to the editor command ed-sequence-lead-in, editline attempts to call a macro.  If the input character by itself forms the name of a macro, that macro is executed.
     Otherwise, additional input characters are read until the string read forms the name of a macro, in which case that macro is executed, or until the string read matches the beginning of none of the
     existing macro names, in which case the string including the final, mismatching character is discarded and the terminal bell is rung.

     There are two kinds of macros.  Command macros execute a single editor command.  Keyboard macros return a string of characters that is appended as a new line to the Input Queue.

     The following command macros are defined by default in vi command mode and in emacs mode:

           Esc [ A, Esc O A    ed-prev-history
           Esc [ B, Esc O B    ed-next-history
           Esc [ C, Esc O C    ed-next-char
           Esc [ D, Esc O D    ed-prev-char
           Esc [ F, Esc O F    ed-move-to-end
           Esc [ H, Esc O H    ed-move-to-beg

     In vi command mode, they are also defined by default without the initial escape character.

     In addition, the editline library tries to bind the strings generated by the arrow keys as reported by the terminfo(5) database to these editor commands, unless that would clobber user settings.

     In emacs mode, the two-character string “Ctrl-X Ctrl-X” is bound to the em-exchange-mark editor command.

   Input Queue
     The editline library maintains an input queue operated in FIFO mode.  Whenever it needs an input character, it takes the first character from the first line of the input queue.  When the queue is
     empty, it reads from the terminal.

     A line can be appended to the end of the input queue in several ways:

           -   By calling one of the keyboard Macros.

           -   By calling the editor command vi-redo.

           -   By calling the editor command vi-alias.

           -   By pressing a key in emacs incremental search mode that doesn't have a special meaning in that mode but returns to normal emacs mode.

           -   If an application program directly calls the functions el_push(3) or el_wpush(3), it can provide additional, program-specific ways of appending to the input queue.

SEE ALSO
     mg(1), vi(1), editline(3), el_wgets(3), el_wpush(3), el_wset(3), editrc(5)

HISTORY
     This manual page first appeared in OpenBSD 6.0 and NetBSD 8.

AUTHORS
     This manual page was written by Ingo Schwarze <schwarze@openbsd.org>.

BSD                                                                                             May 7, 2016                                                                                            BSD
