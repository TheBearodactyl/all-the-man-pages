EVAL(1P)                                                                                 POSIX Programmer's Manual                                                                                EVAL(1P)

PROLOG
       This  manual  page is part of the POSIX Programmer's Manual.  The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or
       the interface may not be implemented on Linux.

NAME
       eval — construct command by concatenating arguments

SYNOPSIS
       eval [argument...]

DESCRIPTION
       The eval utility shall construct a command by concatenating arguments together, separating each with a <space> character.  The constructed command shall be read and executed by the shell.

OPTIONS
       None.

OPERANDS
       See the DESCRIPTION.

STDIN
       Not used.

INPUT FILES
       None.

ENVIRONMENT VARIABLES
       None.

ASYNCHRONOUS EVENTS
       Default.

STDOUT
       Not used.

STDERR
       The standard error shall be used only for diagnostic messages.

OUTPUT FILES
       None.

EXTENDED DESCRIPTION
       None.

EXIT STATUS
       If there are no arguments, or only null arguments, eval shall return a zero exit status; otherwise, it shall return the exit status of the command defined by the string of concatenated  arguments
       separated by <space> characters, or a non-zero exit status if the concatenation could not be parsed as a command and the shell is interactive (and therefore did not abort).

CONSEQUENCES OF ERRORS
       Default.

       The following sections are informative.

APPLICATION USAGE
       Since  eval  is not required to recognize the "--" end of options delimiter, in cases where the argument(s) to eval might begin with '-' it is recommended that the first argument is prefixed by a
       string that will not alter the commands to be executed, such as a <space> character:

           eval " $commands"

       or:

           eval " $(some_command)"

EXAMPLES
       foo=10 x=foo
       y='$'$x
       echo $y
       $foo
       eval y='$'$x
       echo $y
       10

RATIONALE
       This standard allows, but does not require, eval to recognize "--".  Although this means applications cannot use "--" to protect against options supported as an extension (or errors reported  for
       unsupported options), the nature of the eval utility is such that other means can be used to provide this protection (see APPLICATION USAGE above).

FUTURE DIRECTIONS
       None.

SEE ALSO
       Section 2.14, Special Built-In Utilities

COPYRIGHT
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group
       Base Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any discrepancy between this  ver‐
       sion  and  the  original  IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be obtained online at http://www.open‐
       group.org/unix/online.html .

       Any typographical or formatting errors that appear in this page are most likely to have been introduced during the conversion of the source files to man page format. To report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                                                                2017                                                                                           EVAL(1P)
eval(n)                                                                                    Tcl Built-In Commands                                                                                   eval(n)

__________________________________________________________________________________________________________________________________________________________________________________________________________

NAME
       eval - Evaluate a Tcl script

SYNOPSIS
       eval arg ?arg ...?
__________________________________________________________________________________________________________________________________________________________________________________________________________

DESCRIPTION
       Eval  takes one or more arguments, which together comprise a Tcl script containing one or more commands.  Eval concatenates all its arguments in the same fashion as the concat command, passes the
       concatenated string to the Tcl interpreter recursively, and returns the result of that evaluation (or any error generated by it).  Note that the list command quotes sequences of words in  such  a
       way that they are not further expanded by the eval command.

EXAMPLES
       Often, it is useful to store a fragment of a script in a variable and execute it later on with extra values appended. This technique is used in a number of places throughout the Tcl core (e.g. in
       fcopy, lsort and trace command callbacks). This example shows how to do this using core Tcl commands:

              set script {
                  puts "logging now"
                  lappend $myCurrentLogVar
              }
              set myCurrentLogVar log1
              # Set up a switch of logging variable part way through!
              after 20000 set myCurrentLogVar log2

              for {set i 0} {$i<10} {incr i} {
                  # Introduce a random delay
                  after [expr {int(5000 * rand())}]
                  update    ;# Check for the asynch log switch
                  eval $script $i [clock clicks]
              }

       Note that in the most common case (where the script fragment is actually just a list of words forming a command prefix), it is better to use {*}$script when doing this sort of invocation pattern.
       It is less general than the eval command, and hence easier to make robust in practice.  The following procedure acts in a way that is analogous to the lappend command, except it inserts the argu‐
       ment values at the start of the list in the variable:

              proc lprepend {varName args} {
                  upvar 1 $varName var
                  # Ensure that the variable exists and contains a list
                  lappend var
                  # Now we insert all the arguments in one go
                  set var [eval [list linsert $var 0] $args]
              }

       However, the last line would now normally be written without eval, like this:

              set var [linsert $var 0 {*}$args]

SEE ALSO
       catch(n), concat(n), error(n), errorCode(n), errorInfo(n), interp(n), list(n), namespace(n), subst(n), uplevel(n)

KEYWORDS
       concatenate, evaluate, script

Tcl                                                                                                                                                                                                eval(n)
